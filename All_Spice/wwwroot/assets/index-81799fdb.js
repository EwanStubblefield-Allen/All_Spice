var x_ = Object.defineProperty; var k_ = (t, e, n) => e in t ? x_(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n; var ld = (t, e, n) => (k_(t, typeof e != "symbol" ? e + "" : e, n), n); (function() { const e = document.createElement("link").relList; if (e && e.supports && e.supports("modulepreload")) return; for (const o of document.querySelectorAll('link[rel="modulepreload"]')) r(o); new MutationObserver(o => { for (const i of o) if (i.type === "childList") for (const s of i.addedNodes) s.tagName === "LINK" && s.rel === "modulepreload" && r(s) }).observe(document, { childList: !0, subtree: !0 }); function n(o) { const i = {}; return o.integrity && (i.integrity = o.integrity), o.referrerPolicy && (i.referrerPolicy = o.referrerPolicy), o.crossOrigin === "use-credentials" ? i.credentials = "include" : o.crossOrigin === "anonymous" ? i.credentials = "omit" : i.credentials = "same-origin", i } function r(o) { if (o.ep) return; o.ep = !0; const i = n(o); fetch(o.href, i) } })(); var yt = "top", Rt = "bottom", It = "right", wt = "left", va = "auto", Mo = [yt, Rt, It, wt], Pr = "start", _o = "end", mm = "clippingParents", iu = "viewport", no = "popper", gm = "reference", rl = Mo.reduce(function(t, e) { return t.concat([e + "-" + Pr, e + "-" + _o]) }, []), su = [].concat(Mo, [va]).reduce(function(t, e) { return t.concat([e, e + "-" + Pr, e + "-" + _o]) }, []), ym = "beforeRead", wm = "read", bm = "afterRead", vm = "beforeMain", _m = "main", Em = "afterMain", Am = "beforeWrite", Tm = "write", Sm = "afterWrite", Cm = [ym, wm, bm, vm, _m, Em, Am, Tm, Sm]; function fn(t) { return t ? (t.nodeName || "").toLowerCase() : null } function Pt(t) { if (t == null) return window; if (t.toString() !== "[object Window]") { var e = t.ownerDocument; return e && e.defaultView || window } return t } function Nr(t) { var e = Pt(t).Element; return t instanceof e || t instanceof Element } function $t(t) { var e = Pt(t).HTMLElement; return t instanceof e || t instanceof HTMLElement } function au(t) { if (typeof ShadowRoot > "u") return !1; var e = Pt(t).ShadowRoot; return t instanceof e || t instanceof ShadowRoot } function R_(t) { var e = t.state; Object.keys(e.elements).forEach(function(n) { var r = e.styles[n] || {}, o = e.attributes[n] || {}, i = e.elements[n]; !$t(i) || !fn(i) || (Object.assign(i.style, r), Object.keys(o).forEach(function(s) { var c = o[s]; c === !1 ? i.removeAttribute(s) : i.setAttribute(s, c === !0 ? "" : c) })) }) } function I_(t) { var e = t.state, n = { popper: { position: e.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} }; return Object.assign(e.elements.popper.style, n.popper), e.styles = n, e.elements.arrow && Object.assign(e.elements.arrow.style, n.arrow), function() { Object.keys(e.elements).forEach(function(r) { var o = e.elements[r], i = e.attributes[r] || {}, s = Object.keys(e.styles.hasOwnProperty(r) ? e.styles[r] : n[r]), c = s.reduce(function(u, a) { return u[a] = "", u }, {}); !$t(o) || !fn(o) || (Object.assign(o.style, c), Object.keys(i).forEach(function(u) { o.removeAttribute(u) })) }) } } const cu = { name: "applyStyles", enabled: !0, phase: "write", fn: R_, effect: I_, requires: ["computeStyles"] }; function cn(t) { return t.split("-")[0] } var Or = Math.max, Ys = Math.min, Eo = Math.round; function ol() { var t = navigator.userAgentData; return t != null && t.brands && Array.isArray(t.brands) ? t.brands.map(function(e) { return e.brand + "/" + e.version }).join(" ") : navigator.userAgent } function Om() { return !/^((?!chrome|android).)*safari/i.test(ol()) } function Ao(t, e, n) { e === void 0 && (e = !1), n === void 0 && (n = !1); var r = t.getBoundingClientRect(), o = 1, i = 1; e && $t(t) && (o = t.offsetWidth > 0 && Eo(r.width) / t.offsetWidth || 1, i = t.offsetHeight > 0 && Eo(r.height) / t.offsetHeight || 1); var s = Nr(t) ? Pt(t) : window, c = s.visualViewport, u = !Om() && n, a = (r.left + (u && c ? c.offsetLeft : 0)) / o, d = (r.top + (u && c ? c.offsetTop : 0)) / i, h = r.width / o, m = r.height / i; return { width: h, height: m, top: d, right: a + h, bottom: d + m, left: a, x: a, y: d } } function lu(t) { var e = Ao(t), n = t.offsetWidth, r = t.offsetHeight; return Math.abs(e.width - n) <= 1 && (n = e.width), Math.abs(e.height - r) <= 1 && (r = e.height), { x: t.offsetLeft, y: t.offsetTop, width: n, height: r } } function xm(t, e) { var n = e.getRootNode && e.getRootNode(); if (t.contains(e)) return !0; if (n && au(n)) { var r = e; do { if (r && t.isSameNode(r)) return !0; r = r.parentNode || r.host } while (r) } return !1 } function kn(t) { return Pt(t).getComputedStyle(t) } function P_(t) { return ["table", "td", "th"].indexOf(fn(t)) >= 0 } function ar(t) { return ((Nr(t) ? t.ownerDocument : t.document) || window.document).documentElement } function _a(t) { return fn(t) === "html" ? t : t.assignedSlot || t.parentNode || (au(t) ? t.host : null) || ar(t) } function ud(t) { return !$t(t) || kn(t).position === "fixed" ? null : t.offsetParent } function N_(t) { var e = /firefox/i.test(ol()), n = /Trident/i.test(ol()); if (n && $t(t)) { var r = kn(t); if (r.position === "fixed") return null } var o = _a(t); for (au(o) && (o = o.host); $t(o) && ["html", "body"].indexOf(fn(o)) < 0;) { var i = kn(o); if (i.transform !== "none" || i.perspective !== "none" || i.contain === "paint" || ["transform", "perspective"].indexOf(i.willChange) !== -1 || e && i.willChange === "filter" || e && i.filter && i.filter !== "none") return o; o = o.parentNode } return null } function Hi(t) { for (var e = Pt(t), n = ud(t); n && P_(n) && kn(n).position === "static";)n = ud(n); return n && (fn(n) === "html" || fn(n) === "body" && kn(n).position === "static") ? e : n || N_(t) || e } function uu(t) { return ["top", "bottom"].indexOf(t) >= 0 ? "x" : "y" } function bi(t, e, n) { return Or(t, Ys(e, n)) } function L_(t, e, n) { var r = bi(t, e, n); return r > n ? n : r } function km() { return { top: 0, right: 0, bottom: 0, left: 0 } } function Rm(t) { return Object.assign({}, km(), t) } function Im(t, e) { return e.reduce(function(n, r) { return n[r] = t, n }, {}) } var D_ = function(e, n) { return e = typeof e == "function" ? e(Object.assign({}, n.rects, { placement: n.placement })) : e, Rm(typeof e != "number" ? e : Im(e, Mo)) }; function B_(t) { var e, n = t.state, r = t.name, o = t.options, i = n.elements.arrow, s = n.modifiersData.popperOffsets, c = cn(n.placement), u = uu(c), a = [wt, It].indexOf(c) >= 0, d = a ? "height" : "width"; if (!(!i || !s)) { var h = D_(o.padding, n), m = lu(i), g = u === "y" ? yt : wt, y = u === "y" ? Rt : It, _ = n.rects.reference[d] + n.rects.reference[u] - s[u] - n.rects.popper[d], A = s[u] - n.rects.reference[u], E = Hi(i), T = E ? u === "y" ? E.clientHeight || 0 : E.clientWidth || 0 : 0, x = _ / 2 - A / 2, P = h[g], W = T - m[d] - h[y], Y = T / 2 - m[d] / 2 + x, Z = bi(P, Y, W), he = u; n.modifiersData[r] = (e = {}, e[he] = Z, e.centerOffset = Z - Y, e) } } function $_(t) { var e = t.state, n = t.options, r = n.element, o = r === void 0 ? "[data-popper-arrow]" : r; o != null && (typeof o == "string" && (o = e.elements.popper.querySelector(o), !o) || xm(e.elements.popper, o) && (e.elements.arrow = o)) } const Pm = { name: "arrow", enabled: !0, phase: "main", fn: B_, effect: $_, requires: ["popperOffsets"], requiresIfExists: ["preventOverflow"] }; function To(t) { return t.split("-")[1] } var M_ = { top: "auto", right: "auto", bottom: "auto", left: "auto" }; function F_(t, e) { var n = t.x, r = t.y, o = e.devicePixelRatio || 1; return { x: Eo(n * o) / o || 0, y: Eo(r * o) / o || 0 } } function fd(t) { var e, n = t.popper, r = t.popperRect, o = t.placement, i = t.variation, s = t.offsets, c = t.position, u = t.gpuAcceleration, a = t.adaptive, d = t.roundOffsets, h = t.isFixed, m = s.x, g = m === void 0 ? 0 : m, y = s.y, _ = y === void 0 ? 0 : y, A = typeof d == "function" ? d({ x: g, y: _ }) : { x: g, y: _ }; g = A.x, _ = A.y; var E = s.hasOwnProperty("x"), T = s.hasOwnProperty("y"), x = wt, P = yt, W = window; if (a) { var Y = Hi(n), Z = "clientHeight", he = "clientWidth"; if (Y === Pt(n) && (Y = ar(n), kn(Y).position !== "static" && c === "absolute" && (Z = "scrollHeight", he = "scrollWidth")), Y = Y, o === yt || (o === wt || o === It) && i === _o) { P = Rt; var re = h && Y === W && W.visualViewport ? W.visualViewport.height : Y[Z]; _ -= re - r.height, _ *= u ? 1 : -1 } if (o === wt || (o === yt || o === Rt) && i === _o) { x = It; var z = h && Y === W && W.visualViewport ? W.visualViewport.width : Y[he]; g -= z - r.width, g *= u ? 1 : -1 } } var ye = Object.assign({ position: c }, a && M_), De = d === !0 ? F_({ x: g, y: _ }, Pt(n)) : { x: g, y: _ }; if (g = De.x, _ = De.y, u) { var fe; return Object.assign({}, ye, (fe = {}, fe[P] = T ? "0" : "", fe[x] = E ? "0" : "", fe.transform = (W.devicePixelRatio || 1) <= 1 ? "translate(" + g + "px, " + _ + "px)" : "translate3d(" + g + "px, " + _ + "px, 0)", fe)) } return Object.assign({}, ye, (e = {}, e[P] = T ? _ + "px" : "", e[x] = E ? g + "px" : "", e.transform = "", e)) } function j_(t) { var e = t.state, n = t.options, r = n.gpuAcceleration, o = r === void 0 ? !0 : r, i = n.adaptive, s = i === void 0 ? !0 : i, c = n.roundOffsets, u = c === void 0 ? !0 : c, a = { placement: cn(e.placement), variation: To(e.placement), popper: e.elements.popper, popperRect: e.rects.popper, gpuAcceleration: o, isFixed: e.options.strategy === "fixed" }; e.modifiersData.popperOffsets != null && (e.styles.popper = Object.assign({}, e.styles.popper, fd(Object.assign({}, a, { offsets: e.modifiersData.popperOffsets, position: e.options.strategy, adaptive: s, roundOffsets: u })))), e.modifiersData.arrow != null && (e.styles.arrow = Object.assign({}, e.styles.arrow, fd(Object.assign({}, a, { offsets: e.modifiersData.arrow, position: "absolute", adaptive: !1, roundOffsets: u })))), e.attributes.popper = Object.assign({}, e.attributes.popper, { "data-popper-placement": e.placement }) } const fu = { name: "computeStyles", enabled: !0, phase: "beforeWrite", fn: j_, data: {} }; var as = { passive: !0 }; function H_(t) { var e = t.state, n = t.instance, r = t.options, o = r.scroll, i = o === void 0 ? !0 : o, s = r.resize, c = s === void 0 ? !0 : s, u = Pt(e.elements.popper), a = [].concat(e.scrollParents.reference, e.scrollParents.popper); return i && a.forEach(function(d) { d.addEventListener("scroll", n.update, as) }), c && u.addEventListener("resize", n.update, as), function() { i && a.forEach(function(d) { d.removeEventListener("scroll", n.update, as) }), c && u.removeEventListener("resize", n.update, as) } } const du = { name: "eventListeners", enabled: !0, phase: "write", fn: function() { }, effect: H_, data: {} }; var U_ = { left: "right", right: "left", bottom: "top", top: "bottom" }; function Rs(t) { return t.replace(/left|right|bottom|top/g, function(e) { return U_[e] }) } var V_ = { start: "end", end: "start" }; function dd(t) { return t.replace(/start|end/g, function(e) { return V_[e] }) } function hu(t) { var e = Pt(t), n = e.pageXOffset, r = e.pageYOffset; return { scrollLeft: n, scrollTop: r } } function pu(t) { return Ao(ar(t)).left + hu(t).scrollLeft } function K_(t, e) { var n = Pt(t), r = ar(t), o = n.visualViewport, i = r.clientWidth, s = r.clientHeight, c = 0, u = 0; if (o) { i = o.width, s = o.height; var a = Om(); (a || !a && e === "fixed") && (c = o.offsetLeft, u = o.offsetTop) } return { width: i, height: s, x: c + pu(t), y: u } } function W_(t) { var e, n = ar(t), r = hu(t), o = (e = t.ownerDocument) == null ? void 0 : e.body, i = Or(n.scrollWidth, n.clientWidth, o ? o.scrollWidth : 0, o ? o.clientWidth : 0), s = Or(n.scrollHeight, n.clientHeight, o ? o.scrollHeight : 0, o ? o.clientHeight : 0), c = -r.scrollLeft + pu(t), u = -r.scrollTop; return kn(o || n).direction === "rtl" && (c += Or(n.clientWidth, o ? o.clientWidth : 0) - i), { width: i, height: s, x: c, y: u } } function mu(t) { var e = kn(t), n = e.overflow, r = e.overflowX, o = e.overflowY; return /auto|scroll|overlay|hidden/.test(n + o + r) } function Nm(t) { return ["html", "body", "#document"].indexOf(fn(t)) >= 0 ? t.ownerDocument.body : $t(t) && mu(t) ? t : Nm(_a(t)) } function vi(t, e) { var n; e === void 0 && (e = []); var r = Nm(t), o = r === ((n = t.ownerDocument) == null ? void 0 : n.body), i = Pt(r), s = o ? [i].concat(i.visualViewport || [], mu(r) ? r : []) : r, c = e.concat(s); return o ? c : c.concat(vi(_a(s))) } function il(t) { return Object.assign({}, t, { left: t.x, top: t.y, right: t.x + t.width, bottom: t.y + t.height }) } function z_(t, e) { var n = Ao(t, !1, e === "fixed"); return n.top = n.top + t.clientTop, n.left = n.left + t.clientLeft, n.bottom = n.top + t.clientHeight, n.right = n.left + t.clientWidth, n.width = t.clientWidth, n.height = t.clientHeight, n.x = n.left, n.y = n.top, n } function hd(t, e, n) { return e === iu ? il(K_(t, n)) : Nr(e) ? z_(e, n) : il(W_(ar(t))) } function q_(t) { var e = vi(_a(t)), n = ["absolute", "fixed"].indexOf(kn(t).position) >= 0, r = n && $t(t) ? Hi(t) : t; return Nr(r) ? e.filter(function(o) { return Nr(o) && xm(o, r) && fn(o) !== "body" }) : [] } function G_(t, e, n, r) { var o = e === "clippingParents" ? q_(t) : [].concat(e), i = [].concat(o, [n]), s = i[0], c = i.reduce(function(u, a) { var d = hd(t, a, r); return u.top = Or(d.top, u.top), u.right = Ys(d.right, u.right), u.bottom = Ys(d.bottom, u.bottom), u.left = Or(d.left, u.left), u }, hd(t, s, r)); return c.width = c.right - c.left, c.height = c.bottom - c.top, c.x = c.left, c.y = c.top, c } function Lm(t) { var e = t.reference, n = t.element, r = t.placement, o = r ? cn(r) : null, i = r ? To(r) : null, s = e.x + e.width / 2 - n.width / 2, c = e.y + e.height / 2 - n.height / 2, u; switch (o) { case yt: u = { x: s, y: e.y - n.height }; break; case Rt: u = { x: s, y: e.y + e.height }; break; case It: u = { x: e.x + e.width, y: c }; break; case wt: u = { x: e.x - n.width, y: c }; break; default: u = { x: e.x, y: e.y } }var a = o ? uu(o) : null; if (a != null) { var d = a === "y" ? "height" : "width"; switch (i) { case Pr: u[a] = u[a] - (e[d] / 2 - n[d] / 2); break; case _o: u[a] = u[a] + (e[d] / 2 - n[d] / 2); break } } return u } function So(t, e) { e === void 0 && (e = {}); var n = e, r = n.placement, o = r === void 0 ? t.placement : r, i = n.strategy, s = i === void 0 ? t.strategy : i, c = n.boundary, u = c === void 0 ? mm : c, a = n.rootBoundary, d = a === void 0 ? iu : a, h = n.elementContext, m = h === void 0 ? no : h, g = n.altBoundary, y = g === void 0 ? !1 : g, _ = n.padding, A = _ === void 0 ? 0 : _, E = Rm(typeof A != "number" ? A : Im(A, Mo)), T = m === no ? gm : no, x = t.rects.popper, P = t.elements[y ? T : m], W = G_(Nr(P) ? P : P.contextElement || ar(t.elements.popper), u, d, s), Y = Ao(t.elements.reference), Z = Lm({ reference: Y, element: x, strategy: "absolute", placement: o }), he = il(Object.assign({}, x, Z)), re = m === no ? he : Y, z = { top: W.top - re.top + E.top, bottom: re.bottom - W.bottom + E.bottom, left: W.left - re.left + E.left, right: re.right - W.right + E.right }, ye = t.modifiersData.offset; if (m === no && ye) { var De = ye[o]; Object.keys(z).forEach(function(fe) { var He = [It, Rt].indexOf(fe) >= 0 ? 1 : -1, nt = [yt, Rt].indexOf(fe) >= 0 ? "y" : "x"; z[fe] += De[nt] * He }) } return z } function Y_(t, e) { e === void 0 && (e = {}); var n = e, r = n.placement, o = n.boundary, i = n.rootBoundary, s = n.padding, c = n.flipVariations, u = n.allowedAutoPlacements, a = u === void 0 ? su : u, d = To(r), h = d ? c ? rl : rl.filter(function(y) { return To(y) === d }) : Mo, m = h.filter(function(y) { return a.indexOf(y) >= 0 }); m.length === 0 && (m = h); var g = m.reduce(function(y, _) { return y[_] = So(t, { placement: _, boundary: o, rootBoundary: i, padding: s })[cn(_)], y }, {}); return Object.keys(g).sort(function(y, _) { return g[y] - g[_] }) } function X_(t) { if (cn(t) === va) return []; var e = Rs(t); return [dd(t), e, dd(e)] } function Z_(t) { var e = t.state, n = t.options, r = t.name; if (!e.modifiersData[r]._skip) { for (var o = n.mainAxis, i = o === void 0 ? !0 : o, s = n.altAxis, c = s === void 0 ? !0 : s, u = n.fallbackPlacements, a = n.padding, d = n.boundary, h = n.rootBoundary, m = n.altBoundary, g = n.flipVariations, y = g === void 0 ? !0 : g, _ = n.allowedAutoPlacements, A = e.options.placement, E = cn(A), T = E === A, x = u || (T || !y ? [Rs(A)] : X_(A)), P = [A].concat(x).reduce(function(ct, Xe) { return ct.concat(cn(Xe) === va ? Y_(e, { placement: Xe, boundary: d, rootBoundary: h, padding: a, flipVariations: y, allowedAutoPlacements: _ }) : Xe) }, []), W = e.rects.reference, Y = e.rects.popper, Z = new Map, he = !0, re = P[0], z = 0; z < P.length; z++) { var ye = P[z], De = cn(ye), fe = To(ye) === Pr, He = [yt, Rt].indexOf(De) >= 0, nt = He ? "width" : "height", pe = So(e, { placement: ye, boundary: d, rootBoundary: h, altBoundary: m, padding: a }), ie = He ? fe ? It : wt : fe ? Rt : yt; W[nt] > Y[nt] && (ie = Rs(ie)); var oe = Rs(ie), Re = []; if (i && Re.push(pe[De] <= 0), c && Re.push(pe[ie] <= 0, pe[oe] <= 0), Re.every(function(ct) { return ct })) { re = ye, he = !1; break } Z.set(ye, Re) } if (he) for (var $e = y ? 3 : 1, at = function(Xe) { var Oe = P.find(function(R) { var U = Z.get(R); if (U) return U.slice(0, Xe).every(function(j) { return j }) }); if (Oe) return re = Oe, "break" }, Ce = $e; Ce > 0; Ce--) { var rt = at(Ce); if (rt === "break") break } e.placement !== re && (e.modifiersData[r]._skip = !0, e.placement = re, e.reset = !0) } } const Dm = { name: "flip", enabled: !0, phase: "main", fn: Z_, requiresIfExists: ["offset"], data: { _skip: !1 } }; function pd(t, e, n) { return n === void 0 && (n = { x: 0, y: 0 }), { top: t.top - e.height - n.y, right: t.right - e.width + n.x, bottom: t.bottom - e.height + n.y, left: t.left - e.width - n.x } } function md(t) { return [yt, It, Rt, wt].some(function(e) { return t[e] >= 0 }) } function J_(t) { var e = t.state, n = t.name, r = e.rects.reference, o = e.rects.popper, i = e.modifiersData.preventOverflow, s = So(e, { elementContext: "reference" }), c = So(e, { altBoundary: !0 }), u = pd(s, r), a = pd(c, o, i), d = md(u), h = md(a); e.modifiersData[n] = { referenceClippingOffsets: u, popperEscapeOffsets: a, isReferenceHidden: d, hasPopperEscaped: h }, e.attributes.popper = Object.assign({}, e.attributes.popper, { "data-popper-reference-hidden": d, "data-popper-escaped": h }) } const Bm = { name: "hide", enabled: !0, phase: "main", requiresIfExists: ["preventOverflow"], fn: J_ }; function Q_(t, e, n) { var r = cn(t), o = [wt, yt].indexOf(r) >= 0 ? -1 : 1, i = typeof n == "function" ? n(Object.assign({}, e, { placement: t })) : n, s = i[0], c = i[1]; return s = s || 0, c = (c || 0) * o, [wt, It].indexOf(r) >= 0 ? { x: c, y: s } : { x: s, y: c } } function e0(t) { var e = t.state, n = t.options, r = t.name, o = n.offset, i = o === void 0 ? [0, 0] : o, s = su.reduce(function(d, h) { return d[h] = Q_(h, e.rects, i), d }, {}), c = s[e.placement], u = c.x, a = c.y; e.modifiersData.popperOffsets != null && (e.modifiersData.popperOffsets.x += u, e.modifiersData.popperOffsets.y += a), e.modifiersData[r] = s } const $m = { name: "offset", enabled: !0, phase: "main", requires: ["popperOffsets"], fn: e0 }; function t0(t) { var e = t.state, n = t.name; e.modifiersData[n] = Lm({ reference: e.rects.reference, element: e.rects.popper, strategy: "absolute", placement: e.placement }) } const gu = { name: "popperOffsets", enabled: !0, phase: "read", fn: t0, data: {} }; function n0(t) { return t === "x" ? "y" : "x" } function r0(t) { var e = t.state, n = t.options, r = t.name, o = n.mainAxis, i = o === void 0 ? !0 : o, s = n.altAxis, c = s === void 0 ? !1 : s, u = n.boundary, a = n.rootBoundary, d = n.altBoundary, h = n.padding, m = n.tether, g = m === void 0 ? !0 : m, y = n.tetherOffset, _ = y === void 0 ? 0 : y, A = So(e, { boundary: u, rootBoundary: a, padding: h, altBoundary: d }), E = cn(e.placement), T = To(e.placement), x = !T, P = uu(E), W = n0(P), Y = e.modifiersData.popperOffsets, Z = e.rects.reference, he = e.rects.popper, re = typeof _ == "function" ? _(Object.assign({}, e.rects, { placement: e.placement })) : _, z = typeof re == "number" ? { mainAxis: re, altAxis: re } : Object.assign({ mainAxis: 0, altAxis: 0 }, re), ye = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null, De = { x: 0, y: 0 }; if (Y) { if (i) { var fe, He = P === "y" ? yt : wt, nt = P === "y" ? Rt : It, pe = P === "y" ? "height" : "width", ie = Y[P], oe = ie + A[He], Re = ie - A[nt], $e = g ? -he[pe] / 2 : 0, at = T === Pr ? Z[pe] : he[pe], Ce = T === Pr ? -he[pe] : -Z[pe], rt = e.elements.arrow, ct = g && rt ? lu(rt) : { width: 0, height: 0 }, Xe = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : km(), Oe = Xe[He], R = Xe[nt], U = bi(0, Z[pe], ct[pe]), j = x ? Z[pe] / 2 - $e - U - Oe - z.mainAxis : at - U - Oe - z.mainAxis, X = x ? -Z[pe] / 2 + $e + U + R + z.mainAxis : Ce + U + R + z.mainAxis, me = e.elements.arrow && Hi(e.elements.arrow), w = me ? P === "y" ? me.clientTop || 0 : me.clientLeft || 0 : 0, v = (fe = ye == null ? void 0 : ye[P]) != null ? fe : 0, S = ie + j - v - w, C = ie + X - v, N = bi(g ? Ys(oe, S) : oe, ie, g ? Or(Re, C) : Re); Y[P] = N, De[P] = N - ie } if (c) { var D, V = P === "x" ? yt : wt, k = P === "x" ? Rt : It, $ = Y[W], L = W === "y" ? "height" : "width", G = $ + A[V], H = $ - A[k], K = [yt, wt].indexOf(E) !== -1, ee = (D = ye == null ? void 0 : ye[W]) != null ? D : 0, se = K ? G : $ - Z[L] - he[L] - ee + z.altAxis, ae = K ? $ + Z[L] + he[L] - ee - z.altAxis : H, we = g && K ? L_(se, $, ae) : bi(g ? se : G, $, g ? ae : H); Y[W] = we, De[W] = we - $ } e.modifiersData[r] = De } } const Mm = { name: "preventOverflow", enabled: !0, phase: "main", fn: r0, requiresIfExists: ["offset"] }; function o0(t) { return { scrollLeft: t.scrollLeft, scrollTop: t.scrollTop } } function i0(t) { return t === Pt(t) || !$t(t) ? hu(t) : o0(t) } function s0(t) { var e = t.getBoundingClientRect(), n = Eo(e.width) / t.offsetWidth || 1, r = Eo(e.height) / t.offsetHeight || 1; return n !== 1 || r !== 1 } function a0(t, e, n) { n === void 0 && (n = !1); var r = $t(e), o = $t(e) && s0(e), i = ar(e), s = Ao(t, o, n), c = { scrollLeft: 0, scrollTop: 0 }, u = { x: 0, y: 0 }; return (r || !r && !n) && ((fn(e) !== "body" || mu(i)) && (c = i0(e)), $t(e) ? (u = Ao(e, !0), u.x += e.clientLeft, u.y += e.clientTop) : i && (u.x = pu(i))), { x: s.left + c.scrollLeft - u.x, y: s.top + c.scrollTop - u.y, width: s.width, height: s.height } } function c0(t) { var e = new Map, n = new Set, r = []; t.forEach(function(i) { e.set(i.name, i) }); function o(i) { n.add(i.name); var s = [].concat(i.requires || [], i.requiresIfExists || []); s.forEach(function(c) { if (!n.has(c)) { var u = e.get(c); u && o(u) } }), r.push(i) } return t.forEach(function(i) { n.has(i.name) || o(i) }), r } function l0(t) { var e = c0(t); return Cm.reduce(function(n, r) { return n.concat(e.filter(function(o) { return o.phase === r })) }, []) } function u0(t) { var e; return function() { return e || (e = new Promise(function(n) { Promise.resolve().then(function() { e = void 0, n(t()) }) })), e } } function f0(t) { var e = t.reduce(function(n, r) { var o = n[r.name]; return n[r.name] = o ? Object.assign({}, o, r, { options: Object.assign({}, o.options, r.options), data: Object.assign({}, o.data, r.data) }) : r, n }, {}); return Object.keys(e).map(function(n) { return e[n] }) } var gd = { placement: "bottom", modifiers: [], strategy: "absolute" }; function yd() { for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)e[n] = arguments[n]; return !e.some(function(r) { return !(r && typeof r.getBoundingClientRect == "function") }) } function Ea(t) { t === void 0 && (t = {}); var e = t, n = e.defaultModifiers, r = n === void 0 ? [] : n, o = e.defaultOptions, i = o === void 0 ? gd : o; return function(c, u, a) { a === void 0 && (a = i); var d = { placement: "bottom", orderedModifiers: [], options: Object.assign({}, gd, i), modifiersData: {}, elements: { reference: c, popper: u }, attributes: {}, styles: {} }, h = [], m = !1, g = { state: d, setOptions: function(E) { var T = typeof E == "function" ? E(d.options) : E; _(), d.options = Object.assign({}, i, d.options, T), d.scrollParents = { reference: Nr(c) ? vi(c) : c.contextElement ? vi(c.contextElement) : [], popper: vi(u) }; var x = l0(f0([].concat(r, d.options.modifiers))); return d.orderedModifiers = x.filter(function(P) { return P.enabled }), y(), g.update() }, forceUpdate: function() { if (!m) { var E = d.elements, T = E.reference, x = E.popper; if (yd(T, x)) { d.rects = { reference: a0(T, Hi(x), d.options.strategy === "fixed"), popper: lu(x) }, d.reset = !1, d.placement = d.options.placement, d.orderedModifiers.forEach(function(z) { return d.modifiersData[z.name] = Object.assign({}, z.data) }); for (var P = 0; P < d.orderedModifiers.length; P++) { if (d.reset === !0) { d.reset = !1, P = -1; continue } var W = d.orderedModifiers[P], Y = W.fn, Z = W.options, he = Z === void 0 ? {} : Z, re = W.name; typeof Y == "function" && (d = Y({ state: d, options: he, name: re, instance: g }) || d) } } } }, update: u0(function() { return new Promise(function(A) { g.forceUpdate(), A(d) }) }), destroy: function() { _(), m = !0 } }; if (!yd(c, u)) return g; g.setOptions(a).then(function(A) { !m && a.onFirstUpdate && a.onFirstUpdate(A) }); function y() { d.orderedModifiers.forEach(function(A) { var E = A.name, T = A.options, x = T === void 0 ? {} : T, P = A.effect; if (typeof P == "function") { var W = P({ state: d, name: E, instance: g, options: x }), Y = function() { }; h.push(W || Y) } }) } function _() { h.forEach(function(A) { return A() }), h = [] } return g } } var d0 = Ea(), h0 = [du, gu, fu, cu], p0 = Ea({ defaultModifiers: h0 }), m0 = [du, gu, fu, cu, $m, Dm, Mm, Pm, Bm], yu = Ea({ defaultModifiers: m0 }); const Fm = Object.freeze(Object.defineProperty({ __proto__: null, afterMain: Em, afterRead: bm, afterWrite: Sm, applyStyles: cu, arrow: Pm, auto: va, basePlacements: Mo, beforeMain: vm, beforeRead: ym, beforeWrite: Am, bottom: Rt, clippingParents: mm, computeStyles: fu, createPopper: yu, createPopperBase: d0, createPopperLite: p0, detectOverflow: So, end: _o, eventListeners: du, flip: Dm, hide: Bm, left: wt, main: _m, modifierPhases: Cm, offset: $m, placements: su, popper: no, popperGenerator: Ea, popperOffsets: gu, preventOverflow: Mm, read: wm, reference: gm, right: It, start: Pr, top: yt, variationPlacements: rl, viewport: iu, write: Tm }, Symbol.toStringTag, { value: "Module" }));/*!
  * Bootstrap v5.3.0 (https://getbootstrap.com/)
  * Copyright 2011-2023 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */const Mn = new Map, dc = { set(t, e, n) { Mn.has(t) || Mn.set(t, new Map); const r = Mn.get(t); if (!r.has(e) && r.size !== 0) { console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(r.keys())[0]}.`); return } r.set(e, n) }, get(t, e) { return Mn.has(t) && Mn.get(t).get(e) || null }, remove(t, e) { if (!Mn.has(t)) return; const n = Mn.get(t); n.delete(e), n.size === 0 && Mn.delete(t) } }, g0 = 1e6, y0 = 1e3, sl = "transitionend", jm = t => (t && window.CSS && window.CSS.escape && (t = t.replace(/#([^\s"#']+)/g, (e, n) => `#${CSS.escape(n)}`)), t), w0 = t => t == null ? `${t}` : Object.prototype.toString.call(t).match(/\s([a-z]+)/i)[1].toLowerCase(), b0 = t => { do t += Math.floor(Math.random() * g0); while (document.getElementById(t)); return t }, v0 = t => { if (!t) return 0; let { transitionDuration: e, transitionDelay: n } = window.getComputedStyle(t); const r = Number.parseFloat(e), o = Number.parseFloat(n); return !r && !o ? 0 : (e = e.split(",")[0], n = n.split(",")[0], (Number.parseFloat(e) + Number.parseFloat(n)) * y0) }, Hm = t => { t.dispatchEvent(new Event(sl)) }, An = t => !t || typeof t != "object" ? !1 : (typeof t.jquery < "u" && (t = t[0]), typeof t.nodeType < "u"), er = t => An(t) ? t.jquery ? t[0] : t : typeof t == "string" && t.length > 0 ? document.querySelector(jm(t)) : null, Fo = t => { if (!An(t) || t.getClientRects().length === 0) return !1; const e = getComputedStyle(t).getPropertyValue("visibility") === "visible", n = t.closest("details:not([open])"); if (!n) return e; if (n !== t) { const r = t.closest("summary"); if (r && r.parentNode !== n || r === null) return !1 } return e }, tr = t => !t || t.nodeType !== Node.ELEMENT_NODE || t.classList.contains("disabled") ? !0 : typeof t.disabled < "u" ? t.disabled : t.hasAttribute("disabled") && t.getAttribute("disabled") !== "false", Um = t => { if (!document.documentElement.attachShadow) return null; if (typeof t.getRootNode == "function") { const e = t.getRootNode(); return e instanceof ShadowRoot ? e : null } return t instanceof ShadowRoot ? t : t.parentNode ? Um(t.parentNode) : null }, Xs = () => { }, Ui = t => { t.offsetHeight }, Vm = () => window.jQuery && !document.body.hasAttribute("data-bs-no-jquery") ? window.jQuery : null, hc = [], _0 = t => { document.readyState === "loading" ? (hc.length || document.addEventListener("DOMContentLoaded", () => { for (const e of hc) e() }), hc.push(t)) : t() }, Ft = () => document.documentElement.dir === "rtl", Ht = t => { _0(() => { const e = Vm(); if (e) { const n = t.NAME, r = e.fn[n]; e.fn[n] = t.jQueryInterface, e.fn[n].Constructor = t, e.fn[n].noConflict = () => (e.fn[n] = r, t.jQueryInterface) } }) }, Ct = (t, e = [], n = t) => typeof t == "function" ? t(...e) : n, Km = (t, e, n = !0) => { if (!n) { Ct(t); return } const r = 5, o = v0(e) + r; let i = !1; const s = ({ target: c }) => { c === e && (i = !0, e.removeEventListener(sl, s), Ct(t)) }; e.addEventListener(sl, s), setTimeout(() => { i || Hm(e) }, o) }, wu = (t, e, n, r) => { const o = t.length; let i = t.indexOf(e); return i === -1 ? !n && r ? t[o - 1] : t[0] : (i += n ? 1 : -1, r && (i = (i + o) % o), t[Math.max(0, Math.min(i, o - 1))]) }, E0 = /[^.]*(?=\..*)\.|.*/, A0 = /\..*/, T0 = /::\d+$/, pc = {}; let wd = 1; const Wm = { mouseenter: "mouseover", mouseleave: "mouseout" }, S0 = new Set(["click", "dblclick", "mouseup", "mousedown", "contextmenu", "mousewheel", "DOMMouseScroll", "mouseover", "mouseout", "mousemove", "selectstart", "selectend", "keydown", "keypress", "keyup", "orientationchange", "touchstart", "touchmove", "touchend", "touchcancel", "pointerdown", "pointermove", "pointerup", "pointerleave", "pointercancel", "gesturestart", "gesturechange", "gestureend", "focus", "blur", "change", "reset", "select", "submit", "focusin", "focusout", "load", "unload", "beforeunload", "resize", "move", "DOMContentLoaded", "readystatechange", "error", "abort", "scroll"]); function zm(t, e) { return e && `${e}::${wd++}` || t.uidEvent || wd++ } function qm(t) { const e = zm(t); return t.uidEvent = e, pc[e] = pc[e] || {}, pc[e] } function C0(t, e) { return function n(r) { return bu(r, { delegateTarget: t }), n.oneOff && B.off(t, r.type, e), e.apply(t, [r]) } } function O0(t, e, n) { return function r(o) { const i = t.querySelectorAll(e); for (let { target: s } = o; s && s !== this; s = s.parentNode)for (const c of i) if (c === s) return bu(o, { delegateTarget: s }), r.oneOff && B.off(t, o.type, e, n), n.apply(s, [o]) } } function Gm(t, e, n = null) { return Object.values(t).find(r => r.callable === e && r.delegationSelector === n) } function Ym(t, e, n) { const r = typeof e == "string", o = r ? n : e || n; let i = Xm(t); return S0.has(i) || (i = t), [r, o, i] } function bd(t, e, n, r, o) { if (typeof e != "string" || !t) return; let [i, s, c] = Ym(e, n, r); e in Wm && (s = (y => function(_) { if (!_.relatedTarget || _.relatedTarget !== _.delegateTarget && !_.delegateTarget.contains(_.relatedTarget)) return y.call(this, _) })(s)); const u = qm(t), a = u[c] || (u[c] = {}), d = Gm(a, s, i ? n : null); if (d) { d.oneOff = d.oneOff && o; return } const h = zm(s, e.replace(E0, "")), m = i ? O0(t, n, s) : C0(t, s); m.delegationSelector = i ? n : null, m.callable = s, m.oneOff = o, m.uidEvent = h, a[h] = m, t.addEventListener(c, m, i) } function al(t, e, n, r, o) { const i = Gm(e[n], r, o); i && (t.removeEventListener(n, i, !!o), delete e[n][i.uidEvent]) } function x0(t, e, n, r) { const o = e[n] || {}; for (const [i, s] of Object.entries(o)) i.includes(r) && al(t, e, n, s.callable, s.delegationSelector) } function Xm(t) { return t = t.replace(A0, ""), Wm[t] || t } const B = { on(t, e, n, r) { bd(t, e, n, r, !1) }, one(t, e, n, r) { bd(t, e, n, r, !0) }, off(t, e, n, r) { if (typeof e != "string" || !t) return; const [o, i, s] = Ym(e, n, r), c = s !== e, u = qm(t), a = u[s] || {}, d = e.startsWith("."); if (typeof i < "u") { if (!Object.keys(a).length) return; al(t, u, s, i, o ? n : null); return } if (d) for (const h of Object.keys(u)) x0(t, u, h, e.slice(1)); for (const [h, m] of Object.entries(a)) { const g = h.replace(T0, ""); (!c || e.includes(g)) && al(t, u, s, m.callable, m.delegationSelector) } }, trigger(t, e, n) { if (typeof e != "string" || !t) return null; const r = Vm(), o = Xm(e), i = e !== o; let s = null, c = !0, u = !0, a = !1; i && r && (s = r.Event(e, n), r(t).trigger(s), c = !s.isPropagationStopped(), u = !s.isImmediatePropagationStopped(), a = s.isDefaultPrevented()); const d = bu(new Event(e, { bubbles: c, cancelable: !0 }), n); return a && d.preventDefault(), u && t.dispatchEvent(d), d.defaultPrevented && s && s.preventDefault(), d } }; function bu(t, e = {}) { for (const [n, r] of Object.entries(e)) try { t[n] = r } catch { Object.defineProperty(t, n, { configurable: !0, get() { return r } }) } return t } function vd(t) { if (t === "true") return !0; if (t === "false") return !1; if (t === Number(t).toString()) return Number(t); if (t === "" || t === "null") return null; if (typeof t != "string") return t; try { return JSON.parse(decodeURIComponent(t)) } catch { return t } } function mc(t) { return t.replace(/[A-Z]/g, e => `-${e.toLowerCase()}`) } const Tn = { setDataAttribute(t, e, n) { t.setAttribute(`data-bs-${mc(e)}`, n) }, removeDataAttribute(t, e) { t.removeAttribute(`data-bs-${mc(e)}`) }, getDataAttributes(t) { if (!t) return {}; const e = {}, n = Object.keys(t.dataset).filter(r => r.startsWith("bs") && !r.startsWith("bsConfig")); for (const r of n) { let o = r.replace(/^bs/, ""); o = o.charAt(0).toLowerCase() + o.slice(1, o.length), e[o] = vd(t.dataset[r]) } return e }, getDataAttribute(t, e) { return vd(t.getAttribute(`data-bs-${mc(e)}`)) } }; class Vi { static get Default() { return {} } static get DefaultType() { return {} } static get NAME() { throw new Error('You have to implement the static method "NAME", for each component!') } _getConfig(e) { return e = this._mergeConfigObj(e), e = this._configAfterMerge(e), this._typeCheckConfig(e), e } _configAfterMerge(e) { return e } _mergeConfigObj(e, n) { const r = An(n) ? Tn.getDataAttribute(n, "config") : {}; return { ...this.constructor.Default, ...typeof r == "object" ? r : {}, ...An(n) ? Tn.getDataAttributes(n) : {}, ...typeof e == "object" ? e : {} } } _typeCheckConfig(e, n = this.constructor.DefaultType) { for (const [r, o] of Object.entries(n)) { const i = e[r], s = An(i) ? "element" : w0(i); if (!new RegExp(o).test(s)) throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option "${r}" provided type "${s}" but expected type "${o}".`) } } } const k0 = "5.3.0"; class Zt extends Vi { constructor(e, n) { super(), e = er(e), e && (this._element = e, this._config = this._getConfig(n), dc.set(this._element, this.constructor.DATA_KEY, this)) } dispose() { dc.remove(this._element, this.constructor.DATA_KEY), B.off(this._element, this.constructor.EVENT_KEY); for (const e of Object.getOwnPropertyNames(this)) this[e] = null } _queueCallback(e, n, r = !0) { Km(e, n, r) } _getConfig(e) { return e = this._mergeConfigObj(e, this._element), e = this._configAfterMerge(e), this._typeCheckConfig(e), e } static getInstance(e) { return dc.get(er(e), this.DATA_KEY) } static getOrCreateInstance(e, n = {}) { return this.getInstance(e) || new this(e, typeof n == "object" ? n : null) } static get VERSION() { return k0 } static get DATA_KEY() { return `bs.${this.NAME}` } static get EVENT_KEY() { return `.${this.DATA_KEY}` } static eventName(e) { return `${e}${this.EVENT_KEY}` } } const gc = t => { let e = t.getAttribute("data-bs-target"); if (!e || e === "#") { let n = t.getAttribute("href"); if (!n || !n.includes("#") && !n.startsWith(".")) return null; n.includes("#") && !n.startsWith("#") && (n = `#${n.split("#")[1]}`), e = n && n !== "#" ? n.trim() : null } return jm(e) }, J = { find(t, e = document.documentElement) { return [].concat(...Element.prototype.querySelectorAll.call(e, t)) }, findOne(t, e = document.documentElement) { return Element.prototype.querySelector.call(e, t) }, children(t, e) { return [].concat(...t.children).filter(n => n.matches(e)) }, parents(t, e) { const n = []; let r = t.parentNode.closest(e); for (; r;)n.push(r), r = r.parentNode.closest(e); return n }, prev(t, e) { let n = t.previousElementSibling; for (; n;) { if (n.matches(e)) return [n]; n = n.previousElementSibling } return [] }, next(t, e) { let n = t.nextElementSibling; for (; n;) { if (n.matches(e)) return [n]; n = n.nextElementSibling } return [] }, focusableChildren(t) { const e = ["a", "button", "input", "textarea", "select", "details", "[tabindex]", '[contenteditable="true"]'].map(n => `${n}:not([tabindex^="-"])`).join(","); return this.find(e, t).filter(n => !tr(n) && Fo(n)) }, getSelectorFromElement(t) { const e = gc(t); return e && J.findOne(e) ? e : null }, getElementFromSelector(t) { const e = gc(t); return e ? J.findOne(e) : null }, getMultipleElementsFromSelector(t) { const e = gc(t); return e ? J.find(e) : [] } }, Aa = (t, e = "hide") => { const n = `click.dismiss${t.EVENT_KEY}`, r = t.NAME; B.on(document, n, `[data-bs-dismiss="${r}"]`, function(o) { if (["A", "AREA"].includes(this.tagName) && o.preventDefault(), tr(this)) return; const i = J.getElementFromSelector(this) || this.closest(`.${r}`); t.getOrCreateInstance(i)[e]() }) }, R0 = "alert", I0 = "bs.alert", Zm = `.${I0}`, P0 = `close${Zm}`, N0 = `closed${Zm}`, L0 = "fade", D0 = "show"; class Ta extends Zt { static get NAME() { return R0 } close() { if (B.trigger(this._element, P0).defaultPrevented) return; this._element.classList.remove(D0); const n = this._element.classList.contains(L0); this._queueCallback(() => this._destroyElement(), this._element, n) } _destroyElement() { this._element.remove(), B.trigger(this._element, N0), this.dispose() } static jQueryInterface(e) { return this.each(function() { const n = Ta.getOrCreateInstance(this); if (typeof e == "string") { if (n[e] === void 0 || e.startsWith("_") || e === "constructor") throw new TypeError(`No method named "${e}"`); n[e](this) } }) } } Aa(Ta, "close"); Ht(Ta); const B0 = "button", $0 = "bs.button", M0 = `.${$0}`, F0 = ".data-api", j0 = "active", _d = '[data-bs-toggle="button"]', H0 = `click${M0}${F0}`; class Sa extends Zt { static get NAME() { return B0 } toggle() { this._element.setAttribute("aria-pressed", this._element.classList.toggle(j0)) } static jQueryInterface(e) { return this.each(function() { const n = Sa.getOrCreateInstance(this); e === "toggle" && n[e]() }) } } B.on(document, H0, _d, t => { t.preventDefault(); const e = t.target.closest(_d); Sa.getOrCreateInstance(e).toggle() }); Ht(Sa); const U0 = "swipe", jo = ".bs.swipe", V0 = `touchstart${jo}`, K0 = `touchmove${jo}`, W0 = `touchend${jo}`, z0 = `pointerdown${jo}`, q0 = `pointerup${jo}`, G0 = "touch", Y0 = "pen", X0 = "pointer-event", Z0 = 40, J0 = { endCallback: null, leftCallback: null, rightCallback: null }, Q0 = { endCallback: "(function|null)", leftCallback: "(function|null)", rightCallback: "(function|null)" }; class Zs extends Vi { constructor(e, n) { super(), this._element = e, !(!e || !Zs.isSupported()) && (this._config = this._getConfig(n), this._deltaX = 0, this._supportPointerEvents = !!window.PointerEvent, this._initEvents()) } static get Default() { return J0 } static get DefaultType() { return Q0 } static get NAME() { return U0 } dispose() { B.off(this._element, jo) } _start(e) { if (!this._supportPointerEvents) { this._deltaX = e.touches[0].clientX; return } this._eventIsPointerPenTouch(e) && (this._deltaX = e.clientX) } _end(e) { this._eventIsPointerPenTouch(e) && (this._deltaX = e.clientX - this._deltaX), this._handleSwipe(), Ct(this._config.endCallback) } _move(e) { this._deltaX = e.touches && e.touches.length > 1 ? 0 : e.touches[0].clientX - this._deltaX } _handleSwipe() { const e = Math.abs(this._deltaX); if (e <= Z0) return; const n = e / this._deltaX; this._deltaX = 0, n && Ct(n > 0 ? this._config.rightCallback : this._config.leftCallback) } _initEvents() { this._supportPointerEvents ? (B.on(this._element, z0, e => this._start(e)), B.on(this._element, q0, e => this._end(e)), this._element.classList.add(X0)) : (B.on(this._element, V0, e => this._start(e)), B.on(this._element, K0, e => this._move(e)), B.on(this._element, W0, e => this._end(e))) } _eventIsPointerPenTouch(e) { return this._supportPointerEvents && (e.pointerType === Y0 || e.pointerType === G0) } static isSupported() { return "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0 } } const eE = "carousel", tE = "bs.carousel", cr = `.${tE}`, Jm = ".data-api", nE = "ArrowLeft", rE = "ArrowRight", oE = 500, oi = "next", Xr = "prev", ro = "left", Is = "right", iE = `slide${cr}`, yc = `slid${cr}`, sE = `keydown${cr}`, aE = `mouseenter${cr}`, cE = `mouseleave${cr}`, lE = `dragstart${cr}`, uE = `load${cr}${Jm}`, fE = `click${cr}${Jm}`, Qm = "carousel", cs = "active", dE = "slide", hE = "carousel-item-end", pE = "carousel-item-start", mE = "carousel-item-next", gE = "carousel-item-prev", eg = ".active", tg = ".carousel-item", yE = eg + tg, wE = ".carousel-item img", bE = ".carousel-indicators", vE = "[data-bs-slide], [data-bs-slide-to]", _E = '[data-bs-ride="carousel"]', EE = { [nE]: Is, [rE]: ro }, AE = { interval: 5e3, keyboard: !0, pause: "hover", ride: !1, touch: !0, wrap: !0 }, TE = { interval: "(number|boolean)", keyboard: "boolean", pause: "(string|boolean)", ride: "(boolean|string)", touch: "boolean", wrap: "boolean" }; class Ki extends Zt { constructor(e, n) { super(e, n), this._interval = null, this._activeElement = null, this._isSliding = !1, this.touchTimeout = null, this._swipeHelper = null, this._indicatorsElement = J.findOne(bE, this._element), this._addEventListeners(), this._config.ride === Qm && this.cycle() } static get Default() { return AE } static get DefaultType() { return TE } static get NAME() { return eE } next() { this._slide(oi) } nextWhenVisible() { !document.hidden && Fo(this._element) && this.next() } prev() { this._slide(Xr) } pause() { this._isSliding && Hm(this._element), this._clearInterval() } cycle() { this._clearInterval(), this._updateInterval(), this._interval = setInterval(() => this.nextWhenVisible(), this._config.interval) } _maybeEnableCycle() { if (this._config.ride) { if (this._isSliding) { B.one(this._element, yc, () => this.cycle()); return } this.cycle() } } to(e) { const n = this._getItems(); if (e > n.length - 1 || e < 0) return; if (this._isSliding) { B.one(this._element, yc, () => this.to(e)); return } const r = this._getItemIndex(this._getActive()); if (r === e) return; const o = e > r ? oi : Xr; this._slide(o, n[e]) } dispose() { this._swipeHelper && this._swipeHelper.dispose(), super.dispose() } _configAfterMerge(e) { return e.defaultInterval = e.interval, e } _addEventListeners() { this._config.keyboard && B.on(this._element, sE, e => this._keydown(e)), this._config.pause === "hover" && (B.on(this._element, aE, () => this.pause()), B.on(this._element, cE, () => this._maybeEnableCycle())), this._config.touch && Zs.isSupported() && this._addTouchEventListeners() } _addTouchEventListeners() { for (const r of J.find(wE, this._element)) B.on(r, lE, o => o.preventDefault()); const n = { leftCallback: () => this._slide(this._directionToOrder(ro)), rightCallback: () => this._slide(this._directionToOrder(Is)), endCallback: () => { this._config.pause === "hover" && (this.pause(), this.touchTimeout && clearTimeout(this.touchTimeout), this.touchTimeout = setTimeout(() => this._maybeEnableCycle(), oE + this._config.interval)) } }; this._swipeHelper = new Zs(this._element, n) } _keydown(e) { if (/input|textarea/i.test(e.target.tagName)) return; const n = EE[e.key]; n && (e.preventDefault(), this._slide(this._directionToOrder(n))) } _getItemIndex(e) { return this._getItems().indexOf(e) } _setActiveIndicatorElement(e) { if (!this._indicatorsElement) return; const n = J.findOne(eg, this._indicatorsElement); n.classList.remove(cs), n.removeAttribute("aria-current"); const r = J.findOne(`[data-bs-slide-to="${e}"]`, this._indicatorsElement); r && (r.classList.add(cs), r.setAttribute("aria-current", "true")) } _updateInterval() { const e = this._activeElement || this._getActive(); if (!e) return; const n = Number.parseInt(e.getAttribute("data-bs-interval"), 10); this._config.interval = n || this._config.defaultInterval } _slide(e, n = null) { if (this._isSliding) return; const r = this._getActive(), o = e === oi, i = n || wu(this._getItems(), r, o, this._config.wrap); if (i === r) return; const s = this._getItemIndex(i), c = g => B.trigger(this._element, g, { relatedTarget: i, direction: this._orderToDirection(e), from: this._getItemIndex(r), to: s }); if (c(iE).defaultPrevented || !r || !i) return; const a = !!this._interval; this.pause(), this._isSliding = !0, this._setActiveIndicatorElement(s), this._activeElement = i; const d = o ? pE : hE, h = o ? mE : gE; i.classList.add(h), Ui(i), r.classList.add(d), i.classList.add(d); const m = () => { i.classList.remove(d, h), i.classList.add(cs), r.classList.remove(cs, h, d), this._isSliding = !1, c(yc) }; this._queueCallback(m, r, this._isAnimated()), a && this.cycle() } _isAnimated() { return this._element.classList.contains(dE) } _getActive() { return J.findOne(yE, this._element) } _getItems() { return J.find(tg, this._element) } _clearInterval() { this._interval && (clearInterval(this._interval), this._interval = null) } _directionToOrder(e) { return Ft() ? e === ro ? Xr : oi : e === ro ? oi : Xr } _orderToDirection(e) { return Ft() ? e === Xr ? ro : Is : e === Xr ? Is : ro } static jQueryInterface(e) { return this.each(function() { const n = Ki.getOrCreateInstance(this, e); if (typeof e == "number") { n.to(e); return } if (typeof e == "string") { if (n[e] === void 0 || e.startsWith("_") || e === "constructor") throw new TypeError(`No method named "${e}"`); n[e]() } }) } } B.on(document, fE, vE, function(t) { const e = J.getElementFromSelector(this); if (!e || !e.classList.contains(Qm)) return; t.preventDefault(); const n = Ki.getOrCreateInstance(e), r = this.getAttribute("data-bs-slide-to"); if (r) { n.to(r), n._maybeEnableCycle(); return } if (Tn.getDataAttribute(this, "slide") === "next") { n.next(), n._maybeEnableCycle(); return } n.prev(), n._maybeEnableCycle() }); B.on(window, uE, () => { const t = J.find(_E); for (const e of t) Ki.getOrCreateInstance(e) }); Ht(Ki); const SE = "collapse", CE = "bs.collapse", Wi = `.${CE}`, OE = ".data-api", xE = `show${Wi}`, kE = `shown${Wi}`, RE = `hide${Wi}`, IE = `hidden${Wi}`, PE = `click${Wi}${OE}`, wc = "show", uo = "collapse", ls = "collapsing", NE = "collapsed", LE = `:scope .${uo} .${uo}`, DE = "collapse-horizontal", BE = "width", $E = "height", ME = ".collapse.show, .collapse.collapsing", cl = '[data-bs-toggle="collapse"]', FE = { parent: null, toggle: !0 }, jE = { parent: "(null|element)", toggle: "boolean" }; class Oi extends Zt { constructor(e, n) { super(e, n), this._isTransitioning = !1, this._triggerArray = []; const r = J.find(cl); for (const o of r) { const i = J.getSelectorFromElement(o), s = J.find(i).filter(c => c === this._element); i !== null && s.length && this._triggerArray.push(o) } this._initializeChildren(), this._config.parent || this._addAriaAndCollapsedClass(this._triggerArray, this._isShown()), this._config.toggle && this.toggle() } static get Default() { return FE } static get DefaultType() { return jE } static get NAME() { return SE } toggle() { this._isShown() ? this.hide() : this.show() } show() { if (this._isTransitioning || this._isShown()) return; let e = []; if (this._config.parent && (e = this._getFirstLevelChildren(ME).filter(c => c !== this._element).map(c => Oi.getOrCreateInstance(c, { toggle: !1 }))), e.length && e[0]._isTransitioning || B.trigger(this._element, xE).defaultPrevented) return; for (const c of e) c.hide(); const r = this._getDimension(); this._element.classList.remove(uo), this._element.classList.add(ls), this._element.style[r] = 0, this._addAriaAndCollapsedClass(this._triggerArray, !0), this._isTransitioning = !0; const o = () => { this._isTransitioning = !1, this._element.classList.remove(ls), this._element.classList.add(uo, wc), this._element.style[r] = "", B.trigger(this._element, kE) }, s = `scroll${r[0].toUpperCase() + r.slice(1)}`; this._queueCallback(o, this._element, !0), this._element.style[r] = `${this._element[s]}px` } hide() { if (this._isTransitioning || !this._isShown() || B.trigger(this._element, RE).defaultPrevented) return; const n = this._getDimension(); this._element.style[n] = `${this._element.getBoundingClientRect()[n]}px`, Ui(this._element), this._element.classList.add(ls), this._element.classList.remove(uo, wc); for (const o of this._triggerArray) { const i = J.getElementFromSelector(o); i && !this._isShown(i) && this._addAriaAndCollapsedClass([o], !1) } this._isTransitioning = !0; const r = () => { this._isTransitioning = !1, this._element.classList.remove(ls), this._element.classList.add(uo), B.trigger(this._element, IE) }; this._element.style[n] = "", this._queueCallback(r, this._element, !0) } _isShown(e = this._element) { return e.classList.contains(wc) } _configAfterMerge(e) { return e.toggle = !!e.toggle, e.parent = er(e.parent), e } _getDimension() { return this._element.classList.contains(DE) ? BE : $E } _initializeChildren() { if (!this._config.parent) return; const e = this._getFirstLevelChildren(cl); for (const n of e) { const r = J.getElementFromSelector(n); r && this._addAriaAndCollapsedClass([n], this._isShown(r)) } } _getFirstLevelChildren(e) { const n = J.find(LE, this._config.parent); return J.find(e, this._config.parent).filter(r => !n.includes(r)) } _addAriaAndCollapsedClass(e, n) { if (e.length) for (const r of e) r.classList.toggle(NE, !n), r.setAttribute("aria-expanded", n) } static jQueryInterface(e) { const n = {}; return typeof e == "string" && /show|hide/.test(e) && (n.toggle = !1), this.each(function() { const r = Oi.getOrCreateInstance(this, n); if (typeof e == "string") { if (typeof r[e] > "u") throw new TypeError(`No method named "${e}"`); r[e]() } }) } } B.on(document, PE, cl, function(t) { (t.target.tagName === "A" || t.delegateTarget && t.delegateTarget.tagName === "A") && t.preventDefault(); for (const e of J.getMultipleElementsFromSelector(this)) Oi.getOrCreateInstance(e, { toggle: !1 }).toggle() }); Ht(Oi); const Ed = "dropdown", HE = "bs.dropdown", Fr = `.${HE}`, vu = ".data-api", UE = "Escape", Ad = "Tab", VE = "ArrowUp", Td = "ArrowDown", KE = 2, WE = `hide${Fr}`, zE = `hidden${Fr}`, qE = `show${Fr}`, GE = `shown${Fr}`, ng = `click${Fr}${vu}`, rg = `keydown${Fr}${vu}`, YE = `keyup${Fr}${vu}`, oo = "show", XE = "dropup", ZE = "dropend", JE = "dropstart", QE = "dropup-center", eA = "dropdown-center", _r = '[data-bs-toggle="dropdown"]:not(.disabled):not(:disabled)', tA = `${_r}.${oo}`, Ps = ".dropdown-menu", nA = ".navbar", rA = ".navbar-nav", oA = ".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)", iA = Ft() ? "top-end" : "top-start", sA = Ft() ? "top-start" : "top-end", aA = Ft() ? "bottom-end" : "bottom-start", cA = Ft() ? "bottom-start" : "bottom-end", lA = Ft() ? "left-start" : "right-start", uA = Ft() ? "right-start" : "left-start", fA = "top", dA = "bottom", hA = { autoClose: !0, boundary: "clippingParents", display: "dynamic", offset: [0, 2], popperConfig: null, reference: "toggle" }, pA = { autoClose: "(boolean|string)", boundary: "(string|element)", display: "string", offset: "(array|string|function)", popperConfig: "(null|object|function)", reference: "(string|element|object)" }; class ln extends Zt { constructor(e, n) { super(e, n), this._popper = null, this._parent = this._element.parentNode, this._menu = J.next(this._element, Ps)[0] || J.prev(this._element, Ps)[0] || J.findOne(Ps, this._parent), this._inNavbar = this._detectNavbar() } static get Default() { return hA } static get DefaultType() { return pA } static get NAME() { return Ed } toggle() { return this._isShown() ? this.hide() : this.show() } show() { if (tr(this._element) || this._isShown()) return; const e = { relatedTarget: this._element }; if (!B.trigger(this._element, qE, e).defaultPrevented) { if (this._createPopper(), "ontouchstart" in document.documentElement && !this._parent.closest(rA)) for (const r of [].concat(...document.body.children)) B.on(r, "mouseover", Xs); this._element.focus(), this._element.setAttribute("aria-expanded", !0), this._menu.classList.add(oo), this._element.classList.add(oo), B.trigger(this._element, GE, e) } } hide() { if (tr(this._element) || !this._isShown()) return; const e = { relatedTarget: this._element }; this._completeHide(e) } dispose() { this._popper && this._popper.destroy(), super.dispose() } update() { this._inNavbar = this._detectNavbar(), this._popper && this._popper.update() } _completeHide(e) { if (!B.trigger(this._element, WE, e).defaultPrevented) { if ("ontouchstart" in document.documentElement) for (const r of [].concat(...document.body.children)) B.off(r, "mouseover", Xs); this._popper && this._popper.destroy(), this._menu.classList.remove(oo), this._element.classList.remove(oo), this._element.setAttribute("aria-expanded", "false"), Tn.removeDataAttribute(this._menu, "popper"), B.trigger(this._element, zE, e) } } _getConfig(e) { if (e = super._getConfig(e), typeof e.reference == "object" && !An(e.reference) && typeof e.reference.getBoundingClientRect != "function") throw new TypeError(`${Ed.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`); return e } _createPopper() { if (typeof Fm > "u") throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)"); let e = this._element; this._config.reference === "parent" ? e = this._parent : An(this._config.reference) ? e = er(this._config.reference) : typeof this._config.reference == "object" && (e = this._config.reference); const n = this._getPopperConfig(); this._popper = yu(e, this._menu, n) } _isShown() { return this._menu.classList.contains(oo) } _getPlacement() { const e = this._parent; if (e.classList.contains(ZE)) return lA; if (e.classList.contains(JE)) return uA; if (e.classList.contains(QE)) return fA; if (e.classList.contains(eA)) return dA; const n = getComputedStyle(this._menu).getPropertyValue("--bs-position").trim() === "end"; return e.classList.contains(XE) ? n ? sA : iA : n ? cA : aA } _detectNavbar() { return this._element.closest(nA) !== null } _getOffset() { const { offset: e } = this._config; return typeof e == "string" ? e.split(",").map(n => Number.parseInt(n, 10)) : typeof e == "function" ? n => e(n, this._element) : e } _getPopperConfig() { const e = { placement: this._getPlacement(), modifiers: [{ name: "preventOverflow", options: { boundary: this._config.boundary } }, { name: "offset", options: { offset: this._getOffset() } }] }; return (this._inNavbar || this._config.display === "static") && (Tn.setDataAttribute(this._menu, "popper", "static"), e.modifiers = [{ name: "applyStyles", enabled: !1 }]), { ...e, ...Ct(this._config.popperConfig, [e]) } } _selectMenuItem({ key: e, target: n }) { const r = J.find(oA, this._menu).filter(o => Fo(o)); r.length && wu(r, n, e === Td, !r.includes(n)).focus() } static jQueryInterface(e) { return this.each(function() { const n = ln.getOrCreateInstance(this, e); if (typeof e == "string") { if (typeof n[e] > "u") throw new TypeError(`No method named "${e}"`); n[e]() } }) } static clearMenus(e) { if (e.button === KE || e.type === "keyup" && e.key !== Ad) return; const n = J.find(tA); for (const r of n) { const o = ln.getInstance(r); if (!o || o._config.autoClose === !1) continue; const i = e.composedPath(), s = i.includes(o._menu); if (i.includes(o._element) || o._config.autoClose === "inside" && !s || o._config.autoClose === "outside" && s || o._menu.contains(e.target) && (e.type === "keyup" && e.key === Ad || /input|select|option|textarea|form/i.test(e.target.tagName))) continue; const c = { relatedTarget: o._element }; e.type === "click" && (c.clickEvent = e), o._completeHide(c) } } static dataApiKeydownHandler(e) { const n = /input|textarea/i.test(e.target.tagName), r = e.key === UE, o = [VE, Td].includes(e.key); if (!o && !r || n && !r) return; e.preventDefault(); const i = this.matches(_r) ? this : J.prev(this, _r)[0] || J.next(this, _r)[0] || J.findOne(_r, e.delegateTarget.parentNode), s = ln.getOrCreateInstance(i); if (o) { e.stopPropagation(), s.show(), s._selectMenuItem(e); return } s._isShown() && (e.stopPropagation(), s.hide(), i.focus()) } } B.on(document, rg, _r, ln.dataApiKeydownHandler); B.on(document, rg, Ps, ln.dataApiKeydownHandler); B.on(document, ng, ln.clearMenus); B.on(document, YE, ln.clearMenus); B.on(document, ng, _r, function(t) { t.preventDefault(), ln.getOrCreateInstance(this).toggle() }); Ht(ln); const og = "backdrop", mA = "fade", Sd = "show", Cd = `mousedown.bs.${og}`, gA = { className: "modal-backdrop", clickCallback: null, isAnimated: !1, isVisible: !0, rootElement: "body" }, yA = { className: "string", clickCallback: "(function|null)", isAnimated: "boolean", isVisible: "boolean", rootElement: "(element|string)" }; class ig extends Vi { constructor(e) { super(), this._config = this._getConfig(e), this._isAppended = !1, this._element = null } static get Default() { return gA } static get DefaultType() { return yA } static get NAME() { return og } show(e) { if (!this._config.isVisible) { Ct(e); return } this._append(); const n = this._getElement(); this._config.isAnimated && Ui(n), n.classList.add(Sd), this._emulateAnimation(() => { Ct(e) }) } hide(e) { if (!this._config.isVisible) { Ct(e); return } this._getElement().classList.remove(Sd), this._emulateAnimation(() => { this.dispose(), Ct(e) }) } dispose() { this._isAppended && (B.off(this._element, Cd), this._element.remove(), this._isAppended = !1) } _getElement() { if (!this._element) { const e = document.createElement("div"); e.className = this._config.className, this._config.isAnimated && e.classList.add(mA), this._element = e } return this._element } _configAfterMerge(e) { return e.rootElement = er(e.rootElement), e } _append() { if (this._isAppended) return; const e = this._getElement(); this._config.rootElement.append(e), B.on(e, Cd, () => { Ct(this._config.clickCallback) }), this._isAppended = !0 } _emulateAnimation(e) { Km(e, this._getElement(), this._config.isAnimated) } } const wA = "focustrap", bA = "bs.focustrap", Js = `.${bA}`, vA = `focusin${Js}`, _A = `keydown.tab${Js}`, EA = "Tab", AA = "forward", Od = "backward", TA = { autofocus: !0, trapElement: null }, SA = { autofocus: "boolean", trapElement: "element" }; class sg extends Vi { constructor(e) { super(), this._config = this._getConfig(e), this._isActive = !1, this._lastTabNavDirection = null } static get Default() { return TA } static get DefaultType() { return SA } static get NAME() { return wA } activate() { this._isActive || (this._config.autofocus && this._config.trapElement.focus(), B.off(document, Js), B.on(document, vA, e => this._handleFocusin(e)), B.on(document, _A, e => this._handleKeydown(e)), this._isActive = !0) } deactivate() { this._isActive && (this._isActive = !1, B.off(document, Js)) } _handleFocusin(e) { const { trapElement: n } = this._config; if (e.target === document || e.target === n || n.contains(e.target)) return; const r = J.focusableChildren(n); r.length === 0 ? n.focus() : this._lastTabNavDirection === Od ? r[r.length - 1].focus() : r[0].focus() } _handleKeydown(e) { e.key === EA && (this._lastTabNavDirection = e.shiftKey ? Od : AA) } } const xd = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top", kd = ".sticky-top", us = "padding-right", Rd = "margin-right"; class ll { constructor() { this._element = document.body } getWidth() { const e = document.documentElement.clientWidth; return Math.abs(window.innerWidth - e) } hide() { const e = this.getWidth(); this._disableOverFlow(), this._setElementAttributes(this._element, us, n => n + e), this._setElementAttributes(xd, us, n => n + e), this._setElementAttributes(kd, Rd, n => n - e) } reset() { this._resetElementAttributes(this._element, "overflow"), this._resetElementAttributes(this._element, us), this._resetElementAttributes(xd, us), this._resetElementAttributes(kd, Rd) } isOverflowing() { return this.getWidth() > 0 } _disableOverFlow() { this._saveInitialAttribute(this._element, "overflow"), this._element.style.overflow = "hidden" } _setElementAttributes(e, n, r) { const o = this.getWidth(), i = s => { if (s !== this._element && window.innerWidth > s.clientWidth + o) return; this._saveInitialAttribute(s, n); const c = window.getComputedStyle(s).getPropertyValue(n); s.style.setProperty(n, `${r(Number.parseFloat(c))}px`) }; this._applyManipulationCallback(e, i) } _saveInitialAttribute(e, n) { const r = e.style.getPropertyValue(n); r && Tn.setDataAttribute(e, n, r) } _resetElementAttributes(e, n) { const r = o => { const i = Tn.getDataAttribute(o, n); if (i === null) { o.style.removeProperty(n); return } Tn.removeDataAttribute(o, n), o.style.setProperty(n, i) }; this._applyManipulationCallback(e, r) } _applyManipulationCallback(e, n) { if (An(e)) { n(e); return } for (const r of J.find(e, this._element)) n(r) } } const CA = "modal", OA = "bs.modal", jt = `.${OA}`, xA = ".data-api", kA = "Escape", RA = `hide${jt}`, IA = `hidePrevented${jt}`, ag = `hidden${jt}`, cg = `show${jt}`, PA = `shown${jt}`, NA = `resize${jt}`, LA = `click.dismiss${jt}`, DA = `mousedown.dismiss${jt}`, BA = `keydown.dismiss${jt}`, $A = `click${jt}${xA}`, Id = "modal-open", MA = "fade", Pd = "show", bc = "modal-static", FA = ".modal.show", jA = ".modal-dialog", HA = ".modal-body", UA = '[data-bs-toggle="modal"]', VA = { backdrop: !0, focus: !0, keyboard: !0 }, KA = { backdrop: "(boolean|string)", focus: "boolean", keyboard: "boolean" }; class nr extends Zt { constructor(e, n) { super(e, n), this._dialog = J.findOne(jA, this._element), this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._isShown = !1, this._isTransitioning = !1, this._scrollBar = new ll, this._addEventListeners() } static get Default() { return VA } static get DefaultType() { return KA } static get NAME() { return CA } toggle(e) { return this._isShown ? this.hide() : this.show(e) } show(e) { this._isShown || this._isTransitioning || B.trigger(this._element, cg, { relatedTarget: e }).defaultPrevented || (this._isShown = !0, this._isTransitioning = !0, this._scrollBar.hide(), document.body.classList.add(Id), this._adjustDialog(), this._backdrop.show(() => this._showElement(e))) } hide() { !this._isShown || this._isTransitioning || B.trigger(this._element, RA).defaultPrevented || (this._isShown = !1, this._isTransitioning = !0, this._focustrap.deactivate(), this._element.classList.remove(Pd), this._queueCallback(() => this._hideModal(), this._element, this._isAnimated())) } dispose() { B.off(window, jt), B.off(this._dialog, jt), this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose() } handleUpdate() { this._adjustDialog() } _initializeBackDrop() { return new ig({ isVisible: !!this._config.backdrop, isAnimated: this._isAnimated() }) } _initializeFocusTrap() { return new sg({ trapElement: this._element }) } _showElement(e) { document.body.contains(this._element) || document.body.append(this._element), this._element.style.display = "block", this._element.removeAttribute("aria-hidden"), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.scrollTop = 0; const n = J.findOne(HA, this._dialog); n && (n.scrollTop = 0), Ui(this._element), this._element.classList.add(Pd); const r = () => { this._config.focus && this._focustrap.activate(), this._isTransitioning = !1, B.trigger(this._element, PA, { relatedTarget: e }) }; this._queueCallback(r, this._dialog, this._isAnimated()) } _addEventListeners() { B.on(this._element, BA, e => { if (e.key === kA) { if (this._config.keyboard) { this.hide(); return } this._triggerBackdropTransition() } }), B.on(window, NA, () => { this._isShown && !this._isTransitioning && this._adjustDialog() }), B.on(this._element, DA, e => { B.one(this._element, LA, n => { if (!(this._element !== e.target || this._element !== n.target)) { if (this._config.backdrop === "static") { this._triggerBackdropTransition(); return } this._config.backdrop && this.hide() } }) }) } _hideModal() { this._element.style.display = "none", this._element.setAttribute("aria-hidden", !0), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._isTransitioning = !1, this._backdrop.hide(() => { document.body.classList.remove(Id), this._resetAdjustments(), this._scrollBar.reset(), B.trigger(this._element, ag) }) } _isAnimated() { return this._element.classList.contains(MA) } _triggerBackdropTransition() { if (B.trigger(this._element, IA).defaultPrevented) return; const n = this._element.scrollHeight > document.documentElement.clientHeight, r = this._element.style.overflowY; r === "hidden" || this._element.classList.contains(bc) || (n || (this._element.style.overflowY = "hidden"), this._element.classList.add(bc), this._queueCallback(() => { this._element.classList.remove(bc), this._queueCallback(() => { this._element.style.overflowY = r }, this._dialog) }, this._dialog), this._element.focus()) } _adjustDialog() { const e = this._element.scrollHeight > document.documentElement.clientHeight, n = this._scrollBar.getWidth(), r = n > 0; if (r && !e) { const o = Ft() ? "paddingLeft" : "paddingRight"; this._element.style[o] = `${n}px` } if (!r && e) { const o = Ft() ? "paddingRight" : "paddingLeft"; this._element.style[o] = `${n}px` } } _resetAdjustments() { this._element.style.paddingLeft = "", this._element.style.paddingRight = "" } static jQueryInterface(e, n) { return this.each(function() { const r = nr.getOrCreateInstance(this, e); if (typeof e == "string") { if (typeof r[e] > "u") throw new TypeError(`No method named "${e}"`); r[e](n) } }) } } B.on(document, $A, UA, function(t) { const e = J.getElementFromSelector(this);["A", "AREA"].includes(this.tagName) && t.preventDefault(), B.one(e, cg, o => { o.defaultPrevented || B.one(e, ag, () => { Fo(this) && this.focus() }) }); const n = J.findOne(FA); n && nr.getInstance(n).hide(), nr.getOrCreateInstance(e).toggle(this) }); Aa(nr); Ht(nr); const WA = "offcanvas", zA = "bs.offcanvas", Ln = `.${zA}`, lg = ".data-api", qA = `load${Ln}${lg}`, GA = "Escape", Nd = "show", Ld = "showing", Dd = "hiding", YA = "offcanvas-backdrop", ug = ".offcanvas.show", XA = `show${Ln}`, ZA = `shown${Ln}`, JA = `hide${Ln}`, Bd = `hidePrevented${Ln}`, fg = `hidden${Ln}`, QA = `resize${Ln}`, eT = `click${Ln}${lg}`, tT = `keydown.dismiss${Ln}`, nT = '[data-bs-toggle="offcanvas"]', rT = { backdrop: !0, keyboard: !0, scroll: !1 }, oT = { backdrop: "(boolean|string)", keyboard: "boolean", scroll: "boolean" }; class rr extends Zt { constructor(e, n) { super(e, n), this._isShown = !1, this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._addEventListeners() } static get Default() { return rT } static get DefaultType() { return oT } static get NAME() { return WA } toggle(e) { return this._isShown ? this.hide() : this.show(e) } show(e) { if (this._isShown || B.trigger(this._element, XA, { relatedTarget: e }).defaultPrevented) return; this._isShown = !0, this._backdrop.show(), this._config.scroll || new ll().hide(), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.classList.add(Ld); const r = () => { (!this._config.scroll || this._config.backdrop) && this._focustrap.activate(), this._element.classList.add(Nd), this._element.classList.remove(Ld), B.trigger(this._element, ZA, { relatedTarget: e }) }; this._queueCallback(r, this._element, !0) } hide() { if (!this._isShown || B.trigger(this._element, JA).defaultPrevented) return; this._focustrap.deactivate(), this._element.blur(), this._isShown = !1, this._element.classList.add(Dd), this._backdrop.hide(); const n = () => { this._element.classList.remove(Nd, Dd), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._config.scroll || new ll().reset(), B.trigger(this._element, fg) }; this._queueCallback(n, this._element, !0) } dispose() { this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose() } _initializeBackDrop() { const e = () => { if (this._config.backdrop === "static") { B.trigger(this._element, Bd); return } this.hide() }, n = !!this._config.backdrop; return new ig({ className: YA, isVisible: n, isAnimated: !0, rootElement: this._element.parentNode, clickCallback: n ? e : null }) } _initializeFocusTrap() { return new sg({ trapElement: this._element }) } _addEventListeners() { B.on(this._element, tT, e => { if (e.key === GA) { if (this._config.keyboard) { this.hide(); return } B.trigger(this._element, Bd) } }) } static jQueryInterface(e) { return this.each(function() { const n = rr.getOrCreateInstance(this, e); if (typeof e == "string") { if (n[e] === void 0 || e.startsWith("_") || e === "constructor") throw new TypeError(`No method named "${e}"`); n[e](this) } }) } } B.on(document, eT, nT, function(t) { const e = J.getElementFromSelector(this); if (["A", "AREA"].includes(this.tagName) && t.preventDefault(), tr(this)) return; B.one(e, fg, () => { Fo(this) && this.focus() }); const n = J.findOne(ug); n && n !== e && rr.getInstance(n).hide(), rr.getOrCreateInstance(e).toggle(this) }); B.on(window, qA, () => { for (const t of J.find(ug)) rr.getOrCreateInstance(t).show() }); B.on(window, QA, () => { for (const t of J.find("[aria-modal][class*=show][class*=offcanvas-]")) getComputedStyle(t).position !== "fixed" && rr.getOrCreateInstance(t).hide() }); Aa(rr); Ht(rr); const iT = /^aria-[\w-]*$/i, dg = { "*": ["class", "dir", "id", "lang", "role", iT], a: ["target", "href", "title", "rel"], area: [], b: [], br: [], col: [], code: [], div: [], em: [], hr: [], h1: [], h2: [], h3: [], h4: [], h5: [], h6: [], i: [], img: ["src", "srcset", "alt", "title", "width", "height"], li: [], ol: [], p: [], pre: [], s: [], small: [], span: [], sub: [], sup: [], strong: [], u: [], ul: [] }, sT = new Set(["background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href"]), aT = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:/?#]*(?:[/?#]|$))/i, cT = (t, e) => { const n = t.nodeName.toLowerCase(); return e.includes(n) ? sT.has(n) ? !!aT.test(t.nodeValue) : !0 : e.filter(r => r instanceof RegExp).some(r => r.test(n)) }; function lT(t, e, n) { if (!t.length) return t; if (n && typeof n == "function") return n(t); const o = new window.DOMParser().parseFromString(t, "text/html"), i = [].concat(...o.body.querySelectorAll("*")); for (const s of i) { const c = s.nodeName.toLowerCase(); if (!Object.keys(e).includes(c)) { s.remove(); continue } const u = [].concat(...s.attributes), a = [].concat(e["*"] || [], e[c] || []); for (const d of u) cT(d, a) || s.removeAttribute(d.nodeName) } return o.body.innerHTML } const uT = "TemplateFactory", fT = { allowList: dg, content: {}, extraClass: "", html: !1, sanitize: !0, sanitizeFn: null, template: "<div></div>" }, dT = { allowList: "object", content: "object", extraClass: "(string|function)", html: "boolean", sanitize: "boolean", sanitizeFn: "(null|function)", template: "string" }, hT = { entry: "(string|element|function|null)", selector: "(string|element)" }; class pT extends Vi { constructor(e) { super(), this._config = this._getConfig(e) } static get Default() { return fT } static get DefaultType() { return dT } static get NAME() { return uT } getContent() { return Object.values(this._config.content).map(e => this._resolvePossibleFunction(e)).filter(Boolean) } hasContent() { return this.getContent().length > 0 } changeContent(e) { return this._checkContent(e), this._config.content = { ...this._config.content, ...e }, this } toHtml() { const e = document.createElement("div"); e.innerHTML = this._maybeSanitize(this._config.template); for (const [o, i] of Object.entries(this._config.content)) this._setContent(e, i, o); const n = e.children[0], r = this._resolvePossibleFunction(this._config.extraClass); return r && n.classList.add(...r.split(" ")), n } _typeCheckConfig(e) { super._typeCheckConfig(e), this._checkContent(e.content) } _checkContent(e) { for (const [n, r] of Object.entries(e)) super._typeCheckConfig({ selector: n, entry: r }, hT) } _setContent(e, n, r) { const o = J.findOne(r, e); if (o) { if (n = this._resolvePossibleFunction(n), !n) { o.remove(); return } if (An(n)) { this._putElementInTemplate(er(n), o); return } if (this._config.html) { o.innerHTML = this._maybeSanitize(n); return } o.textContent = n } } _maybeSanitize(e) { return this._config.sanitize ? lT(e, this._config.allowList, this._config.sanitizeFn) : e } _resolvePossibleFunction(e) { return Ct(e, [this]) } _putElementInTemplate(e, n) { if (this._config.html) { n.innerHTML = "", n.append(e); return } n.textContent = e.textContent } } const mT = "tooltip", gT = new Set(["sanitize", "allowList", "sanitizeFn"]), vc = "fade", yT = "modal", fs = "show", wT = ".tooltip-inner", $d = `.${yT}`, Md = "hide.bs.modal", ii = "hover", _c = "focus", bT = "click", vT = "manual", _T = "hide", ET = "hidden", AT = "show", TT = "shown", ST = "inserted", CT = "click", OT = "focusin", xT = "focusout", kT = "mouseenter", RT = "mouseleave", IT = { AUTO: "auto", TOP: "top", RIGHT: Ft() ? "left" : "right", BOTTOM: "bottom", LEFT: Ft() ? "right" : "left" }, PT = { allowList: dg, animation: !0, boundary: "clippingParents", container: !1, customClass: "", delay: 0, fallbackPlacements: ["top", "right", "bottom", "left"], html: !1, offset: [0, 6], placement: "top", popperConfig: null, sanitize: !0, sanitizeFn: null, selector: !1, template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>', title: "", trigger: "hover focus" }, NT = { allowList: "object", animation: "boolean", boundary: "(string|element)", container: "(string|element|boolean)", customClass: "(string|function)", delay: "(number|object)", fallbackPlacements: "array", html: "boolean", offset: "(array|string|function)", placement: "(string|function)", popperConfig: "(null|object|function)", sanitize: "boolean", sanitizeFn: "(null|function)", selector: "(string|boolean)", template: "string", title: "(string|element|function)", trigger: "string" }; class Ho extends Zt { constructor(e, n) { if (typeof Fm > "u") throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)"); super(e, n), this._isEnabled = !0, this._timeout = 0, this._isHovered = null, this._activeTrigger = {}, this._popper = null, this._templateFactory = null, this._newContent = null, this.tip = null, this._setListeners(), this._config.selector || this._fixTitle() } static get Default() { return PT } static get DefaultType() { return NT } static get NAME() { return mT } enable() { this._isEnabled = !0 } disable() { this._isEnabled = !1 } toggleEnabled() { this._isEnabled = !this._isEnabled } toggle() { if (this._isEnabled) { if (this._activeTrigger.click = !this._activeTrigger.click, this._isShown()) { this._leave(); return } this._enter() } } dispose() { clearTimeout(this._timeout), B.off(this._element.closest($d), Md, this._hideModalHandler), this._element.getAttribute("data-bs-original-title") && this._element.setAttribute("title", this._element.getAttribute("data-bs-original-title")), this._disposePopper(), super.dispose() } show() { if (this._element.style.display === "none") throw new Error("Please use show on visible elements"); if (!(this._isWithContent() && this._isEnabled)) return; const e = B.trigger(this._element, this.constructor.eventName(AT)), r = (Um(this._element) || this._element.ownerDocument.documentElement).contains(this._element); if (e.defaultPrevented || !r) return; this._disposePopper(); const o = this._getTipElement(); this._element.setAttribute("aria-describedby", o.getAttribute("id")); const { container: i } = this._config; if (this._element.ownerDocument.documentElement.contains(this.tip) || (i.append(o), B.trigger(this._element, this.constructor.eventName(ST))), this._popper = this._createPopper(o), o.classList.add(fs), "ontouchstart" in document.documentElement) for (const c of [].concat(...document.body.children)) B.on(c, "mouseover", Xs); const s = () => { B.trigger(this._element, this.constructor.eventName(TT)), this._isHovered === !1 && this._leave(), this._isHovered = !1 }; this._queueCallback(s, this.tip, this._isAnimated()) } hide() { if (!this._isShown() || B.trigger(this._element, this.constructor.eventName(_T)).defaultPrevented) return; if (this._getTipElement().classList.remove(fs), "ontouchstart" in document.documentElement) for (const o of [].concat(...document.body.children)) B.off(o, "mouseover", Xs); this._activeTrigger[bT] = !1, this._activeTrigger[_c] = !1, this._activeTrigger[ii] = !1, this._isHovered = null; const r = () => { this._isWithActiveTrigger() || (this._isHovered || this._disposePopper(), this._element.removeAttribute("aria-describedby"), B.trigger(this._element, this.constructor.eventName(ET))) }; this._queueCallback(r, this.tip, this._isAnimated()) } update() { this._popper && this._popper.update() } _isWithContent() { return !!this._getTitle() } _getTipElement() { return this.tip || (this.tip = this._createTipElement(this._newContent || this._getContentForTemplate())), this.tip } _createTipElement(e) { const n = this._getTemplateFactory(e).toHtml(); if (!n) return null; n.classList.remove(vc, fs), n.classList.add(`bs-${this.constructor.NAME}-auto`); const r = b0(this.constructor.NAME).toString(); return n.setAttribute("id", r), this._isAnimated() && n.classList.add(vc), n } setContent(e) { this._newContent = e, this._isShown() && (this._disposePopper(), this.show()) } _getTemplateFactory(e) { return this._templateFactory ? this._templateFactory.changeContent(e) : this._templateFactory = new pT({ ...this._config, content: e, extraClass: this._resolvePossibleFunction(this._config.customClass) }), this._templateFactory } _getContentForTemplate() { return { [wT]: this._getTitle() } } _getTitle() { return this._resolvePossibleFunction(this._config.title) || this._element.getAttribute("data-bs-original-title") } _initializeOnDelegatedTarget(e) { return this.constructor.getOrCreateInstance(e.delegateTarget, this._getDelegateConfig()) } _isAnimated() { return this._config.animation || this.tip && this.tip.classList.contains(vc) } _isShown() { return this.tip && this.tip.classList.contains(fs) } _createPopper(e) { const n = Ct(this._config.placement, [this, e, this._element]), r = IT[n.toUpperCase()]; return yu(this._element, e, this._getPopperConfig(r)) } _getOffset() { const { offset: e } = this._config; return typeof e == "string" ? e.split(",").map(n => Number.parseInt(n, 10)) : typeof e == "function" ? n => e(n, this._element) : e } _resolvePossibleFunction(e) { return Ct(e, [this._element]) } _getPopperConfig(e) { const n = { placement: e, modifiers: [{ name: "flip", options: { fallbackPlacements: this._config.fallbackPlacements } }, { name: "offset", options: { offset: this._getOffset() } }, { name: "preventOverflow", options: { boundary: this._config.boundary } }, { name: "arrow", options: { element: `.${this.constructor.NAME}-arrow` } }, { name: "preSetPlacement", enabled: !0, phase: "beforeMain", fn: r => { this._getTipElement().setAttribute("data-popper-placement", r.state.placement) } }] }; return { ...n, ...Ct(this._config.popperConfig, [n]) } } _setListeners() { const e = this._config.trigger.split(" "); for (const n of e) if (n === "click") B.on(this._element, this.constructor.eventName(CT), this._config.selector, r => { this._initializeOnDelegatedTarget(r).toggle() }); else if (n !== vT) { const r = n === ii ? this.constructor.eventName(kT) : this.constructor.eventName(OT), o = n === ii ? this.constructor.eventName(RT) : this.constructor.eventName(xT); B.on(this._element, r, this._config.selector, i => { const s = this._initializeOnDelegatedTarget(i); s._activeTrigger[i.type === "focusin" ? _c : ii] = !0, s._enter() }), B.on(this._element, o, this._config.selector, i => { const s = this._initializeOnDelegatedTarget(i); s._activeTrigger[i.type === "focusout" ? _c : ii] = s._element.contains(i.relatedTarget), s._leave() }) } this._hideModalHandler = () => { this._element && this.hide() }, B.on(this._element.closest($d), Md, this._hideModalHandler) } _fixTitle() { const e = this._element.getAttribute("title"); e && (!this._element.getAttribute("aria-label") && !this._element.textContent.trim() && this._element.setAttribute("aria-label", e), this._element.setAttribute("data-bs-original-title", e), this._element.removeAttribute("title")) } _enter() { if (this._isShown() || this._isHovered) { this._isHovered = !0; return } this._isHovered = !0, this._setTimeout(() => { this._isHovered && this.show() }, this._config.delay.show) } _leave() { this._isWithActiveTrigger() || (this._isHovered = !1, this._setTimeout(() => { this._isHovered || this.hide() }, this._config.delay.hide)) } _setTimeout(e, n) { clearTimeout(this._timeout), this._timeout = setTimeout(e, n) } _isWithActiveTrigger() { return Object.values(this._activeTrigger).includes(!0) } _getConfig(e) { const n = Tn.getDataAttributes(this._element); for (const r of Object.keys(n)) gT.has(r) && delete n[r]; return e = { ...n, ...typeof e == "object" && e ? e : {} }, e = this._mergeConfigObj(e), e = this._configAfterMerge(e), this._typeCheckConfig(e), e } _configAfterMerge(e) { return e.container = e.container === !1 ? document.body : er(e.container), typeof e.delay == "number" && (e.delay = { show: e.delay, hide: e.delay }), typeof e.title == "number" && (e.title = e.title.toString()), typeof e.content == "number" && (e.content = e.content.toString()), e } _getDelegateConfig() { const e = {}; for (const [n, r] of Object.entries(this._config)) this.constructor.Default[n] !== r && (e[n] = r); return e.selector = !1, e.trigger = "manual", e } _disposePopper() { this._popper && (this._popper.destroy(), this._popper = null), this.tip && (this.tip.remove(), this.tip = null) } static jQueryInterface(e) { return this.each(function() { const n = Ho.getOrCreateInstance(this, e); if (typeof e == "string") { if (typeof n[e] > "u") throw new TypeError(`No method named "${e}"`); n[e]() } }) } } Ht(Ho); const LT = "popover", DT = ".popover-header", BT = ".popover-body", $T = { ...Ho.Default, content: "", offset: [0, 8], placement: "right", template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>', trigger: "click" }, MT = { ...Ho.DefaultType, content: "(null|string|element|function)" }; class _u extends Ho { static get Default() { return $T } static get DefaultType() { return MT } static get NAME() { return LT } _isWithContent() { return this._getTitle() || this._getContent() } _getContentForTemplate() { return { [DT]: this._getTitle(), [BT]: this._getContent() } } _getContent() { return this._resolvePossibleFunction(this._config.content) } static jQueryInterface(e) { return this.each(function() { const n = _u.getOrCreateInstance(this, e); if (typeof e == "string") { if (typeof n[e] > "u") throw new TypeError(`No method named "${e}"`); n[e]() } }) } } Ht(_u); const FT = "scrollspy", jT = "bs.scrollspy", Eu = `.${jT}`, HT = ".data-api", UT = `activate${Eu}`, Fd = `click${Eu}`, VT = `load${Eu}${HT}`, KT = "dropdown-item", Zr = "active", WT = '[data-bs-spy="scroll"]', Ec = "[href]", zT = ".nav, .list-group", jd = ".nav-link", qT = ".nav-item", GT = ".list-group-item", YT = `${jd}, ${qT} > ${jd}, ${GT}`, XT = ".dropdown", ZT = ".dropdown-toggle", JT = { offset: null, rootMargin: "0px 0px -25%", smoothScroll: !1, target: null, threshold: [.1, .5, 1] }, QT = { offset: "(number|null)", rootMargin: "string", smoothScroll: "boolean", target: "element", threshold: "array" }; class Ca extends Zt { constructor(e, n) { super(e, n), this._targetLinks = new Map, this._observableSections = new Map, this._rootElement = getComputedStyle(this._element).overflowY === "visible" ? null : this._element, this._activeTarget = null, this._observer = null, this._previousScrollData = { visibleEntryTop: 0, parentScrollTop: 0 }, this.refresh() } static get Default() { return JT } static get DefaultType() { return QT } static get NAME() { return FT } refresh() { this._initializeTargetsAndObservables(), this._maybeEnableSmoothScroll(), this._observer ? this._observer.disconnect() : this._observer = this._getNewObserver(); for (const e of this._observableSections.values()) this._observer.observe(e) } dispose() { this._observer.disconnect(), super.dispose() } _configAfterMerge(e) { return e.target = er(e.target) || document.body, e.rootMargin = e.offset ? `${e.offset}px 0px -30%` : e.rootMargin, typeof e.threshold == "string" && (e.threshold = e.threshold.split(",").map(n => Number.parseFloat(n))), e } _maybeEnableSmoothScroll() { this._config.smoothScroll && (B.off(this._config.target, Fd), B.on(this._config.target, Fd, Ec, e => { const n = this._observableSections.get(e.target.hash); if (n) { e.preventDefault(); const r = this._rootElement || window, o = n.offsetTop - this._element.offsetTop; if (r.scrollTo) { r.scrollTo({ top: o, behavior: "smooth" }); return } r.scrollTop = o } })) } _getNewObserver() { const e = { root: this._rootElement, threshold: this._config.threshold, rootMargin: this._config.rootMargin }; return new IntersectionObserver(n => this._observerCallback(n), e) } _observerCallback(e) { const n = s => this._targetLinks.get(`#${s.target.id}`), r = s => { this._previousScrollData.visibleEntryTop = s.target.offsetTop, this._process(n(s)) }, o = (this._rootElement || document.documentElement).scrollTop, i = o >= this._previousScrollData.parentScrollTop; this._previousScrollData.parentScrollTop = o; for (const s of e) { if (!s.isIntersecting) { this._activeTarget = null, this._clearActiveClass(n(s)); continue } const c = s.target.offsetTop >= this._previousScrollData.visibleEntryTop; if (i && c) { if (r(s), !o) return; continue } !i && !c && r(s) } } _initializeTargetsAndObservables() { this._targetLinks = new Map, this._observableSections = new Map; const e = J.find(Ec, this._config.target); for (const n of e) { if (!n.hash || tr(n)) continue; const r = J.findOne(decodeURI(n.hash), this._element); Fo(r) && (this._targetLinks.set(decodeURI(n.hash), n), this._observableSections.set(n.hash, r)) } } _process(e) { this._activeTarget !== e && (this._clearActiveClass(this._config.target), this._activeTarget = e, e.classList.add(Zr), this._activateParents(e), B.trigger(this._element, UT, { relatedTarget: e })) } _activateParents(e) { if (e.classList.contains(KT)) { J.findOne(ZT, e.closest(XT)).classList.add(Zr); return } for (const n of J.parents(e, zT)) for (const r of J.prev(n, YT)) r.classList.add(Zr) } _clearActiveClass(e) { e.classList.remove(Zr); const n = J.find(`${Ec}.${Zr}`, e); for (const r of n) r.classList.remove(Zr) } static jQueryInterface(e) { return this.each(function() { const n = Ca.getOrCreateInstance(this, e); if (typeof e == "string") { if (n[e] === void 0 || e.startsWith("_") || e === "constructor") throw new TypeError(`No method named "${e}"`); n[e]() } }) } } B.on(window, VT, () => { for (const t of J.find(WT)) Ca.getOrCreateInstance(t) }); Ht(Ca); const eS = "tab", tS = "bs.tab", jr = `.${tS}`, nS = `hide${jr}`, rS = `hidden${jr}`, oS = `show${jr}`, iS = `shown${jr}`, sS = `click${jr}`, aS = `keydown${jr}`, cS = `load${jr}`, lS = "ArrowLeft", Hd = "ArrowRight", uS = "ArrowUp", Ud = "ArrowDown", Er = "active", Vd = "fade", Ac = "show", fS = "dropdown", dS = ".dropdown-toggle", hS = ".dropdown-menu", Tc = ":not(.dropdown-toggle)", pS = '.list-group, .nav, [role="tablist"]', mS = ".nav-item, .list-group-item", gS = `.nav-link${Tc}, .list-group-item${Tc}, [role="tab"]${Tc}`, hg = '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]', Sc = `${gS}, ${hg}`, yS = `.${Er}[data-bs-toggle="tab"], .${Er}[data-bs-toggle="pill"], .${Er}[data-bs-toggle="list"]`; class Co extends Zt { constructor(e) { super(e), this._parent = this._element.closest(pS), this._parent && (this._setInitialAttributes(this._parent, this._getChildren()), B.on(this._element, aS, n => this._keydown(n))) } static get NAME() { return eS } show() { const e = this._element; if (this._elemIsActive(e)) return; const n = this._getActiveElem(), r = n ? B.trigger(n, nS, { relatedTarget: e }) : null; B.trigger(e, oS, { relatedTarget: n }).defaultPrevented || r && r.defaultPrevented || (this._deactivate(n, e), this._activate(e, n)) } _activate(e, n) { if (!e) return; e.classList.add(Er), this._activate(J.getElementFromSelector(e)); const r = () => { if (e.getAttribute("role") !== "tab") { e.classList.add(Ac); return } e.removeAttribute("tabindex"), e.setAttribute("aria-selected", !0), this._toggleDropDown(e, !0), B.trigger(e, iS, { relatedTarget: n }) }; this._queueCallback(r, e, e.classList.contains(Vd)) } _deactivate(e, n) { if (!e) return; e.classList.remove(Er), e.blur(), this._deactivate(J.getElementFromSelector(e)); const r = () => { if (e.getAttribute("role") !== "tab") { e.classList.remove(Ac); return } e.setAttribute("aria-selected", !1), e.setAttribute("tabindex", "-1"), this._toggleDropDown(e, !1), B.trigger(e, rS, { relatedTarget: n }) }; this._queueCallback(r, e, e.classList.contains(Vd)) } _keydown(e) { if (![lS, Hd, uS, Ud].includes(e.key)) return; e.stopPropagation(), e.preventDefault(); const n = [Hd, Ud].includes(e.key), r = wu(this._getChildren().filter(o => !tr(o)), e.target, n, !0); r && (r.focus({ preventScroll: !0 }), Co.getOrCreateInstance(r).show()) } _getChildren() { return J.find(Sc, this._parent) } _getActiveElem() { return this._getChildren().find(e => this._elemIsActive(e)) || null } _setInitialAttributes(e, n) { this._setAttributeIfNotExists(e, "role", "tablist"); for (const r of n) this._setInitialAttributesOnChild(r) } _setInitialAttributesOnChild(e) { e = this._getInnerElement(e); const n = this._elemIsActive(e), r = this._getOuterElement(e); e.setAttribute("aria-selected", n), r !== e && this._setAttributeIfNotExists(r, "role", "presentation"), n || e.setAttribute("tabindex", "-1"), this._setAttributeIfNotExists(e, "role", "tab"), this._setInitialAttributesOnTargetPanel(e) } _setInitialAttributesOnTargetPanel(e) { const n = J.getElementFromSelector(e); n && (this._setAttributeIfNotExists(n, "role", "tabpanel"), e.id && this._setAttributeIfNotExists(n, "aria-labelledby", `${e.id}`)) } _toggleDropDown(e, n) { const r = this._getOuterElement(e); if (!r.classList.contains(fS)) return; const o = (i, s) => { const c = J.findOne(i, r); c && c.classList.toggle(s, n) }; o(dS, Er), o(hS, Ac), r.setAttribute("aria-expanded", n) } _setAttributeIfNotExists(e, n, r) { e.hasAttribute(n) || e.setAttribute(n, r) } _elemIsActive(e) { return e.classList.contains(Er) } _getInnerElement(e) { return e.matches(Sc) ? e : J.findOne(Sc, e) } _getOuterElement(e) { return e.closest(mS) || e } static jQueryInterface(e) { return this.each(function() { const n = Co.getOrCreateInstance(this); if (typeof e == "string") { if (n[e] === void 0 || e.startsWith("_") || e === "constructor") throw new TypeError(`No method named "${e}"`); n[e]() } }) } } B.on(document, sS, hg, function(t) { ["A", "AREA"].includes(this.tagName) && t.preventDefault(), !tr(this) && Co.getOrCreateInstance(this).show() }); B.on(window, cS, () => { for (const t of J.find(yS)) Co.getOrCreateInstance(t) }); Ht(Co); const wS = "toast", bS = "bs.toast", lr = `.${bS}`, vS = `mouseover${lr}`, _S = `mouseout${lr}`, ES = `focusin${lr}`, AS = `focusout${lr}`, TS = `hide${lr}`, SS = `hidden${lr}`, CS = `show${lr}`, OS = `shown${lr}`, xS = "fade", Kd = "hide", ds = "show", hs = "showing", kS = { animation: "boolean", autohide: "boolean", delay: "number" }, RS = { animation: !0, autohide: !0, delay: 5e3 }; class Oa extends Zt { constructor(e, n) { super(e, n), this._timeout = null, this._hasMouseInteraction = !1, this._hasKeyboardInteraction = !1, this._setListeners() } static get Default() { return RS } static get DefaultType() { return kS } static get NAME() { return wS } show() { if (B.trigger(this._element, CS).defaultPrevented) return; this._clearTimeout(), this._config.animation && this._element.classList.add(xS); const n = () => { this._element.classList.remove(hs), B.trigger(this._element, OS), this._maybeScheduleHide() }; this._element.classList.remove(Kd), Ui(this._element), this._element.classList.add(ds, hs), this._queueCallback(n, this._element, this._config.animation) } hide() { if (!this.isShown() || B.trigger(this._element, TS).defaultPrevented) return; const n = () => { this._element.classList.add(Kd), this._element.classList.remove(hs, ds), B.trigger(this._element, SS) }; this._element.classList.add(hs), this._queueCallback(n, this._element, this._config.animation) } dispose() { this._clearTimeout(), this.isShown() && this._element.classList.remove(ds), super.dispose() } isShown() { return this._element.classList.contains(ds) } _maybeScheduleHide() { this._config.autohide && (this._hasMouseInteraction || this._hasKeyboardInteraction || (this._timeout = setTimeout(() => { this.hide() }, this._config.delay))) } _onInteraction(e, n) { switch (e.type) { case "mouseover": case "mouseout": { this._hasMouseInteraction = n; break } case "focusin": case "focusout": { this._hasKeyboardInteraction = n; break } }if (n) { this._clearTimeout(); return } const r = e.relatedTarget; this._element === r || this._element.contains(r) || this._maybeScheduleHide() } _setListeners() { B.on(this._element, vS, e => this._onInteraction(e, !0)), B.on(this._element, _S, e => this._onInteraction(e, !1)), B.on(this._element, ES, e => this._onInteraction(e, !0)), B.on(this._element, AS, e => this._onInteraction(e, !1)) } _clearTimeout() { clearTimeout(this._timeout), this._timeout = null } static jQueryInterface(e) { return this.each(function() { const n = Oa.getOrCreateInstance(this, e); if (typeof e == "string") { if (typeof n[e] > "u") throw new TypeError(`No method named "${e}"`); n[e](this) } }) } } Aa(Oa); Ht(Oa); function Au(t, e) { const n = Object.create(null), r = t.split(","); for (let o = 0; o < r.length; o++)n[r[o]] = !0; return e ? o => !!n[o.toLowerCase()] : o => !!n[o] } const Ie = {}, po = [], Gt = () => { }, IS = () => !1, PS = /^on[^a-z]/, xa = t => PS.test(t), Tu = t => t.startsWith("onUpdate:"), tt = Object.assign, Su = (t, e) => { const n = t.indexOf(e); n > -1 && t.splice(n, 1) }, NS = Object.prototype.hasOwnProperty, be = (t, e) => NS.call(t, e), te = Array.isArray, mo = t => zi(t) === "[object Map]", ka = t => zi(t) === "[object Set]", Wd = t => zi(t) === "[object Date]", ce = t => typeof t == "function", Ge = t => typeof t == "string", xi = t => typeof t == "symbol", ke = t => t !== null && typeof t == "object", pg = t => ke(t) && ce(t.then) && ce(t.catch), mg = Object.prototype.toString, zi = t => mg.call(t), LS = t => zi(t).slice(8, -1), gg = t => zi(t) === "[object Object]", Cu = t => Ge(t) && t !== "NaN" && t[0] !== "-" && "" + parseInt(t, 10) === t, Ns = Au(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"), Ra = t => { const e = Object.create(null); return n => e[n] || (e[n] = t(n)) }, DS = /-(\w)/g, dn = Ra(t => t.replace(DS, (e, n) => n ? n.toUpperCase() : "")), BS = /\B([A-Z])/g, Uo = Ra(t => t.replace(BS, "-$1").toLowerCase()), Ia = Ra(t => t.charAt(0).toUpperCase() + t.slice(1)), Cc = Ra(t => t ? `on${Ia(t)}` : ""), ki = (t, e) => !Object.is(t, e), Ls = (t, e) => { for (let n = 0; n < t.length; n++)t[n](e) }, Qs = (t, e, n) => { Object.defineProperty(t, e, { configurable: !0, enumerable: !1, value: n }) }, ea = t => { const e = parseFloat(t); return isNaN(e) ? t : e }; let zd; const ul = () => zd || (zd = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {}); function Ou(t) { if (te(t)) { const e = {}; for (let n = 0; n < t.length; n++) { const r = t[n], o = Ge(r) ? jS(r) : Ou(r); if (o) for (const i in o) e[i] = o[i] } return e } else { if (Ge(t)) return t; if (ke(t)) return t } } const $S = /;(?![^(]*\))/g, MS = /:([^]+)/, FS = /\/\*[^]*?\*\//g; function jS(t) { const e = {}; return t.replace(FS, "").split($S).forEach(n => { if (n) { const r = n.split(MS); r.length > 1 && (e[r[0].trim()] = r[1].trim()) } }), e } function xu(t) { let e = ""; if (Ge(t)) e = t; else if (te(t)) for (let n = 0; n < t.length; n++) { const r = xu(t[n]); r && (e += r + " ") } else if (ke(t)) for (const n in t) t[n] && (e += n + " "); return e.trim() } const HS = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", US = Au(HS); function yg(t) { return !!t || t === "" } function VS(t, e) { if (t.length !== e.length) return !1; let n = !0; for (let r = 0; n && r < t.length; r++)n = Pa(t[r], e[r]); return n } function Pa(t, e) { if (t === e) return !0; let n = Wd(t), r = Wd(e); if (n || r) return n && r ? t.getTime() === e.getTime() : !1; if (n = xi(t), r = xi(e), n || r) return t === e; if (n = te(t), r = te(e), n || r) return n && r ? VS(t, e) : !1; if (n = ke(t), r = ke(e), n || r) { if (!n || !r) return !1; const o = Object.keys(t).length, i = Object.keys(e).length; if (o !== i) return !1; for (const s in t) { const c = t.hasOwnProperty(s), u = e.hasOwnProperty(s); if (c && !u || !c && u || !Pa(t[s], e[s])) return !1 } } return String(t) === String(e) } function KS(t, e) { return t.findIndex(n => Pa(n, e)) } const tn = t => Ge(t) ? t : t == null ? "" : te(t) || ke(t) && (t.toString === mg || !ce(t.toString)) ? JSON.stringify(t, wg, 2) : String(t), wg = (t, e) => e && e.__v_isRef ? wg(t, e.value) : mo(e) ? { [`Map(${e.size})`]: [...e.entries()].reduce((n, [r, o]) => (n[`${r} =>`] = o, n), {}) } : ka(e) ? { [`Set(${e.size})`]: [...e.values()] } : ke(e) && !te(e) && !gg(e) ? String(e) : e; let Vt; class WS { constructor(e = !1) { this.detached = e, this._active = !0, this.effects = [], this.cleanups = [], this.parent = Vt, !e && Vt && (this.index = (Vt.scopes || (Vt.scopes = [])).push(this) - 1) } get active() { return this._active } run(e) { if (this._active) { const n = Vt; try { return Vt = this, e() } finally { Vt = n } } } on() { Vt = this } off() { Vt = this.parent } stop(e) { if (this._active) { let n, r; for (n = 0, r = this.effects.length; n < r; n++)this.effects[n].stop(); for (n = 0, r = this.cleanups.length; n < r; n++)this.cleanups[n](); if (this.scopes) for (n = 0, r = this.scopes.length; n < r; n++)this.scopes[n].stop(!0); if (!this.detached && this.parent && !e) { const o = this.parent.scopes.pop(); o && o !== this && (this.parent.scopes[this.index] = o, o.index = this.index) } this.parent = void 0, this._active = !1 } } } function zS(t, e = Vt) { e && e.active && e.effects.push(t) } function qS() { return Vt } const ku = t => { const e = new Set(t); return e.w = 0, e.n = 0, e }, bg = t => (t.w & or) > 0, vg = t => (t.n & or) > 0, GS = ({ deps: t }) => { if (t.length) for (let e = 0; e < t.length; e++)t[e].w |= or }, YS = t => { const { deps: e } = t; if (e.length) { let n = 0; for (let r = 0; r < e.length; r++) { const o = e[r]; bg(o) && !vg(o) ? o.delete(t) : e[n++] = o, o.w &= ~or, o.n &= ~or } e.length = n } }, fl = new WeakMap; let mi = 0, or = 1; const dl = 30; let Wt; const xr = Symbol(""), hl = Symbol(""); class Ru { constructor(e, n = null, r) { this.fn = e, this.scheduler = n, this.active = !0, this.deps = [], this.parent = void 0, zS(this, r) } run() { if (!this.active) return this.fn(); let e = Wt, n = Xn; for (; e;) { if (e === this) return; e = e.parent } try { return this.parent = Wt, Wt = this, Xn = !0, or = 1 << ++mi, mi <= dl ? GS(this) : qd(this), this.fn() } finally { mi <= dl && YS(this), or = 1 << --mi, Wt = this.parent, Xn = n, this.parent = void 0, this.deferStop && this.stop() } } stop() { Wt === this ? this.deferStop = !0 : this.active && (qd(this), this.onStop && this.onStop(), this.active = !1) } } function qd(t) { const { deps: e } = t; if (e.length) { for (let n = 0; n < e.length; n++)e[n].delete(t); e.length = 0 } } let Xn = !0; const _g = []; function Vo() { _g.push(Xn), Xn = !1 } function Ko() { const t = _g.pop(); Xn = t === void 0 ? !0 : t } function xt(t, e, n) { if (Xn && Wt) { let r = fl.get(t); r || fl.set(t, r = new Map); let o = r.get(n); o || r.set(n, o = ku()), Eg(o) } } function Eg(t, e) { let n = !1; mi <= dl ? vg(t) || (t.n |= or, n = !bg(t)) : n = !t.has(Wt), n && (t.add(Wt), Wt.deps.push(t)) } function Rn(t, e, n, r, o, i) { const s = fl.get(t); if (!s) return; let c = []; if (e === "clear") c = [...s.values()]; else if (n === "length" && te(t)) { const u = Number(r); s.forEach((a, d) => { (d === "length" || d >= u) && c.push(a) }) } else switch (n !== void 0 && c.push(s.get(n)), e) { case "add": te(t) ? Cu(n) && c.push(s.get("length")) : (c.push(s.get(xr)), mo(t) && c.push(s.get(hl))); break; case "delete": te(t) || (c.push(s.get(xr)), mo(t) && c.push(s.get(hl))); break; case "set": mo(t) && c.push(s.get(xr)); break }if (c.length === 1) c[0] && pl(c[0]); else { const u = []; for (const a of c) a && u.push(...a); pl(ku(u)) } } function pl(t, e) { const n = te(t) ? t : [...t]; for (const r of n) r.computed && Gd(r); for (const r of n) r.computed || Gd(r) } function Gd(t, e) { (t !== Wt || t.allowRecurse) && (t.scheduler ? t.scheduler() : t.run()) } const XS = Au("__proto__,__v_isRef,__isVue"), Ag = new Set(Object.getOwnPropertyNames(Symbol).filter(t => t !== "arguments" && t !== "caller").map(t => Symbol[t]).filter(xi)), ZS = Iu(), JS = Iu(!1, !0), QS = Iu(!0), Yd = eC(); function eC() { const t = {}; return ["includes", "indexOf", "lastIndexOf"].forEach(e => { t[e] = function(...n) { const r = Ae(this); for (let i = 0, s = this.length; i < s; i++)xt(r, "get", i + ""); const o = r[e](...n); return o === -1 || o === !1 ? r[e](...n.map(Ae)) : o } }), ["push", "pop", "shift", "unshift", "splice"].forEach(e => { t[e] = function(...n) { Vo(); const r = Ae(this)[e].apply(this, n); return Ko(), r } }), t } function tC(t) { const e = Ae(this); return xt(e, "has", t), e.hasOwnProperty(t) } function Iu(t = !1, e = !1) { return function(r, o, i) { if (o === "__v_isReactive") return !t; if (o === "__v_isReadonly") return t; if (o === "__v_isShallow") return e; if (o === "__v_raw" && i === (t ? e ? yC : xg : e ? Og : Cg).get(r)) return r; const s = te(r); if (!t) { if (s && be(Yd, o)) return Reflect.get(Yd, o, i); if (o === "hasOwnProperty") return tC } const c = Reflect.get(r, o, i); return (xi(o) ? Ag.has(o) : XS(o)) || (t || xt(r, "get", o), e) ? c : ft(c) ? s && Cu(o) ? c : c.value : ke(c) ? t ? kg(c) : Wo(c) : c } } const nC = Tg(), rC = Tg(!0); function Tg(t = !1) { return function(n, r, o, i) { let s = n[r]; if (Oo(s) && ft(s) && !ft(o)) return !1; if (!t && (!ta(o) && !Oo(o) && (s = Ae(s), o = Ae(o)), !te(n) && ft(s) && !ft(o))) return s.value = o, !0; const c = te(n) && Cu(r) ? Number(r) < n.length : be(n, r), u = Reflect.set(n, r, o, i); return n === Ae(i) && (c ? ki(o, s) && Rn(n, "set", r, o) : Rn(n, "add", r, o)), u } } function oC(t, e) { const n = be(t, e); t[e]; const r = Reflect.deleteProperty(t, e); return r && n && Rn(t, "delete", e, void 0), r } function iC(t, e) { const n = Reflect.has(t, e); return (!xi(e) || !Ag.has(e)) && xt(t, "has", e), n } function sC(t) { return xt(t, "iterate", te(t) ? "length" : xr), Reflect.ownKeys(t) } const Sg = { get: ZS, set: nC, deleteProperty: oC, has: iC, ownKeys: sC }, aC = { get: QS, set(t, e) { return !0 }, deleteProperty(t, e) { return !0 } }, cC = tt({}, Sg, { get: JS, set: rC }), Pu = t => t, Na = t => Reflect.getPrototypeOf(t); function ps(t, e, n = !1, r = !1) { t = t.__v_raw; const o = Ae(t), i = Ae(e); n || (e !== i && xt(o, "get", e), xt(o, "get", i)); const { has: s } = Na(o), c = r ? Pu : n ? Du : Ri; if (s.call(o, e)) return c(t.get(e)); if (s.call(o, i)) return c(t.get(i)); t !== o && t.get(e) } function ms(t, e = !1) { const n = this.__v_raw, r = Ae(n), o = Ae(t); return e || (t !== o && xt(r, "has", t), xt(r, "has", o)), t === o ? n.has(t) : n.has(t) || n.has(o) } function gs(t, e = !1) { return t = t.__v_raw, !e && xt(Ae(t), "iterate", xr), Reflect.get(t, "size", t) } function Xd(t) { t = Ae(t); const e = Ae(this); return Na(e).has.call(e, t) || (e.add(t), Rn(e, "add", t, t)), this } function Zd(t, e) { e = Ae(e); const n = Ae(this), { has: r, get: o } = Na(n); let i = r.call(n, t); i || (t = Ae(t), i = r.call(n, t)); const s = o.call(n, t); return n.set(t, e), i ? ki(e, s) && Rn(n, "set", t, e) : Rn(n, "add", t, e), this } function Jd(t) { const e = Ae(this), { has: n, get: r } = Na(e); let o = n.call(e, t); o || (t = Ae(t), o = n.call(e, t)), r && r.call(e, t); const i = e.delete(t); return o && Rn(e, "delete", t, void 0), i } function Qd() { const t = Ae(this), e = t.size !== 0, n = t.clear(); return e && Rn(t, "clear", void 0, void 0), n } function ys(t, e) { return function(r, o) { const i = this, s = i.__v_raw, c = Ae(s), u = e ? Pu : t ? Du : Ri; return !t && xt(c, "iterate", xr), s.forEach((a, d) => r.call(o, u(a), u(d), i)) } } function ws(t, e, n) { return function(...r) { const o = this.__v_raw, i = Ae(o), s = mo(i), c = t === "entries" || t === Symbol.iterator && s, u = t === "keys" && s, a = o[t](...r), d = n ? Pu : e ? Du : Ri; return !e && xt(i, "iterate", u ? hl : xr), { next() { const { value: h, done: m } = a.next(); return m ? { value: h, done: m } : { value: c ? [d(h[0]), d(h[1])] : d(h), done: m } }, [Symbol.iterator]() { return this } } } } function Fn(t) { return function(...e) { return t === "delete" ? !1 : this } } function lC() { const t = { get(i) { return ps(this, i) }, get size() { return gs(this) }, has: ms, add: Xd, set: Zd, delete: Jd, clear: Qd, forEach: ys(!1, !1) }, e = { get(i) { return ps(this, i, !1, !0) }, get size() { return gs(this) }, has: ms, add: Xd, set: Zd, delete: Jd, clear: Qd, forEach: ys(!1, !0) }, n = { get(i) { return ps(this, i, !0) }, get size() { return gs(this, !0) }, has(i) { return ms.call(this, i, !0) }, add: Fn("add"), set: Fn("set"), delete: Fn("delete"), clear: Fn("clear"), forEach: ys(!0, !1) }, r = { get(i) { return ps(this, i, !0, !0) }, get size() { return gs(this, !0) }, has(i) { return ms.call(this, i, !0) }, add: Fn("add"), set: Fn("set"), delete: Fn("delete"), clear: Fn("clear"), forEach: ys(!0, !0) }; return ["keys", "values", "entries", Symbol.iterator].forEach(i => { t[i] = ws(i, !1, !1), n[i] = ws(i, !0, !1), e[i] = ws(i, !1, !0), r[i] = ws(i, !0, !0) }), [t, n, e, r] } const [uC, fC, dC, hC] = lC(); function Nu(t, e) { const n = e ? t ? hC : dC : t ? fC : uC; return (r, o, i) => o === "__v_isReactive" ? !t : o === "__v_isReadonly" ? t : o === "__v_raw" ? r : Reflect.get(be(n, o) && o in r ? n : r, o, i) } const pC = { get: Nu(!1, !1) }, mC = { get: Nu(!1, !0) }, gC = { get: Nu(!0, !1) }, Cg = new WeakMap, Og = new WeakMap, xg = new WeakMap, yC = new WeakMap; function wC(t) { switch (t) { case "Object": case "Array": return 1; case "Map": case "Set": case "WeakMap": case "WeakSet": return 2; default: return 0 } } function bC(t) { return t.__v_skip || !Object.isExtensible(t) ? 0 : wC(LS(t)) } function Wo(t) { return Oo(t) ? t : Lu(t, !1, Sg, pC, Cg) } function vC(t) { return Lu(t, !1, cC, mC, Og) } function kg(t) { return Lu(t, !0, aC, gC, xg) } function Lu(t, e, n, r, o) { if (!ke(t) || t.__v_raw && !(e && t.__v_isReactive)) return t; const i = o.get(t); if (i) return i; const s = bC(t); if (s === 0) return t; const c = new Proxy(t, s === 2 ? r : n); return o.set(t, c), c } function go(t) { return Oo(t) ? go(t.__v_raw) : !!(t && t.__v_isReactive) } function Oo(t) { return !!(t && t.__v_isReadonly) } function ta(t) { return !!(t && t.__v_isShallow) } function Rg(t) { return go(t) || Oo(t) } function Ae(t) { const e = t && t.__v_raw; return e ? Ae(e) : t } function Ig(t) { return Qs(t, "__v_skip", !0), t } const Ri = t => ke(t) ? Wo(t) : t, Du = t => ke(t) ? kg(t) : t; function Pg(t) { Xn && Wt && (t = Ae(t), Eg(t.dep || (t.dep = ku()))) } function Ng(t, e) { t = Ae(t); const n = t.dep; n && pl(n) } function ft(t) { return !!(t && t.__v_isRef === !0) } function La(t) { return Lg(t, !1) } function _C(t) { return Lg(t, !0) } function Lg(t, e) { return ft(t) ? t : new EC(t, e) } class EC { constructor(e, n) { this.__v_isShallow = n, this.dep = void 0, this.__v_isRef = !0, this._rawValue = n ? e : Ae(e), this._value = n ? e : Ri(e) } get value() { return Pg(this), this._value } set value(e) { const n = this.__v_isShallow || ta(e) || Oo(e); e = n ? e : Ae(e), ki(e, this._rawValue) && (this._rawValue = e, this._value = n ? e : Ri(e), Ng(this)) } } function yo(t) { return ft(t) ? t.value : t } const AC = { get: (t, e, n) => yo(Reflect.get(t, e, n)), set: (t, e, n, r) => { const o = t[e]; return ft(o) && !ft(n) ? (o.value = n, !0) : Reflect.set(t, e, n, r) } }; function Dg(t) { return go(t) ? t : new Proxy(t, AC) } class TC { constructor(e, n, r, o) { this._setter = n, this.dep = void 0, this.__v_isRef = !0, this.__v_isReadonly = !1, this._dirty = !0, this.effect = new Ru(e, () => { this._dirty || (this._dirty = !0, Ng(this)) }), this.effect.computed = this, this.effect.active = this._cacheable = !o, this.__v_isReadonly = r } get value() { const e = Ae(this); return Pg(e), (e._dirty || !e._cacheable) && (e._dirty = !1, e._value = e.effect.run()), e._value } set value(e) { this._setter(e) } } function SC(t, e, n = !1) { let r, o; const i = ce(t); return i ? (r = t, o = Gt) : (r = t.get, o = t.set), new TC(r, o, i || !o, n) } function Zn(t, e, n, r) { let o; try { o = r ? t(...r) : t() } catch (i) { Da(i, e, n) } return o } function Yt(t, e, n, r) { if (ce(t)) { const i = Zn(t, e, n, r); return i && pg(i) && i.catch(s => { Da(s, e, n) }), i } const o = []; for (let i = 0; i < t.length; i++)o.push(Yt(t[i], e, n, r)); return o } function Da(t, e, n, r = !0) { const o = e ? e.vnode : null; if (e) { let i = e.parent; const s = e.proxy, c = n; for (; i;) { const a = i.ec; if (a) { for (let d = 0; d < a.length; d++)if (a[d](t, s, c) === !1) return } i = i.parent } const u = e.appContext.config.errorHandler; if (u) { Zn(u, null, 10, [t, s, c]); return } } CC(t, n, o, r) } function CC(t, e, n, r = !0) { console.error(t) } let Ii = !1, ml = !1; const ut = []; let rn = 0; const wo = []; let vn = null, yr = 0; const Bg = Promise.resolve(); let Bu = null; function $g(t) { const e = Bu || Bg; return t ? e.then(this ? t.bind(this) : t) : e } function OC(t) { let e = rn + 1, n = ut.length; for (; e < n;) { const r = e + n >>> 1; Pi(ut[r]) < t ? e = r + 1 : n = r } return e } function $u(t) { (!ut.length || !ut.includes(t, Ii && t.allowRecurse ? rn + 1 : rn)) && (t.id == null ? ut.push(t) : ut.splice(OC(t.id), 0, t), Mg()) } function Mg() { !Ii && !ml && (ml = !0, Bu = Bg.then(jg)) } function xC(t) { const e = ut.indexOf(t); e > rn && ut.splice(e, 1) } function kC(t) { te(t) ? wo.push(...t) : (!vn || !vn.includes(t, t.allowRecurse ? yr + 1 : yr)) && wo.push(t), Mg() } function eh(t, e = Ii ? rn + 1 : 0) { for (; e < ut.length; e++) { const n = ut[e]; n && n.pre && (ut.splice(e, 1), e--, n()) } } function Fg(t) { if (wo.length) { const e = [...new Set(wo)]; if (wo.length = 0, vn) { vn.push(...e); return } for (vn = e, vn.sort((n, r) => Pi(n) - Pi(r)), yr = 0; yr < vn.length; yr++)vn[yr](); vn = null, yr = 0 } } const Pi = t => t.id == null ? 1 / 0 : t.id, RC = (t, e) => { const n = Pi(t) - Pi(e); if (n === 0) { if (t.pre && !e.pre) return -1; if (e.pre && !t.pre) return 1 } return n }; function jg(t) { ml = !1, Ii = !0, ut.sort(RC); const e = Gt; try { for (rn = 0; rn < ut.length; rn++) { const n = ut[rn]; n && n.active !== !1 && Zn(n, null, 14) } } finally { rn = 0, ut.length = 0, Fg(), Ii = !1, Bu = null, (ut.length || wo.length) && jg() } } function IC(t, e, ...n) { if (t.isUnmounted) return; const r = t.vnode.props || Ie; let o = n; const i = e.startsWith("update:"), s = i && e.slice(7); if (s && s in r) { const d = `${s === "modelValue" ? "model" : s}Modifiers`, { number: h, trim: m } = r[d] || Ie; m && (o = n.map(g => Ge(g) ? g.trim() : g)), h && (o = n.map(ea)) } let c, u = r[c = Cc(e)] || r[c = Cc(dn(e))]; !u && i && (u = r[c = Cc(Uo(e))]), u && Yt(u, t, 6, o); const a = r[c + "Once"]; if (a) { if (!t.emitted) t.emitted = {}; else if (t.emitted[c]) return; t.emitted[c] = !0, Yt(a, t, 6, o) } } function Hg(t, e, n = !1) { const r = e.emitsCache, o = r.get(t); if (o !== void 0) return o; const i = t.emits; let s = {}, c = !1; if (!ce(t)) { const u = a => { const d = Hg(a, e, !0); d && (c = !0, tt(s, d)) }; !n && e.mixins.length && e.mixins.forEach(u), t.extends && u(t.extends), t.mixins && t.mixins.forEach(u) } return !i && !c ? (ke(t) && r.set(t, null), null) : (te(i) ? i.forEach(u => s[u] = null) : tt(s, i), ke(t) && r.set(t, s), s) } function Ba(t, e) { return !t || !xa(e) ? !1 : (e = e.slice(2).replace(/Once$/, ""), be(t, e[0].toLowerCase() + e.slice(1)) || be(t, Uo(e)) || be(t, e)) } let st = null, $a = null; function na(t) { const e = st; return st = t, $a = t && t.type.__scopeId || null, e } function Ug(t) { $a = t } function Vg() { $a = null } function gl(t, e = st, n) { if (!e || t._n) return t; const r = (...o) => { r._d && fh(-1); const i = na(e); let s; try { s = t(...o) } finally { na(i), r._d && fh(1) } return s }; return r._n = !0, r._c = !0, r._d = !0, r } function Oc(t) { const { type: e, vnode: n, proxy: r, withProxy: o, props: i, propsOptions: [s], slots: c, attrs: u, emit: a, render: d, renderCache: h, data: m, setupState: g, ctx: y, inheritAttrs: _ } = t; let A, E; const T = na(t); try { if (n.shapeFlag & 4) { const P = o || r; A = nn(d.call(P, P, h, i, g, m, y)), E = u } else { const P = e; A = nn(P.length > 1 ? P(i, { attrs: u, slots: c, emit: a }) : P(i, null)), E = e.props ? u : PC(u) } } catch (P) { Ai.length = 0, Da(P, t, 1), A = Ve(ir) } let x = A; if (E && _ !== !1) { const P = Object.keys(E), { shapeFlag: W } = x; P.length && W & 7 && (s && P.some(Tu) && (E = NC(E, s)), x = xo(x, E)) } return n.dirs && (x = xo(x), x.dirs = x.dirs ? x.dirs.concat(n.dirs) : n.dirs), n.transition && (x.transition = n.transition), A = x, na(T), A } const PC = t => { let e; for (const n in t) (n === "class" || n === "style" || xa(n)) && ((e || (e = {}))[n] = t[n]); return e }, NC = (t, e) => { const n = {}; for (const r in t) (!Tu(r) || !(r.slice(9) in e)) && (n[r] = t[r]); return n }; function LC(t, e, n) { const { props: r, children: o, component: i } = t, { props: s, children: c, patchFlag: u } = e, a = i.emitsOptions; if (e.dirs || e.transition) return !0; if (n && u >= 0) { if (u & 1024) return !0; if (u & 16) return r ? th(r, s, a) : !!s; if (u & 8) { const d = e.dynamicProps; for (let h = 0; h < d.length; h++) { const m = d[h]; if (s[m] !== r[m] && !Ba(a, m)) return !0 } } } else return (o || c) && (!c || !c.$stable) ? !0 : r === s ? !1 : r ? s ? th(r, s, a) : !0 : !!s; return !1 } function th(t, e, n) { const r = Object.keys(e); if (r.length !== Object.keys(t).length) return !0; for (let o = 0; o < r.length; o++) { const i = r[o]; if (e[i] !== t[i] && !Ba(n, i)) return !0 } return !1 } function DC({ vnode: t, parent: e }, n) { for (; e && e.subTree === t;)(t = e.vnode).el = n, e = e.parent } const BC = t => t.__isSuspense; function $C(t, e) { e && e.pendingBranch ? te(t) ? e.effects.push(...t) : e.effects.push(t) : kC(t) } function MC(t, e) { return Ma(t, null, e) } function FC(t, e) { return Ma(t, null, { flush: "post" }) } const bs = {}; function Ds(t, e, n) { return Ma(t, e, n) } function Ma(t, e, { immediate: n, deep: r, flush: o, onTrack: i, onTrigger: s } = Ie) { var c; const u = qS() === ((c = Je) == null ? void 0 : c.scope) ? Je : null; let a, d = !1, h = !1; if (ft(t) ? (a = () => t.value, d = ta(t)) : go(t) ? (a = () => t, r = !0) : te(t) ? (h = !0, d = t.some(P => go(P) || ta(P)), a = () => t.map(P => { if (ft(P)) return P.value; if (go(P)) return Ar(P); if (ce(P)) return Zn(P, u, 2) })) : ce(t) ? e ? a = () => Zn(t, u, 2) : a = () => { if (!(u && u.isUnmounted)) return m && m(), Yt(t, u, 3, [g]) } : a = Gt, e && r) { const P = a; a = () => Ar(P()) } let m, g = P => { m = T.onStop = () => { Zn(P, u, 4) } }, y; if (Li) if (g = Gt, e ? n && Yt(e, u, 3, [a(), h ? [] : void 0, g]) : a(), o === "sync") { const P = N2(); y = P.__watcherHandles || (P.__watcherHandles = []) } else return Gt; let _ = h ? new Array(t.length).fill(bs) : bs; const A = () => { if (T.active) if (e) { const P = T.run(); (r || d || (h ? P.some((W, Y) => ki(W, _[Y])) : ki(P, _))) && (m && m(), Yt(e, u, 3, [P, _ === bs ? void 0 : h && _[0] === bs ? [] : _, g]), _ = P) } else T.run() }; A.allowRecurse = !!e; let E; o === "sync" ? E = A : o === "post" ? E = () => Tt(A, u && u.suspense) : (A.pre = !0, u && (A.id = u.uid), E = () => $u(A)); const T = new Ru(a, E); e ? n ? A() : _ = T.run() : o === "post" ? Tt(T.run.bind(T), u && u.suspense) : T.run(); const x = () => { T.stop(), u && u.scope && Su(u.scope.effects, T) }; return y && y.push(x), x } function jC(t, e, n) { const r = this.proxy, o = Ge(t) ? t.includes(".") ? Kg(r, t) : () => r[t] : t.bind(r, r); let i; ce(e) ? i = e : (i = e.handler, n = e); const s = Je; ko(this); const c = Ma(o, i.bind(r), n); return s ? ko(s) : kr(), c } function Kg(t, e) { const n = e.split("."); return () => { let r = t; for (let o = 0; o < n.length && r; o++)r = r[n[o]]; return r } } function Ar(t, e) { if (!ke(t) || t.__v_skip || (e = e || new Set, e.has(t))) return t; if (e.add(t), ft(t)) Ar(t.value, e); else if (te(t)) for (let n = 0; n < t.length; n++)Ar(t[n], e); else if (ka(t) || mo(t)) t.forEach(n => { Ar(n, e) }); else if (gg(t)) for (const n in t) Ar(t[n], e); return t } function Tr(t, e) { const n = st; if (n === null) return t; const r = Ua(n) || n.proxy, o = t.dirs || (t.dirs = []); for (let i = 0; i < e.length; i++) { let [s, c, u, a = Ie] = e[i]; s && (ce(s) && (s = { mounted: s, updated: s }), s.deep && Ar(c), o.push({ dir: s, instance: r, value: c, oldValue: void 0, arg: u, modifiers: a })) } return t } function dr(t, e, n, r) { const o = t.dirs, i = e && e.dirs; for (let s = 0; s < o.length; s++) { const c = o[s]; i && (c.oldValue = i[s].value); let u = c.dir[r]; u && (Vo(), Yt(u, n, 8, [t.el, c, t, e]), Ko()) } } function Wg(t, e) { return ce(t) ? (() => tt({ name: t.name }, e, { setup: t }))() : t } const _i = t => !!t.type.__asyncLoader, zg = t => t.type.__isKeepAlive; function HC(t, e) { qg(t, "a", e) } function UC(t, e) { qg(t, "da", e) } function qg(t, e, n = Je) { const r = t.__wdc || (t.__wdc = () => { let o = n; for (; o;) { if (o.isDeactivated) return; o = o.parent } return t() }); if (Fa(e, r, n), n) { let o = n.parent; for (; o && o.parent;)zg(o.parent.vnode) && VC(r, e, n, o), o = o.parent } } function VC(t, e, n, r) { const o = Fa(e, t, r, !0); Fu(() => { Su(r[e], o) }, n) } function Fa(t, e, n = Je, r = !1) { if (n) { const o = n[t] || (n[t] = []), i = e.__weh || (e.__weh = (...s) => { if (n.isUnmounted) return; Vo(), ko(n); const c = Yt(e, n, t, s); return kr(), Ko(), c }); return r ? o.unshift(i) : o.push(i), i } } const Dn = t => (e, n = Je) => (!Li || t === "sp") && Fa(t, (...r) => e(...r), n), KC = Dn("bm"), Mu = Dn("m"), WC = Dn("bu"), zC = Dn("u"), qC = Dn("bum"), Fu = Dn("um"), GC = Dn("sp"), YC = Dn("rtg"), XC = Dn("rtc"); function ZC(t, e = Je) { Fa("ec", t, e) } const Gg = "components"; function io(t, e) { return QC(Gg, t, !0, e) || t } const JC = Symbol.for("v-ndc"); function QC(t, e, n = !0, r = !1) { const o = st || Je; if (o) { const i = o.type; if (t === Gg) { const c = R2(i, !1); if (c && (c === e || c === dn(e) || c === Ia(dn(e)))) return i } const s = nh(o[t] || i[t], e) || nh(o.appContext[t], e); return !s && r ? i : s } } function nh(t, e) { return t && (t[e] || t[dn(e)] || t[Ia(dn(e))]) } function Yg(t, e, n, r) { let o; const i = n && n[r]; if (te(t) || Ge(t)) { o = new Array(t.length); for (let s = 0, c = t.length; s < c; s++)o[s] = e(t[s], s, void 0, i && i[s]) } else if (typeof t == "number") { o = new Array(t); for (let s = 0; s < t; s++)o[s] = e(s + 1, s, void 0, i && i[s]) } else if (ke(t)) if (t[Symbol.iterator]) o = Array.from(t, (s, c) => e(s, c, void 0, i && i[c])); else { const s = Object.keys(t); o = new Array(s.length); for (let c = 0, u = s.length; c < u; c++) { const a = s[c]; o[c] = e(t[a], a, c, i && i[c]) } } else o = []; return n && (n[r] = o), o } function e2(t, e, n = {}, r, o) { if (st.isCE || st.parent && _i(st.parent) && st.parent.isCE) return e !== "default" && (n.name = e), Ve("slot", n, r && r()); let i = t[e]; i && i._c && (i._d = !1), Le(); const s = i && Xg(i(n)), c = sy(mt, { key: n.key || s && s.key || `_${e}` }, s || (r ? r() : []), s && t._ === 1 ? 64 : -2); return !o && c.scopeId && (c.slotScopeIds = [c.scopeId + "-s"]), i && i._c && (i._d = !0), c } function Xg(t) { return t.some(e => ia(e) ? !(e.type === ir || e.type === mt && !Xg(e.children)) : !0) ? t : null } const yl = t => t ? cy(t) ? Ua(t) || t.proxy : yl(t.parent) : null, Ei = tt(Object.create(null), { $: t => t, $el: t => t.vnode.el, $data: t => t.data, $props: t => t.props, $attrs: t => t.attrs, $slots: t => t.slots, $refs: t => t.refs, $parent: t => yl(t.parent), $root: t => yl(t.root), $emit: t => t.emit, $options: t => ju(t), $forceUpdate: t => t.f || (t.f = () => $u(t.update)), $nextTick: t => t.n || (t.n = $g.bind(t.proxy)), $watch: t => jC.bind(t) }), xc = (t, e) => t !== Ie && !t.__isScriptSetup && be(t, e), t2 = { get({ _: t }, e) { const { ctx: n, setupState: r, data: o, props: i, accessCache: s, type: c, appContext: u } = t; let a; if (e[0] !== "$") { const g = s[e]; if (g !== void 0) switch (g) { case 1: return r[e]; case 2: return o[e]; case 4: return n[e]; case 3: return i[e] } else { if (xc(r, e)) return s[e] = 1, r[e]; if (o !== Ie && be(o, e)) return s[e] = 2, o[e]; if ((a = t.propsOptions[0]) && be(a, e)) return s[e] = 3, i[e]; if (n !== Ie && be(n, e)) return s[e] = 4, n[e]; wl && (s[e] = 0) } } const d = Ei[e]; let h, m; if (d) return e === "$attrs" && xt(t, "get", e), d(t); if ((h = c.__cssModules) && (h = h[e])) return h; if (n !== Ie && be(n, e)) return s[e] = 4, n[e]; if (m = u.config.globalProperties, be(m, e)) return m[e] }, set({ _: t }, e, n) { const { data: r, setupState: o, ctx: i } = t; return xc(o, e) ? (o[e] = n, !0) : r !== Ie && be(r, e) ? (r[e] = n, !0) : be(t.props, e) || e[0] === "$" && e.slice(1) in t ? !1 : (i[e] = n, !0) }, has({ _: { data: t, setupState: e, accessCache: n, ctx: r, appContext: o, propsOptions: i } }, s) { let c; return !!n[s] || t !== Ie && be(t, s) || xc(e, s) || (c = i[0]) && be(c, s) || be(r, s) || be(Ei, s) || be(o.config.globalProperties, s) }, defineProperty(t, e, n) { return n.get != null ? t._.accessCache[e] = 0 : be(n, "value") && this.set(t, e, n.value, null), Reflect.defineProperty(t, e, n) } }; function rh(t) { return te(t) ? t.reduce((e, n) => (e[n] = null, e), {}) : t } let wl = !0; function n2(t) { const e = ju(t), n = t.proxy, r = t.ctx; wl = !1, e.beforeCreate && oh(e.beforeCreate, t, "bc"); const { data: o, computed: i, methods: s, watch: c, provide: u, inject: a, created: d, beforeMount: h, mounted: m, beforeUpdate: g, updated: y, activated: _, deactivated: A, beforeDestroy: E, beforeUnmount: T, destroyed: x, unmounted: P, render: W, renderTracked: Y, renderTriggered: Z, errorCaptured: he, serverPrefetch: re, expose: z, inheritAttrs: ye, components: De, directives: fe, filters: He } = e; if (a && r2(a, r, null), s) for (const ie in s) { const oe = s[ie]; ce(oe) && (r[ie] = oe.bind(n)) } if (o) { const ie = o.call(n, n); ke(ie) && (t.data = Wo(ie)) } if (wl = !0, i) for (const ie in i) { const oe = i[ie], Re = ce(oe) ? oe.bind(n, n) : ce(oe.get) ? oe.get.bind(n, n) : Gt, $e = !ce(oe) && ce(oe.set) ? oe.set.bind(n) : Gt, at = Ke({ get: Re, set: $e }); Object.defineProperty(r, ie, { enumerable: !0, configurable: !0, get: () => at.value, set: Ce => at.value = Ce }) } if (c) for (const ie in c) Zg(c[ie], r, n, ie); if (u) { const ie = ce(u) ? u.call(n) : u; Reflect.ownKeys(ie).forEach(oe => { Bs(oe, ie[oe]) }) } d && oh(d, t, "c"); function pe(ie, oe) { te(oe) ? oe.forEach(Re => ie(Re.bind(n))) : oe && ie(oe.bind(n)) } if (pe(KC, h), pe(Mu, m), pe(WC, g), pe(zC, y), pe(HC, _), pe(UC, A), pe(ZC, he), pe(XC, Y), pe(YC, Z), pe(qC, T), pe(Fu, P), pe(GC, re), te(z)) if (z.length) { const ie = t.exposed || (t.exposed = {}); z.forEach(oe => { Object.defineProperty(ie, oe, { get: () => n[oe], set: Re => n[oe] = Re }) }) } else t.exposed || (t.exposed = {}); W && t.render === Gt && (t.render = W), ye != null && (t.inheritAttrs = ye), De && (t.components = De), fe && (t.directives = fe) } function r2(t, e, n = Gt) { te(t) && (t = bl(t)); for (const r in t) { const o = t[r]; let i; ke(o) ? "default" in o ? i = Sn(o.from || r, o.default, !0) : i = Sn(o.from || r) : i = Sn(o), ft(i) ? Object.defineProperty(e, r, { enumerable: !0, configurable: !0, get: () => i.value, set: s => i.value = s }) : e[r] = i } } function oh(t, e, n) { Yt(te(t) ? t.map(r => r.bind(e.proxy)) : t.bind(e.proxy), e, n) } function Zg(t, e, n, r) { const o = r.includes(".") ? Kg(n, r) : () => n[r]; if (Ge(t)) { const i = e[t]; ce(i) && Ds(o, i) } else if (ce(t)) Ds(o, t.bind(n)); else if (ke(t)) if (te(t)) t.forEach(i => Zg(i, e, n, r)); else { const i = ce(t.handler) ? t.handler.bind(n) : e[t.handler]; ce(i) && Ds(o, i, t) } } function ju(t) { const e = t.type, { mixins: n, extends: r } = e, { mixins: o, optionsCache: i, config: { optionMergeStrategies: s } } = t.appContext, c = i.get(e); let u; return c ? u = c : !o.length && !n && !r ? u = e : (u = {}, o.length && o.forEach(a => ra(u, a, s, !0)), ra(u, e, s)), ke(e) && i.set(e, u), u } function ra(t, e, n, r = !1) { const { mixins: o, extends: i } = e; i && ra(t, i, n, !0), o && o.forEach(s => ra(t, s, n, !0)); for (const s in e) if (!(r && s === "expose")) { const c = o2[s] || n && n[s]; t[s] = c ? c(t[s], e[s]) : e[s] } return t } const o2 = { data: ih, props: sh, emits: sh, methods: gi, computed: gi, beforeCreate: pt, created: pt, beforeMount: pt, mounted: pt, beforeUpdate: pt, updated: pt, beforeDestroy: pt, beforeUnmount: pt, destroyed: pt, unmounted: pt, activated: pt, deactivated: pt, errorCaptured: pt, serverPrefetch: pt, components: gi, directives: gi, watch: s2, provide: ih, inject: i2 }; function ih(t, e) { return e ? t ? function() { return tt(ce(t) ? t.call(this, this) : t, ce(e) ? e.call(this, this) : e) } : e : t } function i2(t, e) { return gi(bl(t), bl(e)) } function bl(t) { if (te(t)) { const e = {}; for (let n = 0; n < t.length; n++)e[t[n]] = t[n]; return e } return t } function pt(t, e) { return t ? [...new Set([].concat(t, e))] : e } function gi(t, e) { return t ? tt(Object.create(null), t, e) : e } function sh(t, e) { return t ? te(t) && te(e) ? [...new Set([...t, ...e])] : tt(Object.create(null), rh(t), rh(e ?? {})) : e } function s2(t, e) { if (!t) return e; if (!e) return t; const n = tt(Object.create(null), t); for (const r in e) n[r] = pt(t[r], e[r]); return n } function Jg() { return { app: null, config: { isNativeTag: IS, performance: !1, globalProperties: {}, optionMergeStrategies: {}, errorHandler: void 0, warnHandler: void 0, compilerOptions: {} }, mixins: [], components: {}, directives: {}, provides: Object.create(null), optionsCache: new WeakMap, propsCache: new WeakMap, emitsCache: new WeakMap } } let a2 = 0; function c2(t, e) { return function(r, o = null) { ce(r) || (r = tt({}, r)), o != null && !ke(o) && (o = null); const i = Jg(), s = new Set; let c = !1; const u = i.app = { _uid: a2++, _component: r, _props: o, _container: null, _context: i, _instance: null, version: L2, get config() { return i.config }, set config(a) { }, use(a, ...d) { return s.has(a) || (a && ce(a.install) ? (s.add(a), a.install(u, ...d)) : ce(a) && (s.add(a), a(u, ...d))), u }, mixin(a) { return i.mixins.includes(a) || i.mixins.push(a), u }, component(a, d) { return d ? (i.components[a] = d, u) : i.components[a] }, directive(a, d) { return d ? (i.directives[a] = d, u) : i.directives[a] }, mount(a, d, h) { if (!c) { const m = Ve(r, o); return m.appContext = i, d && e ? e(m, a) : t(m, a, h), c = !0, u._container = a, a.__vue_app__ = u, Ua(m.component) || m.component.proxy } }, unmount() { c && (t(null, u._container), delete u._container.__vue_app__) }, provide(a, d) { return i.provides[a] = d, u }, runWithContext(a) { oa = u; try { return a() } finally { oa = null } } }; return u } } let oa = null; function Bs(t, e) { if (Je) { let n = Je.provides; const r = Je.parent && Je.parent.provides; r === n && (n = Je.provides = Object.create(r)), n[t] = e } } function Sn(t, e, n = !1) { const r = Je || st; if (r || oa) { const o = r ? r.parent == null ? r.vnode.appContext && r.vnode.appContext.provides : r.parent.provides : oa._context.provides; if (o && t in o) return o[t]; if (arguments.length > 1) return n && ce(e) ? e.call(r && r.proxy) : e } } function l2(t, e, n, r = !1) { const o = {}, i = {}; Qs(i, Ha, 1), t.propsDefaults = Object.create(null), Qg(t, e, o, i); for (const s in t.propsOptions[0]) s in o || (o[s] = void 0); n ? t.props = r ? o : vC(o) : t.type.props ? t.props = o : t.props = i, t.attrs = i } function u2(t, e, n, r) { const { props: o, attrs: i, vnode: { patchFlag: s } } = t, c = Ae(o), [u] = t.propsOptions; let a = !1; if ((r || s > 0) && !(s & 16)) { if (s & 8) { const d = t.vnode.dynamicProps; for (let h = 0; h < d.length; h++) { let m = d[h]; if (Ba(t.emitsOptions, m)) continue; const g = e[m]; if (u) if (be(i, m)) g !== i[m] && (i[m] = g, a = !0); else { const y = dn(m); o[y] = vl(u, c, y, g, t, !1) } else g !== i[m] && (i[m] = g, a = !0) } } } else { Qg(t, e, o, i) && (a = !0); let d; for (const h in c) (!e || !be(e, h) && ((d = Uo(h)) === h || !be(e, d))) && (u ? n && (n[h] !== void 0 || n[d] !== void 0) && (o[h] = vl(u, c, h, void 0, t, !0)) : delete o[h]); if (i !== c) for (const h in i) (!e || !be(e, h)) && (delete i[h], a = !0) } a && Rn(t, "set", "$attrs") } function Qg(t, e, n, r) { const [o, i] = t.propsOptions; let s = !1, c; if (e) for (let u in e) { if (Ns(u)) continue; const a = e[u]; let d; o && be(o, d = dn(u)) ? !i || !i.includes(d) ? n[d] = a : (c || (c = {}))[d] = a : Ba(t.emitsOptions, u) || (!(u in r) || a !== r[u]) && (r[u] = a, s = !0) } if (i) { const u = Ae(n), a = c || Ie; for (let d = 0; d < i.length; d++) { const h = i[d]; n[h] = vl(o, u, h, a[h], t, !be(a, h)) } } return s } function vl(t, e, n, r, o, i) { const s = t[n]; if (s != null) { const c = be(s, "default"); if (c && r === void 0) { const u = s.default; if (s.type !== Function && !s.skipFactory && ce(u)) { const { propsDefaults: a } = o; n in a ? r = a[n] : (ko(o), r = a[n] = u.call(null, e), kr()) } else r = u } s[0] && (i && !c ? r = !1 : s[1] && (r === "" || r === Uo(n)) && (r = !0)) } return r } function ey(t, e, n = !1) { const r = e.propsCache, o = r.get(t); if (o) return o; const i = t.props, s = {}, c = []; let u = !1; if (!ce(t)) { const d = h => { u = !0; const [m, g] = ey(h, e, !0); tt(s, m), g && c.push(...g) }; !n && e.mixins.length && e.mixins.forEach(d), t.extends && d(t.extends), t.mixins && t.mixins.forEach(d) } if (!i && !u) return ke(t) && r.set(t, po), po; if (te(i)) for (let d = 0; d < i.length; d++) { const h = dn(i[d]); ah(h) && (s[h] = Ie) } else if (i) for (const d in i) { const h = dn(d); if (ah(h)) { const m = i[d], g = s[h] = te(m) || ce(m) ? { type: m } : tt({}, m); if (g) { const y = uh(Boolean, g.type), _ = uh(String, g.type); g[0] = y > -1, g[1] = _ < 0 || y < _, (y > -1 || be(g, "default")) && c.push(h) } } } const a = [s, c]; return ke(t) && r.set(t, a), a } function ah(t) { return t[0] !== "$" } function ch(t) { const e = t && t.toString().match(/^\s*(function|class) (\w+)/); return e ? e[2] : t === null ? "null" : "" } function lh(t, e) { return ch(t) === ch(e) } function uh(t, e) { return te(e) ? e.findIndex(n => lh(n, t)) : ce(e) && lh(e, t) ? 0 : -1 } const ty = t => t[0] === "_" || t === "$stable", Hu = t => te(t) ? t.map(nn) : [nn(t)], f2 = (t, e, n) => { if (e._n) return e; const r = gl((...o) => Hu(e(...o)), n); return r._c = !1, r }, ny = (t, e, n) => { const r = t._ctx; for (const o in t) { if (ty(o)) continue; const i = t[o]; if (ce(i)) e[o] = f2(o, i, r); else if (i != null) { const s = Hu(i); e[o] = () => s } } }, ry = (t, e) => { const n = Hu(e); t.slots.default = () => n }, d2 = (t, e) => { if (t.vnode.shapeFlag & 32) { const n = e._; n ? (t.slots = Ae(e), Qs(e, "_", n)) : ny(e, t.slots = {}) } else t.slots = {}, e && ry(t, e); Qs(t.slots, Ha, 1) }, h2 = (t, e, n) => { const { vnode: r, slots: o } = t; let i = !0, s = Ie; if (r.shapeFlag & 32) { const c = e._; c ? n && c === 1 ? i = !1 : (tt(o, e), !n && c === 1 && delete o._) : (i = !e.$stable, ny(e, o)), s = e } else e && (ry(t, e), s = { default: 1 }); if (i) for (const c in o) !ty(c) && !(c in s) && delete o[c] }; function _l(t, e, n, r, o = !1) { if (te(t)) { t.forEach((m, g) => _l(m, e && (te(e) ? e[g] : e), n, r, o)); return } if (_i(r) && !o) return; const i = r.shapeFlag & 4 ? Ua(r.component) || r.component.proxy : r.el, s = o ? null : i, { i: c, r: u } = t, a = e && e.r, d = c.refs === Ie ? c.refs = {} : c.refs, h = c.setupState; if (a != null && a !== u && (Ge(a) ? (d[a] = null, be(h, a) && (h[a] = null)) : ft(a) && (a.value = null)), ce(u)) Zn(u, c, 12, [s, d]); else { const m = Ge(u), g = ft(u); if (m || g) { const y = () => { if (t.f) { const _ = m ? be(h, u) ? h[u] : d[u] : u.value; o ? te(_) && Su(_, i) : te(_) ? _.includes(i) || _.push(i) : m ? (d[u] = [i], be(h, u) && (h[u] = d[u])) : (u.value = [i], t.k && (d[t.k] = u.value)) } else m ? (d[u] = s, be(h, u) && (h[u] = s)) : g && (u.value = s, t.k && (d[t.k] = s)) }; s ? (y.id = -1, Tt(y, n)) : y() } } } const Tt = $C; function p2(t) { return m2(t) } function m2(t, e) { const n = ul(); n.__VUE__ = !0; const { insert: r, remove: o, patchProp: i, createElement: s, createText: c, createComment: u, setText: a, setElementText: d, parentNode: h, nextSibling: m, setScopeId: g = Gt, insertStaticContent: y } = t, _ = (w, v, S, C = null, N = null, D = null, V = !1, k = null, $ = !!v.dynamicChildren) => { if (w === v) return; w && !si(w, v) && (C = R(w), Ce(w, N, D, !0), w = null), v.patchFlag === -2 && ($ = !1, v.dynamicChildren = null); const { type: L, ref: G, shapeFlag: H } = v; switch (L) { case ja: A(w, v, S, C); break; case ir: E(w, v, S, C); break; case $s: w == null && T(v, S, C, V); break; case mt: De(w, v, S, C, N, D, V, k, $); break; default: H & 1 ? W(w, v, S, C, N, D, V, k, $) : H & 6 ? fe(w, v, S, C, N, D, V, k, $) : (H & 64 || H & 128) && L.process(w, v, S, C, N, D, V, k, $, j) }G != null && N && _l(G, w && w.ref, D, v || w, !v) }, A = (w, v, S, C) => { if (w == null) r(v.el = c(v.children), S, C); else { const N = v.el = w.el; v.children !== w.children && a(N, v.children) } }, E = (w, v, S, C) => { w == null ? r(v.el = u(v.children || ""), S, C) : v.el = w.el }, T = (w, v, S, C) => { [w.el, w.anchor] = y(w.children, v, S, C, w.el, w.anchor) }, x = ({ el: w, anchor: v }, S, C) => { let N; for (; w && w !== v;)N = m(w), r(w, S, C), w = N; r(v, S, C) }, P = ({ el: w, anchor: v }) => { let S; for (; w && w !== v;)S = m(w), o(w), w = S; o(v) }, W = (w, v, S, C, N, D, V, k, $) => { V = V || v.type === "svg", w == null ? Y(v, S, C, N, D, V, k, $) : re(w, v, N, D, V, k, $) }, Y = (w, v, S, C, N, D, V, k) => { let $, L; const { type: G, props: H, shapeFlag: K, transition: ee, dirs: se } = w; if ($ = w.el = s(w.type, D, H && H.is, H), K & 8 ? d($, w.children) : K & 16 && he(w.children, $, null, C, N, D && G !== "foreignObject", V, k), se && dr(w, null, C, "created"), Z($, w, w.scopeId, V, C), H) { for (const we in H) we !== "value" && !Ns(we) && i($, we, null, H[we], D, w.children, C, N, Oe); "value" in H && i($, "value", null, H.value), (L = H.onVnodeBeforeMount) && en(L, C, w) } se && dr(w, null, C, "beforeMount"); const ae = (!N || N && !N.pendingBranch) && ee && !ee.persisted; ae && ee.beforeEnter($), r($, v, S), ((L = H && H.onVnodeMounted) || ae || se) && Tt(() => { L && en(L, C, w), ae && ee.enter($), se && dr(w, null, C, "mounted") }, N) }, Z = (w, v, S, C, N) => { if (S && g(w, S), C) for (let D = 0; D < C.length; D++)g(w, C[D]); if (N) { let D = N.subTree; if (v === D) { const V = N.vnode; Z(w, V, V.scopeId, V.slotScopeIds, N.parent) } } }, he = (w, v, S, C, N, D, V, k, $ = 0) => { for (let L = $; L < w.length; L++) { const G = w[L] = k ? zn(w[L]) : nn(w[L]); _(null, G, v, S, C, N, D, V, k) } }, re = (w, v, S, C, N, D, V) => { const k = v.el = w.el; let { patchFlag: $, dynamicChildren: L, dirs: G } = v; $ |= w.patchFlag & 16; const H = w.props || Ie, K = v.props || Ie; let ee; S && hr(S, !1), (ee = K.onVnodeBeforeUpdate) && en(ee, S, v, w), G && dr(v, w, S, "beforeUpdate"), S && hr(S, !0); const se = N && v.type !== "foreignObject"; if (L ? z(w.dynamicChildren, L, k, S, C, se, D) : V || oe(w, v, k, null, S, C, se, D, !1), $ > 0) { if ($ & 16) ye(k, v, H, K, S, C, N); else if ($ & 2 && H.class !== K.class && i(k, "class", null, K.class, N), $ & 4 && i(k, "style", H.style, K.style, N), $ & 8) { const ae = v.dynamicProps; for (let we = 0; we < ae.length; we++) { const Be = ae[we], vt = H[Be], Qt = K[Be]; (Qt !== vt || Be === "value") && i(k, Be, vt, Qt, N, w.children, S, C, Oe) } } $ & 1 && w.children !== v.children && d(k, v.children) } else !V && L == null && ye(k, v, H, K, S, C, N); ((ee = K.onVnodeUpdated) || G) && Tt(() => { ee && en(ee, S, v, w), G && dr(v, w, S, "updated") }, C) }, z = (w, v, S, C, N, D, V) => { for (let k = 0; k < v.length; k++) { const $ = w[k], L = v[k], G = $.el && ($.type === mt || !si($, L) || $.shapeFlag & 70) ? h($.el) : S; _($, L, G, null, C, N, D, V, !0) } }, ye = (w, v, S, C, N, D, V) => { if (S !== C) { if (S !== Ie) for (const k in S) !Ns(k) && !(k in C) && i(w, k, S[k], null, V, v.children, N, D, Oe); for (const k in C) { if (Ns(k)) continue; const $ = C[k], L = S[k]; $ !== L && k !== "value" && i(w, k, L, $, V, v.children, N, D, Oe) } "value" in C && i(w, "value", S.value, C.value) } }, De = (w, v, S, C, N, D, V, k, $) => { const L = v.el = w ? w.el : c(""), G = v.anchor = w ? w.anchor : c(""); let { patchFlag: H, dynamicChildren: K, slotScopeIds: ee } = v; ee && (k = k ? k.concat(ee) : ee), w == null ? (r(L, S, C), r(G, S, C), he(v.children, S, G, N, D, V, k, $)) : H > 0 && H & 64 && K && w.dynamicChildren ? (z(w.dynamicChildren, K, S, N, D, V, k), (v.key != null || N && v === N.subTree) && oy(w, v, !0)) : oe(w, v, S, G, N, D, V, k, $) }, fe = (w, v, S, C, N, D, V, k, $) => { v.slotScopeIds = k, w == null ? v.shapeFlag & 512 ? N.ctx.activate(v, S, C, V, $) : He(v, S, C, N, D, V, $) : nt(w, v, $) }, He = (w, v, S, C, N, D, V) => { const k = w.component = T2(w, C, N); if (zg(w) && (k.ctx.renderer = j), C2(k), k.asyncDep) { if (N && N.registerDep(k, pe), !w.el) { const $ = k.subTree = Ve(ir); E(null, $, v, S) } return } pe(k, w, v, S, N, D, V) }, nt = (w, v, S) => { const C = v.component = w.component; if (LC(w, v, S)) if (C.asyncDep && !C.asyncResolved) { ie(C, v, S); return } else C.next = v, xC(C.update), C.update(); else v.el = w.el, C.vnode = v }, pe = (w, v, S, C, N, D, V) => { const k = () => { if (w.isMounted) { let { next: G, bu: H, u: K, parent: ee, vnode: se } = w, ae = G, we; hr(w, !1), G ? (G.el = se.el, ie(w, G, V)) : G = se, H && Ls(H), (we = G.props && G.props.onVnodeBeforeUpdate) && en(we, ee, G, se), hr(w, !0); const Be = Oc(w), vt = w.subTree; w.subTree = Be, _(vt, Be, h(vt.el), R(vt), w, N, D), G.el = Be.el, ae === null && DC(w, Be.el), K && Tt(K, N), (we = G.props && G.props.onVnodeUpdated) && Tt(() => en(we, ee, G, se), N) } else { let G; const { el: H, props: K } = v, { bm: ee, m: se, parent: ae } = w, we = _i(v); if (hr(w, !1), ee && Ls(ee), !we && (G = K && K.onVnodeBeforeMount) && en(G, ae, v), hr(w, !0), H && me) { const Be = () => { w.subTree = Oc(w), me(H, w.subTree, w, N, null) }; we ? v.type.__asyncLoader().then(() => !w.isUnmounted && Be()) : Be() } else { const Be = w.subTree = Oc(w); _(null, Be, S, C, w, N, D), v.el = Be.el } if (se && Tt(se, N), !we && (G = K && K.onVnodeMounted)) { const Be = v; Tt(() => en(G, ae, Be), N) } (v.shapeFlag & 256 || ae && _i(ae.vnode) && ae.vnode.shapeFlag & 256) && w.a && Tt(w.a, N), w.isMounted = !0, v = S = C = null } }, $ = w.effect = new Ru(k, () => $u(L), w.scope), L = w.update = () => $.run(); L.id = w.uid, hr(w, !0), L() }, ie = (w, v, S) => { v.component = w; const C = w.vnode.props; w.vnode = v, w.next = null, u2(w, v.props, C, S), h2(w, v.children, S), Vo(), eh(), Ko() }, oe = (w, v, S, C, N, D, V, k, $ = !1) => { const L = w && w.children, G = w ? w.shapeFlag : 0, H = v.children, { patchFlag: K, shapeFlag: ee } = v; if (K > 0) { if (K & 128) { $e(L, H, S, C, N, D, V, k, $); return } else if (K & 256) { Re(L, H, S, C, N, D, V, k, $); return } } ee & 8 ? (G & 16 && Oe(L, N, D), H !== L && d(S, H)) : G & 16 ? ee & 16 ? $e(L, H, S, C, N, D, V, k, $) : Oe(L, N, D, !0) : (G & 8 && d(S, ""), ee & 16 && he(H, S, C, N, D, V, k, $)) }, Re = (w, v, S, C, N, D, V, k, $) => { w = w || po, v = v || po; const L = w.length, G = v.length, H = Math.min(L, G); let K; for (K = 0; K < H; K++) { const ee = v[K] = $ ? zn(v[K]) : nn(v[K]); _(w[K], ee, S, null, N, D, V, k, $) } L > G ? Oe(w, N, D, !0, !1, H) : he(v, S, C, N, D, V, k, $, H) }, $e = (w, v, S, C, N, D, V, k, $) => { let L = 0; const G = v.length; let H = w.length - 1, K = G - 1; for (; L <= H && L <= K;) { const ee = w[L], se = v[L] = $ ? zn(v[L]) : nn(v[L]); if (si(ee, se)) _(ee, se, S, null, N, D, V, k, $); else break; L++ } for (; L <= H && L <= K;) { const ee = w[H], se = v[K] = $ ? zn(v[K]) : nn(v[K]); if (si(ee, se)) _(ee, se, S, null, N, D, V, k, $); else break; H--, K-- } if (L > H) { if (L <= K) { const ee = K + 1, se = ee < G ? v[ee].el : C; for (; L <= K;)_(null, v[L] = $ ? zn(v[L]) : nn(v[L]), S, se, N, D, V, k, $), L++ } } else if (L > K) for (; L <= H;)Ce(w[L], N, D, !0), L++; else { const ee = L, se = L, ae = new Map; for (L = se; L <= K; L++) { const ht = v[L] = $ ? zn(v[L]) : nn(v[L]); ht.key != null && ae.set(ht.key, L) } let we, Be = 0; const vt = K - se + 1; let Qt = !1, es = 0; const Bn = new Array(vt); for (L = 0; L < vt; L++)Bn[L] = 0; for (L = ee; L <= H; L++) { const ht = w[L]; if (Be >= vt) { Ce(ht, N, D, !0); continue } let Ze; if (ht.key != null) Ze = ae.get(ht.key); else for (we = se; we <= K; we++)if (Bn[we - se] === 0 && si(ht, v[we])) { Ze = we; break } Ze === void 0 ? Ce(ht, N, D, !0) : (Bn[Ze - se] = L + 1, Ze >= es ? es = Ze : Qt = !0, _(ht, v[Ze], S, null, N, D, V, k, $), Be++) } const ts = Qt ? g2(Bn) : po; for (we = ts.length - 1, L = vt - 1; L >= 0; L--) { const ht = se + L, Ze = v[ht], ns = ht + 1 < G ? v[ht + 1].el : C; Bn[L] === 0 ? _(null, Ze, S, ns, N, D, V, k, $) : Qt && (we < 0 || L !== ts[we] ? at(Ze, S, ns, 2) : we--) } } }, at = (w, v, S, C, N = null) => { const { el: D, type: V, transition: k, children: $, shapeFlag: L } = w; if (L & 6) { at(w.component.subTree, v, S, C); return } if (L & 128) { w.suspense.move(v, S, C); return } if (L & 64) { V.move(w, v, S, j); return } if (V === mt) { r(D, v, S); for (let H = 0; H < $.length; H++)at($[H], v, S, C); r(w.anchor, v, S); return } if (V === $s) { x(w, v, S); return } if (C !== 2 && L & 1 && k) if (C === 0) k.beforeEnter(D), r(D, v, S), Tt(() => k.enter(D), N); else { const { leave: H, delayLeave: K, afterLeave: ee } = k, se = () => r(D, v, S), ae = () => { H(D, () => { se(), ee && ee() }) }; K ? K(D, se, ae) : ae() } else r(D, v, S) }, Ce = (w, v, S, C = !1, N = !1) => { const { type: D, props: V, ref: k, children: $, dynamicChildren: L, shapeFlag: G, patchFlag: H, dirs: K } = w; if (k != null && _l(k, null, S, w, !0), G & 256) { v.ctx.deactivate(w); return } const ee = G & 1 && K, se = !_i(w); let ae; if (se && (ae = V && V.onVnodeBeforeUnmount) && en(ae, v, w), G & 6) Xe(w.component, S, C); else { if (G & 128) { w.suspense.unmount(S, C); return } ee && dr(w, null, v, "beforeUnmount"), G & 64 ? w.type.remove(w, v, S, N, j, C) : L && (D !== mt || H > 0 && H & 64) ? Oe(L, v, S, !1, !0) : (D === mt && H & 384 || !N && G & 16) && Oe($, v, S), C && rt(w) } (se && (ae = V && V.onVnodeUnmounted) || ee) && Tt(() => { ae && en(ae, v, w), ee && dr(w, null, v, "unmounted") }, S) }, rt = w => { const { type: v, el: S, anchor: C, transition: N } = w; if (v === mt) { ct(S, C); return } if (v === $s) { P(w); return } const D = () => { o(S), N && !N.persisted && N.afterLeave && N.afterLeave() }; if (w.shapeFlag & 1 && N && !N.persisted) { const { leave: V, delayLeave: k } = N, $ = () => V(S, D); k ? k(w.el, D, $) : $() } else D() }, ct = (w, v) => { let S; for (; w !== v;)S = m(w), o(w), w = S; o(v) }, Xe = (w, v, S) => { const { bum: C, scope: N, update: D, subTree: V, um: k } = w; C && Ls(C), N.stop(), D && (D.active = !1, Ce(V, w, v, S)), k && Tt(k, v), Tt(() => { w.isUnmounted = !0 }, v), v && v.pendingBranch && !v.isUnmounted && w.asyncDep && !w.asyncResolved && w.suspenseId === v.pendingId && (v.deps--, v.deps === 0 && v.resolve()) }, Oe = (w, v, S, C = !1, N = !1, D = 0) => { for (let V = D; V < w.length; V++)Ce(w[V], v, S, C, N) }, R = w => w.shapeFlag & 6 ? R(w.component.subTree) : w.shapeFlag & 128 ? w.suspense.next() : m(w.anchor || w.el), U = (w, v, S) => { w == null ? v._vnode && Ce(v._vnode, null, null, !0) : _(v._vnode || null, w, v, null, null, null, S), eh(), Fg(), v._vnode = w }, j = { p: _, um: Ce, m: at, r: rt, mt: He, mc: he, pc: oe, pbc: z, n: R, o: t }; let X, me; return e && ([X, me] = e(j)), { render: U, hydrate: X, createApp: c2(U, X) } } function hr({ effect: t, update: e }, n) { t.allowRecurse = e.allowRecurse = n } function oy(t, e, n = !1) { const r = t.children, o = e.children; if (te(r) && te(o)) for (let i = 0; i < r.length; i++) { const s = r[i]; let c = o[i]; c.shapeFlag & 1 && !c.dynamicChildren && ((c.patchFlag <= 0 || c.patchFlag === 32) && (c = o[i] = zn(o[i]), c.el = s.el), n || oy(s, c)), c.type === ja && (c.el = s.el) } } function g2(t) { const e = t.slice(), n = [0]; let r, o, i, s, c; const u = t.length; for (r = 0; r < u; r++) { const a = t[r]; if (a !== 0) { if (o = n[n.length - 1], t[o] < a) { e[r] = o, n.push(r); continue } for (i = 0, s = n.length - 1; i < s;)c = i + s >> 1, t[n[c]] < a ? i = c + 1 : s = c; a < t[n[i]] && (i > 0 && (e[r] = n[i - 1]), n[i] = r) } } for (i = n.length, s = n[i - 1]; i-- > 0;)n[i] = s, s = e[s]; return n } const y2 = t => t.__isTeleport, mt = Symbol.for("v-fgt"), ja = Symbol.for("v-txt"), ir = Symbol.for("v-cmt"), $s = Symbol.for("v-stc"), Ai = []; let zt = null; function Le(t = !1) { Ai.push(zt = t ? null : []) } function w2() { Ai.pop(), zt = Ai[Ai.length - 1] || null } let Ni = 1; function fh(t) { Ni += t } function iy(t) { return t.dynamicChildren = Ni > 0 ? zt || po : null, w2(), Ni > 0 && zt && zt.push(t), t } function Fe(t, e, n, r, o, i) { return iy(M(t, e, n, r, o, i, !0)) } function sy(t, e, n, r, o) { return iy(Ve(t, e, n, r, o, !0)) } function ia(t) { return t ? t.__v_isVNode === !0 : !1 } function si(t, e) { return t.type === e.type && t.key === e.key } const Ha = "__vInternal", ay = ({ key: t }) => t ?? null, Ms = ({ ref: t, ref_key: e, ref_for: n }) => (typeof t == "number" && (t = "" + t), t != null ? Ge(t) || ft(t) || ce(t) ? { i: st, r: t, k: e, f: !!n } : t : null); function M(t, e = null, n = null, r = 0, o = null, i = t === mt ? 0 : 1, s = !1, c = !1) { const u = { __v_isVNode: !0, __v_skip: !0, type: t, props: e, key: e && ay(e), ref: e && Ms(e), scopeId: $a, slotScopeIds: null, children: n, component: null, suspense: null, ssContent: null, ssFallback: null, dirs: null, transition: null, el: null, anchor: null, target: null, targetAnchor: null, staticCount: 0, shapeFlag: i, patchFlag: r, dynamicProps: o, dynamicChildren: null, appContext: null, ctx: st }; return c ? (Uu(u, n), i & 128 && t.normalize(u)) : n && (u.shapeFlag |= Ge(n) ? 8 : 16), Ni > 0 && !s && zt && (u.patchFlag > 0 || i & 6) && u.patchFlag !== 32 && zt.push(u), u } const Ve = b2; function b2(t, e = null, n = null, r = 0, o = null, i = !1) { if ((!t || t === JC) && (t = ir), ia(t)) { const c = xo(t, e, !0); return n && Uu(c, n), Ni > 0 && !i && zt && (c.shapeFlag & 6 ? zt[zt.indexOf(t)] = c : zt.push(c)), c.patchFlag |= -2, c } if (I2(t) && (t = t.__vccOpts), e) { e = v2(e); let { class: c, style: u } = e; c && !Ge(c) && (e.class = xu(c)), ke(u) && (Rg(u) && !te(u) && (u = tt({}, u)), e.style = Ou(u)) } const s = Ge(t) ? 1 : BC(t) ? 128 : y2(t) ? 64 : ke(t) ? 4 : ce(t) ? 2 : 0; return M(t, e, n, r, o, s, i, !0) } function v2(t) { return t ? Rg(t) || Ha in t ? tt({}, t) : t : null } function xo(t, e, n = !1) { const { props: r, ref: o, patchFlag: i, children: s } = t, c = e ? _2(r || {}, e) : r; return { __v_isVNode: !0, __v_skip: !0, type: t.type, props: c, key: c && ay(c), ref: e && e.ref ? n && o ? te(o) ? o.concat(Ms(e)) : [o, Ms(e)] : Ms(e) : o, scopeId: t.scopeId, slotScopeIds: t.slotScopeIds, children: s, target: t.target, targetAnchor: t.targetAnchor, staticCount: t.staticCount, shapeFlag: t.shapeFlag, patchFlag: e && t.type !== mt ? i === -1 ? 16 : i | 16 : i, dynamicProps: t.dynamicProps, dynamicChildren: t.dynamicChildren, appContext: t.appContext, dirs: t.dirs, transition: t.transition, component: t.component, suspense: t.suspense, ssContent: t.ssContent && xo(t.ssContent), ssFallback: t.ssFallback && xo(t.ssFallback), el: t.el, anchor: t.anchor, ctx: t.ctx, ce: t.ce } } function sa(t = " ", e = 0) { return Ve(ja, null, t, e) } function so(t = "", e = !1) { return e ? (Le(), sy(ir, null, t)) : Ve(ir, null, t) } function nn(t) { return t == null || typeof t == "boolean" ? Ve(ir) : te(t) ? Ve(mt, null, t.slice()) : typeof t == "object" ? zn(t) : Ve(ja, null, String(t)) } function zn(t) { return t.el === null && t.patchFlag !== -1 || t.memo ? t : xo(t) } function Uu(t, e) { let n = 0; const { shapeFlag: r } = t; if (e == null) e = null; else if (te(e)) n = 16; else if (typeof e == "object") if (r & 65) { const o = e.default; o && (o._c && (o._d = !1), Uu(t, o()), o._c && (o._d = !0)); return } else { n = 32; const o = e._; !o && !(Ha in e) ? e._ctx = st : o === 3 && st && (st.slots._ === 1 ? e._ = 1 : (e._ = 2, t.patchFlag |= 1024)) } else ce(e) ? (e = { default: e, _ctx: st }, n = 32) : (e = String(e), r & 64 ? (n = 16, e = [sa(e)]) : n = 8); t.children = e, t.shapeFlag |= n } function _2(...t) { const e = {}; for (let n = 0; n < t.length; n++) { const r = t[n]; for (const o in r) if (o === "class") e.class !== r.class && (e.class = xu([e.class, r.class])); else if (o === "style") e.style = Ou([e.style, r.style]); else if (xa(o)) { const i = e[o], s = r[o]; s && i !== s && !(te(i) && i.includes(s)) && (e[o] = i ? [].concat(i, s) : s) } else o !== "" && (e[o] = r[o]) } return e } function en(t, e, n, r = null) { Yt(t, e, 7, [n, r]) } const E2 = Jg(); let A2 = 0; function T2(t, e, n) { const r = t.type, o = (e ? e.appContext : t.appContext) || E2, i = { uid: A2++, vnode: t, type: r, parent: e, appContext: o, root: null, next: null, subTree: null, effect: null, update: null, scope: new WS(!0), render: null, proxy: null, exposed: null, exposeProxy: null, withProxy: null, provides: e ? e.provides : Object.create(o.provides), accessCache: null, renderCache: [], components: null, directives: null, propsOptions: ey(r, o), emitsOptions: Hg(r, o), emit: null, emitted: null, propsDefaults: Ie, inheritAttrs: r.inheritAttrs, ctx: Ie, data: Ie, props: Ie, attrs: Ie, slots: Ie, refs: Ie, setupState: Ie, setupContext: null, attrsProxy: null, slotsProxy: null, suspense: n, suspenseId: n ? n.pendingId : 0, asyncDep: null, asyncResolved: !1, isMounted: !1, isUnmounted: !1, isDeactivated: !1, bc: null, c: null, bm: null, m: null, bu: null, u: null, um: null, bum: null, da: null, a: null, rtg: null, rtc: null, ec: null, sp: null }; return i.ctx = { _: i }, i.root = e ? e.root : i, i.emit = IC.bind(null, i), t.ce && t.ce(i), i } let Je = null; const S2 = () => Je || st; let Vu, Jr, dh = "__VUE_INSTANCE_SETTERS__"; (Jr = ul()[dh]) || (Jr = ul()[dh] = []), Jr.push(t => Je = t), Vu = t => { Jr.length > 1 ? Jr.forEach(e => e(t)) : Jr[0](t) }; const ko = t => { Vu(t), t.scope.on() }, kr = () => { Je && Je.scope.off(), Vu(null) }; function cy(t) { return t.vnode.shapeFlag & 4 } let Li = !1; function C2(t, e = !1) { Li = e; const { props: n, children: r } = t.vnode, o = cy(t); l2(t, n, o, e), d2(t, r); const i = o ? O2(t, e) : void 0; return Li = !1, i } function O2(t, e) { const n = t.type; t.accessCache = Object.create(null), t.proxy = Ig(new Proxy(t.ctx, t2)); const { setup: r } = n; if (r) { const o = t.setupContext = r.length > 1 ? k2(t) : null; ko(t), Vo(); const i = Zn(r, t, 0, [t.props, o]); if (Ko(), kr(), pg(i)) { if (i.then(kr, kr), e) return i.then(s => { hh(t, s, e) }).catch(s => { Da(s, t, 0) }); t.asyncDep = i } else hh(t, i, e) } else ly(t, e) } function hh(t, e, n) { ce(e) ? t.type.__ssrInlineRender ? t.ssrRender = e : t.render = e : ke(e) && (t.setupState = Dg(e)), ly(t, n) } let ph; function ly(t, e, n) { const r = t.type; if (!t.render) { if (!e && ph && !r.render) { const o = r.template || ju(t).template; if (o) { const { isCustomElement: i, compilerOptions: s } = t.appContext.config, { delimiters: c, compilerOptions: u } = r, a = tt(tt({ isCustomElement: i, delimiters: c }, s), u); r.render = ph(o, a) } } t.render = r.render || Gt } ko(t), Vo(), n2(t), Ko(), kr() } function x2(t) { return t.attrsProxy || (t.attrsProxy = new Proxy(t.attrs, { get(e, n) { return xt(t, "get", "$attrs"), e[n] } })) } function k2(t) { const e = n => { t.exposed = n || {} }; return { get attrs() { return x2(t) }, slots: t.slots, emit: t.emit, expose: e } } function Ua(t) { if (t.exposed) return t.exposeProxy || (t.exposeProxy = new Proxy(Dg(Ig(t.exposed)), { get(e, n) { if (n in e) return e[n]; if (n in Ei) return Ei[n](t) }, has(e, n) { return n in e || n in Ei } })) } function R2(t, e = !0) { return ce(t) ? t.displayName || t.name : t.name || e && t.__name } function I2(t) { return ce(t) && "__vccOpts" in t } const Ke = (t, e) => SC(t, e, Li); function uy(t, e, n) { const r = arguments.length; return r === 2 ? ke(e) && !te(e) ? ia(e) ? Ve(t, null, [e]) : Ve(t, e) : Ve(t, null, e) : (r > 3 ? n = Array.prototype.slice.call(arguments, 2) : r === 3 && ia(n) && (n = [n]), Ve(t, e, n)) } const P2 = Symbol.for("v-scx"), N2 = () => Sn(P2), L2 = "3.3.4", D2 = "http://www.w3.org/2000/svg", wr = typeof document < "u" ? document : null, mh = wr && wr.createElement("template"), B2 = { insert: (t, e, n) => { e.insertBefore(t, n || null) }, remove: t => { const e = t.parentNode; e && e.removeChild(t) }, createElement: (t, e, n, r) => { const o = e ? wr.createElementNS(D2, t) : wr.createElement(t, n ? { is: n } : void 0); return t === "select" && r && r.multiple != null && o.setAttribute("multiple", r.multiple), o }, createText: t => wr.createTextNode(t), createComment: t => wr.createComment(t), setText: (t, e) => { t.nodeValue = e }, setElementText: (t, e) => { t.textContent = e }, parentNode: t => t.parentNode, nextSibling: t => t.nextSibling, querySelector: t => wr.querySelector(t), setScopeId(t, e) { t.setAttribute(e, "") }, insertStaticContent(t, e, n, r, o, i) { const s = n ? n.previousSibling : e.lastChild; if (o && (o === i || o.nextSibling)) for (; e.insertBefore(o.cloneNode(!0), n), !(o === i || !(o = o.nextSibling));); else { mh.innerHTML = r ? `<svg>${t}</svg>` : t; const c = mh.content; if (r) { const u = c.firstChild; for (; u.firstChild;)c.appendChild(u.firstChild); c.removeChild(u) } e.insertBefore(c, n) } return [s ? s.nextSibling : e.firstChild, n ? n.previousSibling : e.lastChild] } }; function $2(t, e, n) { const r = t._vtc; r && (e = (e ? [e, ...r] : [...r]).join(" ")), e == null ? t.removeAttribute("class") : n ? t.setAttribute("class", e) : t.className = e } function M2(t, e, n) { const r = t.style, o = Ge(n); if (n && !o) { if (e && !Ge(e)) for (const i in e) n[i] == null && El(r, i, ""); for (const i in n) El(r, i, n[i]) } else { const i = r.display; o ? e !== n && (r.cssText = n) : e && t.removeAttribute("style"), "_vod" in t && (r.display = i) } } const gh = /\s*!important$/; function El(t, e, n) { if (te(n)) n.forEach(r => El(t, e, r)); else if (n == null && (n = ""), e.startsWith("--")) t.setProperty(e, n); else { const r = F2(t, e); gh.test(n) ? t.setProperty(Uo(r), n.replace(gh, ""), "important") : t[r] = n } } const yh = ["Webkit", "Moz", "ms"], kc = {}; function F2(t, e) { const n = kc[e]; if (n) return n; let r = dn(e); if (r !== "filter" && r in t) return kc[e] = r; r = Ia(r); for (let o = 0; o < yh.length; o++) { const i = yh[o] + r; if (i in t) return kc[e] = i } return e } const wh = "http://www.w3.org/1999/xlink"; function j2(t, e, n, r, o) { if (r && e.startsWith("xlink:")) n == null ? t.removeAttributeNS(wh, e.slice(6, e.length)) : t.setAttributeNS(wh, e, n); else { const i = US(e); n == null || i && !yg(n) ? t.removeAttribute(e) : t.setAttribute(e, i ? "" : n) } } function H2(t, e, n, r, o, i, s) { if (e === "innerHTML" || e === "textContent") { r && s(r, o, i), t[e] = n ?? ""; return } const c = t.tagName; if (e === "value" && c !== "PROGRESS" && !c.includes("-")) { t._value = n; const a = c === "OPTION" ? t.getAttribute("value") : t.value, d = n ?? ""; a !== d && (t.value = d), n == null && t.removeAttribute(e); return } let u = !1; if (n === "" || n == null) { const a = typeof t[e]; a === "boolean" ? n = yg(n) : n == null && a === "string" ? (n = "", u = !0) : a === "number" && (n = 0, u = !0) } try { t[e] = n } catch { } u && t.removeAttribute(e) } function br(t, e, n, r) { t.addEventListener(e, n, r) } function U2(t, e, n, r) { t.removeEventListener(e, n, r) } function V2(t, e, n, r, o = null) { const i = t._vei || (t._vei = {}), s = i[e]; if (r && s) s.value = r; else { const [c, u] = K2(e); if (r) { const a = i[e] = q2(r, o); br(t, c, a, u) } else s && (U2(t, c, s, u), i[e] = void 0) } } const bh = /(?:Once|Passive|Capture)$/; function K2(t) { let e; if (bh.test(t)) { e = {}; let r; for (; r = t.match(bh);)t = t.slice(0, t.length - r[0].length), e[r[0].toLowerCase()] = !0 } return [t[2] === ":" ? t.slice(3) : Uo(t.slice(2)), e] } let Rc = 0; const W2 = Promise.resolve(), z2 = () => Rc || (W2.then(() => Rc = 0), Rc = Date.now()); function q2(t, e) { const n = r => { if (!r._vts) r._vts = Date.now(); else if (r._vts <= n.attached) return; Yt(G2(r, n.value), e, 5, [r]) }; return n.value = t, n.attached = z2(), n } function G2(t, e) { if (te(e)) { const n = t.stopImmediatePropagation; return t.stopImmediatePropagation = () => { n.call(t), t._stopped = !0 }, e.map(r => o => !o._stopped && r && r(o)) } else return e } const vh = /^on[a-z]/, Y2 = (t, e, n, r, o = !1, i, s, c, u) => { e === "class" ? $2(t, r, o) : e === "style" ? M2(t, n, r) : xa(e) ? Tu(e) || V2(t, e, n, r, s) : (e[0] === "." ? (e = e.slice(1), !0) : e[0] === "^" ? (e = e.slice(1), !1) : X2(t, e, r, o)) ? H2(t, e, r, i, s, c, u) : (e === "true-value" ? t._trueValue = r : e === "false-value" && (t._falseValue = r), j2(t, e, r, o)) }; function X2(t, e, n, r) { return r ? !!(e === "innerHTML" || e === "textContent" || e in t && vh.test(e) && ce(n)) : e === "spellcheck" || e === "draggable" || e === "translate" || e === "form" || e === "list" && t.tagName === "INPUT" || e === "type" && t.tagName === "TEXTAREA" || vh.test(e) && Ge(n) ? !1 : e in t } function Z2(t) { const e = S2(); if (!e) return; const n = e.ut = (o = t(e.proxy)) => { Array.from(document.querySelectorAll(`[data-v-owner="${e.uid}"]`)).forEach(i => Tl(i, o)) }, r = () => { const o = t(e.proxy); Al(e.subTree, o), n(o) }; FC(r), Mu(() => { const o = new MutationObserver(r); o.observe(e.subTree.el.parentNode, { childList: !0 }), Fu(() => o.disconnect()) }) } function Al(t, e) { if (t.shapeFlag & 128) { const n = t.suspense; t = n.activeBranch, n.pendingBranch && !n.isHydrating && n.effects.push(() => { Al(n.activeBranch, e) }) } for (; t.component;)t = t.component.subTree; if (t.shapeFlag & 1 && t.el) Tl(t.el, e); else if (t.type === mt) t.children.forEach(n => Al(n, e)); else if (t.type === $s) { let { el: n, anchor: r } = t; for (; n && (Tl(n, e), n !== r);)n = n.nextSibling } } function Tl(t, e) { if (t.nodeType === 1) { const n = t.style; for (const r in e) n.setProperty(`--${r}`, e[r]) } } const aa = t => { const e = t.props["onUpdate:modelValue"] || !1; return te(e) ? n => Ls(e, n) : e }; function J2(t) { t.target.composing = !0 } function _h(t) { const e = t.target; e.composing && (e.composing = !1, e.dispatchEvent(new Event("input"))) } const bo = { created(t, { modifiers: { lazy: e, trim: n, number: r } }, o) { t._assign = aa(o); const i = r || o.props && o.props.type === "number"; br(t, e ? "change" : "input", s => { if (s.target.composing) return; let c = t.value; n && (c = c.trim()), i && (c = ea(c)), t._assign(c) }), n && br(t, "change", () => { t.value = t.value.trim() }), e || (br(t, "compositionstart", J2), br(t, "compositionend", _h), br(t, "change", _h)) }, mounted(t, { value: e }) { t.value = e ?? "" }, beforeUpdate(t, { value: e, modifiers: { lazy: n, trim: r, number: o } }, i) { if (t._assign = aa(i), t.composing || document.activeElement === t && t.type !== "range" && (n || r && t.value.trim() === e || (o || t.type === "number") && ea(t.value) === e)) return; const s = e ?? ""; t.value !== s && (t.value = s) } }, Q2 = { deep: !0, created(t, { value: e, modifiers: { number: n } }, r) { const o = ka(e); br(t, "change", () => { const i = Array.prototype.filter.call(t.options, s => s.selected).map(s => n ? ea(ca(s)) : ca(s)); t._assign(t.multiple ? o ? new Set(i) : i : i[0]) }), t._assign = aa(r) }, mounted(t, { value: e }) { Eh(t, e) }, beforeUpdate(t, e, n) { t._assign = aa(n) }, updated(t, { value: e }) { Eh(t, e) } }; function Eh(t, e) { const n = t.multiple; if (!(n && !te(e) && !ka(e))) { for (let r = 0, o = t.options.length; r < o; r++) { const i = t.options[r], s = ca(i); if (n) te(e) ? i.selected = KS(e, s) > -1 : i.selected = e.has(s); else if (Pa(ca(i), e)) { t.selectedIndex !== r && (t.selectedIndex = r); return } } !n && t.selectedIndex !== -1 && (t.selectedIndex = -1) } } function ca(t) { return "_value" in t ? t._value : t.value } const eO = ["ctrl", "shift", "alt", "meta"], tO = { stop: t => t.stopPropagation(), prevent: t => t.preventDefault(), self: t => t.target !== t.currentTarget, ctrl: t => !t.ctrlKey, shift: t => !t.shiftKey, alt: t => !t.altKey, meta: t => !t.metaKey, left: t => "button" in t && t.button !== 0, middle: t => "button" in t && t.button !== 1, right: t => "button" in t && t.button !== 2, exact: (t, e) => eO.some(n => t[`${n}Key`] && !e.includes(n)) }, Ku = (t, e) => (n, ...r) => { for (let o = 0; o < e.length; o++) { const i = tO[e[o]]; if (i && i(n, e)) return } return t(n, ...r) }, nO = tt({ patchProp: Y2 }, B2); let Ah; function rO() { return Ah || (Ah = p2(nO)) } const oO = (...t) => { const e = rO().createApp(...t), { mount: n } = e; return e.mount = r => { const o = iO(r); if (!o) return; const i = e._component; !ce(i) && !i.render && !i.template && (i.template = o.innerHTML), o.innerHTML = ""; const s = n(o, !1, o instanceof SVGElement); return o instanceof Element && (o.removeAttribute("v-cloak"), o.setAttribute("data-v-app", "")), s }, e }; function iO(t) { return Ge(t) ? document.querySelector(t) : t } const ue = Wo({ user: {}, account: {}, recipes: [], activeRecipe: null, ingredients: [], favorites: [], isEditing: !1 }); class fy { constructor(e) { this.id = e.id, this.name = e.name, this.picture = e.picture } } class Sr { constructor(e) { this.id = e.id, this.favoriteId = e.favoriteId ? e.favoriteId : null, this.title = e.title, this.instructions = e.instructions, this.img = e.img, this.category = e.category, this.createdAt = e.createdAt, this.updatedAt = e.updatedAt, this.creatorId = e.creatorId, this.creator = new fy(e.creator) } } function dy(t, e) { return function() { return t.apply(e, arguments) } } const { toString: sO } = Object.prototype, { getPrototypeOf: Wu } = Object, Va = (t => e => { const n = sO.call(e); return t[n] || (t[n] = n.slice(8, -1).toLowerCase()) })(Object.create(null)), gn = t => (t = t.toLowerCase(), e => Va(e) === t), Ka = t => e => typeof e === t, { isArray: zo } = Array, Di = Ka("undefined"); function aO(t) { return t !== null && !Di(t) && t.constructor !== null && !Di(t.constructor) && Mt(t.constructor.isBuffer) && t.constructor.isBuffer(t) } const hy = gn("ArrayBuffer"); function cO(t) { let e; return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? e = ArrayBuffer.isView(t) : e = t && t.buffer && hy(t.buffer), e } const lO = Ka("string"), Mt = Ka("function"), py = Ka("number"), Wa = t => t !== null && typeof t == "object", uO = t => t === !0 || t === !1, Fs = t => { if (Va(t) !== "object") return !1; const e = Wu(t); return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(Symbol.toStringTag in t) && !(Symbol.iterator in t) }, fO = gn("Date"), dO = gn("File"), hO = gn("Blob"), pO = gn("FileList"), mO = t => Wa(t) && Mt(t.pipe), gO = t => { let e; return t && (typeof FormData == "function" && t instanceof FormData || Mt(t.append) && ((e = Va(t)) === "formdata" || e === "object" && Mt(t.toString) && t.toString() === "[object FormData]")) }, yO = gn("URLSearchParams"), wO = t => t.trim ? t.trim() : t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""); function qi(t, e, { allOwnKeys: n = !1 } = {}) { if (t === null || typeof t > "u") return; let r, o; if (typeof t != "object" && (t = [t]), zo(t)) for (r = 0, o = t.length; r < o; r++)e.call(null, t[r], r, t); else { const i = n ? Object.getOwnPropertyNames(t) : Object.keys(t), s = i.length; let c; for (r = 0; r < s; r++)c = i[r], e.call(null, t[c], c, t) } } function my(t, e) { e = e.toLowerCase(); const n = Object.keys(t); let r = n.length, o; for (; r-- > 0;)if (o = n[r], e === o.toLowerCase()) return o; return null } const gy = (() => typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global)(), yy = t => !Di(t) && t !== gy; function Sl() { const { caseless: t } = yy(this) && this || {}, e = {}, n = (r, o) => { const i = t && my(e, o) || o; Fs(e[i]) && Fs(r) ? e[i] = Sl(e[i], r) : Fs(r) ? e[i] = Sl({}, r) : zo(r) ? e[i] = r.slice() : e[i] = r }; for (let r = 0, o = arguments.length; r < o; r++)arguments[r] && qi(arguments[r], n); return e } const bO = (t, e, n, { allOwnKeys: r } = {}) => (qi(e, (o, i) => { n && Mt(o) ? t[i] = dy(o, n) : t[i] = o }, { allOwnKeys: r }), t), vO = t => (t.charCodeAt(0) === 65279 && (t = t.slice(1)), t), _O = (t, e, n, r) => { t.prototype = Object.create(e.prototype, r), t.prototype.constructor = t, Object.defineProperty(t, "super", { value: e.prototype }), n && Object.assign(t.prototype, n) }, EO = (t, e, n, r) => { let o, i, s; const c = {}; if (e = e || {}, t == null) return e; do { for (o = Object.getOwnPropertyNames(t), i = o.length; i-- > 0;)s = o[i], (!r || r(s, t, e)) && !c[s] && (e[s] = t[s], c[s] = !0); t = n !== !1 && Wu(t) } while (t && (!n || n(t, e)) && t !== Object.prototype); return e }, AO = (t, e, n) => { t = String(t), (n === void 0 || n > t.length) && (n = t.length), n -= e.length; const r = t.indexOf(e, n); return r !== -1 && r === n }, TO = t => { if (!t) return null; if (zo(t)) return t; let e = t.length; if (!py(e)) return null; const n = new Array(e); for (; e-- > 0;)n[e] = t[e]; return n }, SO = (t => e => t && e instanceof t)(typeof Uint8Array < "u" && Wu(Uint8Array)), CO = (t, e) => { const r = (t && t[Symbol.iterator]).call(t); let o; for (; (o = r.next()) && !o.done;) { const i = o.value; e.call(t, i[0], i[1]) } }, OO = (t, e) => { let n; const r = []; for (; (n = t.exec(e)) !== null;)r.push(n); return r }, xO = gn("HTMLFormElement"), kO = t => t.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function(n, r, o) { return r.toUpperCase() + o }), Th = (({ hasOwnProperty: t }) => (e, n) => t.call(e, n))(Object.prototype), RO = gn("RegExp"), wy = (t, e) => { const n = Object.getOwnPropertyDescriptors(t), r = {}; qi(n, (o, i) => { e(o, i, t) !== !1 && (r[i] = o) }), Object.defineProperties(t, r) }, IO = t => { wy(t, (e, n) => { if (Mt(t) && ["arguments", "caller", "callee"].indexOf(n) !== -1) return !1; const r = t[n]; if (Mt(r)) { if (e.enumerable = !1, "writable" in e) { e.writable = !1; return } e.set || (e.set = () => { throw Error("Can not rewrite read-only method '" + n + "'") }) } }) }, PO = (t, e) => { const n = {}, r = o => { o.forEach(i => { n[i] = !0 }) }; return zo(t) ? r(t) : r(String(t).split(e)), n }, NO = () => { }, LO = (t, e) => (t = +t, Number.isFinite(t) ? t : e), Ic = "abcdefghijklmnopqrstuvwxyz", Sh = "0123456789", by = { DIGIT: Sh, ALPHA: Ic, ALPHA_DIGIT: Ic + Ic.toUpperCase() + Sh }, DO = (t = 16, e = by.ALPHA_DIGIT) => { let n = ""; const { length: r } = e; for (; t--;)n += e[Math.random() * r | 0]; return n }; function BO(t) { return !!(t && Mt(t.append) && t[Symbol.toStringTag] === "FormData" && t[Symbol.iterator]) } const $O = t => { const e = new Array(10), n = (r, o) => { if (Wa(r)) { if (e.indexOf(r) >= 0) return; if (!("toJSON" in r)) { e[o] = r; const i = zo(r) ? [] : {}; return qi(r, (s, c) => { const u = n(s, o + 1); !Di(u) && (i[c] = u) }), e[o] = void 0, i } } return r }; return n(t, 0) }, MO = gn("AsyncFunction"), FO = t => t && (Wa(t) || Mt(t)) && Mt(t.then) && Mt(t.catch), I = { isArray: zo, isArrayBuffer: hy, isBuffer: aO, isFormData: gO, isArrayBufferView: cO, isString: lO, isNumber: py, isBoolean: uO, isObject: Wa, isPlainObject: Fs, isUndefined: Di, isDate: fO, isFile: dO, isBlob: hO, isRegExp: RO, isFunction: Mt, isStream: mO, isURLSearchParams: yO, isTypedArray: SO, isFileList: pO, forEach: qi, merge: Sl, extend: bO, trim: wO, stripBOM: vO, inherits: _O, toFlatObject: EO, kindOf: Va, kindOfTest: gn, endsWith: AO, toArray: TO, forEachEntry: CO, matchAll: OO, isHTMLForm: xO, hasOwnProperty: Th, hasOwnProp: Th, reduceDescriptors: wy, freezeMethods: IO, toObjectSet: PO, toCamelCase: kO, noop: NO, toFiniteNumber: LO, findKey: my, global: gy, isContextDefined: yy, ALPHABET: by, generateString: DO, isSpecCompliantForm: BO, toJSONObject: $O, isAsyncFn: MO, isThenable: FO }; function ve(t, e, n, r, o) { Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = t, this.name = "AxiosError", e && (this.code = e), n && (this.config = n), r && (this.request = r), o && (this.response = o) } I.inherits(ve, Error, { toJSON: function() { return { message: this.message, name: this.name, description: this.description, number: this.number, fileName: this.fileName, lineNumber: this.lineNumber, columnNumber: this.columnNumber, stack: this.stack, config: I.toJSONObject(this.config), code: this.code, status: this.response && this.response.status ? this.response.status : null } } }); const vy = ve.prototype, _y = {};["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach(t => { _y[t] = { value: t } }); Object.defineProperties(ve, _y); Object.defineProperty(vy, "isAxiosError", { value: !0 }); ve.from = (t, e, n, r, o, i) => { const s = Object.create(vy); return I.toFlatObject(t, s, function(u) { return u !== Error.prototype }, c => c !== "isAxiosError"), ve.call(s, t.message, e, n, r, o), s.cause = t, s.name = t.name, i && Object.assign(s, i), s }; const jO = null; function Cl(t) { return I.isPlainObject(t) || I.isArray(t) } function Ey(t) { return I.endsWith(t, "[]") ? t.slice(0, -2) : t } function Ch(t, e, n) { return t ? t.concat(e).map(function(o, i) { return o = Ey(o), !n && i ? "[" + o + "]" : o }).join(n ? "." : "") : e } function HO(t) { return I.isArray(t) && !t.some(Cl) } const UO = I.toFlatObject(I, {}, null, function(e) { return /^is[A-Z]/.test(e) }); function za(t, e, n) { if (!I.isObject(t)) throw new TypeError("target must be an object"); e = e || new FormData, n = I.toFlatObject(n, { metaTokens: !0, dots: !1, indexes: !1 }, !1, function(_, A) { return !I.isUndefined(A[_]) }); const r = n.metaTokens, o = n.visitor || d, i = n.dots, s = n.indexes, u = (n.Blob || typeof Blob < "u" && Blob) && I.isSpecCompliantForm(e); if (!I.isFunction(o)) throw new TypeError("visitor must be a function"); function a(y) { if (y === null) return ""; if (I.isDate(y)) return y.toISOString(); if (!u && I.isBlob(y)) throw new ve("Blob is not supported. Use a Buffer instead."); return I.isArrayBuffer(y) || I.isTypedArray(y) ? u && typeof Blob == "function" ? new Blob([y]) : Buffer.from(y) : y } function d(y, _, A) { let E = y; if (y && !A && typeof y == "object") { if (I.endsWith(_, "{}")) _ = r ? _ : _.slice(0, -2), y = JSON.stringify(y); else if (I.isArray(y) && HO(y) || (I.isFileList(y) || I.endsWith(_, "[]")) && (E = I.toArray(y))) return _ = Ey(_), E.forEach(function(x, P) { !(I.isUndefined(x) || x === null) && e.append(s === !0 ? Ch([_], P, i) : s === null ? _ : _ + "[]", a(x)) }), !1 } return Cl(y) ? !0 : (e.append(Ch(A, _, i), a(y)), !1) } const h = [], m = Object.assign(UO, { defaultVisitor: d, convertValue: a, isVisitable: Cl }); function g(y, _) { if (!I.isUndefined(y)) { if (h.indexOf(y) !== -1) throw Error("Circular reference detected in " + _.join(".")); h.push(y), I.forEach(y, function(E, T) { (!(I.isUndefined(E) || E === null) && o.call(e, E, I.isString(T) ? T.trim() : T, _, m)) === !0 && g(E, _ ? _.concat(T) : [T]) }), h.pop() } } if (!I.isObject(t)) throw new TypeError("data must be an object"); return g(t), e } function Oh(t) { const e = { "!": "%21", "'": "%27", "(": "%28", ")": "%29", "~": "%7E", "%20": "+", "%00": "\0" }; return encodeURIComponent(t).replace(/[!'()~]|%20|%00/g, function(r) { return e[r] }) } function zu(t, e) { this._pairs = [], t && za(t, this, e) } const Ay = zu.prototype; Ay.append = function(e, n) { this._pairs.push([e, n]) }; Ay.toString = function(e) { const n = e ? function(r) { return e.call(this, r, Oh) } : Oh; return this._pairs.map(function(o) { return n(o[0]) + "=" + n(o[1]) }, "").join("&") }; function VO(t) { return encodeURIComponent(t).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]") } function Ty(t, e, n) { if (!e) return t; const r = n && n.encode || VO, o = n && n.serialize; let i; if (o ? i = o(e, n) : i = I.isURLSearchParams(e) ? e.toString() : new zu(e, n).toString(r), i) { const s = t.indexOf("#"); s !== -1 && (t = t.slice(0, s)), t += (t.indexOf("?") === -1 ? "?" : "&") + i } return t } class KO { constructor() { this.handlers = [] } use(e, n, r) { return this.handlers.push({ fulfilled: e, rejected: n, synchronous: r ? r.synchronous : !1, runWhen: r ? r.runWhen : null }), this.handlers.length - 1 } eject(e) { this.handlers[e] && (this.handlers[e] = null) } clear() { this.handlers && (this.handlers = []) } forEach(e) { I.forEach(this.handlers, function(r) { r !== null && e(r) }) } } const xh = KO, Sy = { silentJSONParsing: !0, forcedJSONParsing: !0, clarifyTimeoutError: !1 }, WO = typeof URLSearchParams < "u" ? URLSearchParams : zu, zO = typeof FormData < "u" ? FormData : null, qO = typeof Blob < "u" ? Blob : null, GO = (() => { let t; return typeof navigator < "u" && ((t = navigator.product) === "ReactNative" || t === "NativeScript" || t === "NS") ? !1 : typeof window < "u" && typeof document < "u" })(), YO = (() => typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && typeof self.importScripts == "function")(), sn = { isBrowser: !0, classes: { URLSearchParams: WO, FormData: zO, Blob: qO }, isStandardBrowserEnv: GO, isStandardBrowserWebWorkerEnv: YO, protocols: ["http", "https", "file", "blob", "url", "data"] }; function XO(t, e) { return za(t, new sn.classes.URLSearchParams, Object.assign({ visitor: function(n, r, o, i) { return sn.isNode && I.isBuffer(n) ? (this.append(r, n.toString("base64")), !1) : i.defaultVisitor.apply(this, arguments) } }, e)) } function ZO(t) { return I.matchAll(/\w+|\[(\w*)]/g, t).map(e => e[0] === "[]" ? "" : e[1] || e[0]) } function JO(t) { const e = {}, n = Object.keys(t); let r; const o = n.length; let i; for (r = 0; r < o; r++)i = n[r], e[i] = t[i]; return e } function Cy(t) { function e(n, r, o, i) { let s = n[i++]; const c = Number.isFinite(+s), u = i >= n.length; return s = !s && I.isArray(o) ? o.length : s, u ? (I.hasOwnProp(o, s) ? o[s] = [o[s], r] : o[s] = r, !c) : ((!o[s] || !I.isObject(o[s])) && (o[s] = []), e(n, r, o[s], i) && I.isArray(o[s]) && (o[s] = JO(o[s])), !c) } if (I.isFormData(t) && I.isFunction(t.entries)) { const n = {}; return I.forEachEntry(t, (r, o) => { e(ZO(r), o, n, 0) }), n } return null } const QO = { "Content-Type": void 0 }; function ex(t, e, n) { if (I.isString(t)) try { return (e || JSON.parse)(t), I.trim(t) } catch (r) { if (r.name !== "SyntaxError") throw r } return (n || JSON.stringify)(t) } const qa = { transitional: Sy, adapter: ["xhr", "http"], transformRequest: [function(e, n) { const r = n.getContentType() || "", o = r.indexOf("application/json") > -1, i = I.isObject(e); if (i && I.isHTMLForm(e) && (e = new FormData(e)), I.isFormData(e)) return o && o ? JSON.stringify(Cy(e)) : e; if (I.isArrayBuffer(e) || I.isBuffer(e) || I.isStream(e) || I.isFile(e) || I.isBlob(e)) return e; if (I.isArrayBufferView(e)) return e.buffer; if (I.isURLSearchParams(e)) return n.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), e.toString(); let c; if (i) { if (r.indexOf("application/x-www-form-urlencoded") > -1) return XO(e, this.formSerializer).toString(); if ((c = I.isFileList(e)) || r.indexOf("multipart/form-data") > -1) { const u = this.env && this.env.FormData; return za(c ? { "files[]": e } : e, u && new u, this.formSerializer) } } return i || o ? (n.setContentType("application/json", !1), ex(e)) : e }], transformResponse: [function(e) { const n = this.transitional || qa.transitional, r = n && n.forcedJSONParsing, o = this.responseType === "json"; if (e && I.isString(e) && (r && !this.responseType || o)) { const s = !(n && n.silentJSONParsing) && o; try { return JSON.parse(e) } catch (c) { if (s) throw c.name === "SyntaxError" ? ve.from(c, ve.ERR_BAD_RESPONSE, this, null, this.response) : c } } return e }], timeout: 0, xsrfCookieName: "XSRF-TOKEN", xsrfHeaderName: "X-XSRF-TOKEN", maxContentLength: -1, maxBodyLength: -1, env: { FormData: sn.classes.FormData, Blob: sn.classes.Blob }, validateStatus: function(e) { return e >= 200 && e < 300 }, headers: { common: { Accept: "application/json, text/plain, */*" } } }; I.forEach(["delete", "get", "head"], function(e) { qa.headers[e] = {} }); I.forEach(["post", "put", "patch"], function(e) { qa.headers[e] = I.merge(QO) }); const qu = qa, tx = I.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"]), nx = t => {
  const e = {}; let n, r, o; return t && t.split(`
`).forEach(function(s) { o = s.indexOf(":"), n = s.substring(0, o).trim().toLowerCase(), r = s.substring(o + 1).trim(), !(!n || e[n] && tx[n]) && (n === "set-cookie" ? e[n] ? e[n].push(r) : e[n] = [r] : e[n] = e[n] ? e[n] + ", " + r : r) }), e
}, kh = Symbol("internals"); function ai(t) { return t && String(t).trim().toLowerCase() } function js(t) { return t === !1 || t == null ? t : I.isArray(t) ? t.map(js) : String(t) } function rx(t) { const e = Object.create(null), n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g; let r; for (; r = n.exec(t);)e[r[1]] = r[2]; return e } const ox = t => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(t.trim()); function Pc(t, e, n, r, o) { if (I.isFunction(r)) return r.call(this, e, n); if (o && (e = n), !!I.isString(e)) { if (I.isString(r)) return e.indexOf(r) !== -1; if (I.isRegExp(r)) return r.test(e) } } function ix(t) { return t.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (e, n, r) => n.toUpperCase() + r) } function sx(t, e) { const n = I.toCamelCase(" " + e);["get", "set", "has"].forEach(r => { Object.defineProperty(t, r + n, { value: function(o, i, s) { return this[r].call(this, e, o, i, s) }, configurable: !0 }) }) } class Ga {
  constructor(e) { e && this.set(e) } set(e, n, r) { const o = this; function i(c, u, a) { const d = ai(u); if (!d) throw new Error("header name must be a non-empty string"); const h = I.findKey(o, d); (!h || o[h] === void 0 || a === !0 || a === void 0 && o[h] !== !1) && (o[h || u] = js(c)) } const s = (c, u) => I.forEach(c, (a, d) => i(a, d, u)); return I.isPlainObject(e) || e instanceof this.constructor ? s(e, n) : I.isString(e) && (e = e.trim()) && !ox(e) ? s(nx(e), n) : e != null && i(n, e, r), this } get(e, n) { if (e = ai(e), e) { const r = I.findKey(this, e); if (r) { const o = this[r]; if (!n) return o; if (n === !0) return rx(o); if (I.isFunction(n)) return n.call(this, o, r); if (I.isRegExp(n)) return n.exec(o); throw new TypeError("parser must be boolean|regexp|function") } } } has(e, n) { if (e = ai(e), e) { const r = I.findKey(this, e); return !!(r && this[r] !== void 0 && (!n || Pc(this, this[r], r, n))) } return !1 } delete(e, n) { const r = this; let o = !1; function i(s) { if (s = ai(s), s) { const c = I.findKey(r, s); c && (!n || Pc(r, r[c], c, n)) && (delete r[c], o = !0) } } return I.isArray(e) ? e.forEach(i) : i(e), o } clear(e) { const n = Object.keys(this); let r = n.length, o = !1; for (; r--;) { const i = n[r]; (!e || Pc(this, this[i], i, e, !0)) && (delete this[i], o = !0) } return o } normalize(e) { const n = this, r = {}; return I.forEach(this, (o, i) => { const s = I.findKey(r, i); if (s) { n[s] = js(o), delete n[i]; return } const c = e ? ix(i) : String(i).trim(); c !== i && delete n[i], n[c] = js(o), r[c] = !0 }), this } concat(...e) { return this.constructor.concat(this, ...e) } toJSON(e) { const n = Object.create(null); return I.forEach(this, (r, o) => { r != null && r !== !1 && (n[o] = e && I.isArray(r) ? r.join(", ") : r) }), n } [Symbol.iterator]() { return Object.entries(this.toJSON())[Symbol.iterator]() } toString() {
    return Object.entries(this.toJSON()).map(([e, n]) => e + ": " + n).join(`
`)
  } get [Symbol.toStringTag]() { return "AxiosHeaders" } static from(e) { return e instanceof this ? e : new this(e) } static concat(e, ...n) { const r = new this(e); return n.forEach(o => r.set(o)), r } static accessor(e) { const r = (this[kh] = this[kh] = { accessors: {} }).accessors, o = this.prototype; function i(s) { const c = ai(s); r[c] || (sx(o, s), r[c] = !0) } return I.isArray(e) ? e.forEach(i) : i(e), this }
} Ga.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]); I.freezeMethods(Ga.prototype); I.freezeMethods(Ga); const Cn = Ga; function Nc(t, e) { const n = this || qu, r = e || n, o = Cn.from(r.headers); let i = r.data; return I.forEach(t, function(c) { i = c.call(n, i, o.normalize(), e ? e.status : void 0) }), o.normalize(), i } function Oy(t) { return !!(t && t.__CANCEL__) } function Gi(t, e, n) { ve.call(this, t ?? "canceled", ve.ERR_CANCELED, e, n), this.name = "CanceledError" } I.inherits(Gi, ve, { __CANCEL__: !0 }); function ax(t, e, n) { const r = n.config.validateStatus; !n.status || !r || r(n.status) ? t(n) : e(new ve("Request failed with status code " + n.status, [ve.ERR_BAD_REQUEST, ve.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4], n.config, n.request, n)) } const cx = sn.isStandardBrowserEnv ? function() { return { write: function(n, r, o, i, s, c) { const u = []; u.push(n + "=" + encodeURIComponent(r)), I.isNumber(o) && u.push("expires=" + new Date(o).toGMTString()), I.isString(i) && u.push("path=" + i), I.isString(s) && u.push("domain=" + s), c === !0 && u.push("secure"), document.cookie = u.join("; ") }, read: function(n) { const r = document.cookie.match(new RegExp("(^|;\\s*)(" + n + ")=([^;]*)")); return r ? decodeURIComponent(r[3]) : null }, remove: function(n) { this.write(n, "", Date.now() - 864e5) } } }() : function() { return { write: function() { }, read: function() { return null }, remove: function() { } } }(); function lx(t) { return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(t) } function ux(t, e) { return e ? t.replace(/\/+$/, "") + "/" + e.replace(/^\/+/, "") : t } function xy(t, e) { return t && !lx(e) ? ux(t, e) : e } const fx = sn.isStandardBrowserEnv ? function() { const e = /(msie|trident)/i.test(navigator.userAgent), n = document.createElement("a"); let r; function o(i) { let s = i; return e && (n.setAttribute("href", s), s = n.href), n.setAttribute("href", s), { href: n.href, protocol: n.protocol ? n.protocol.replace(/:$/, "") : "", host: n.host, search: n.search ? n.search.replace(/^\?/, "") : "", hash: n.hash ? n.hash.replace(/^#/, "") : "", hostname: n.hostname, port: n.port, pathname: n.pathname.charAt(0) === "/" ? n.pathname : "/" + n.pathname } } return r = o(window.location.href), function(s) { const c = I.isString(s) ? o(s) : s; return c.protocol === r.protocol && c.host === r.host } }() : function() { return function() { return !0 } }(); function dx(t) { const e = /^([-+\w]{1,25})(:?\/\/|:)/.exec(t); return e && e[1] || "" } function hx(t, e) { t = t || 10; const n = new Array(t), r = new Array(t); let o = 0, i = 0, s; return e = e !== void 0 ? e : 1e3, function(u) { const a = Date.now(), d = r[i]; s || (s = a), n[o] = u, r[o] = a; let h = i, m = 0; for (; h !== o;)m += n[h++], h = h % t; if (o = (o + 1) % t, o === i && (i = (i + 1) % t), a - s < e) return; const g = d && a - d; return g ? Math.round(m * 1e3 / g) : void 0 } } function Rh(t, e) { let n = 0; const r = hx(50, 250); return o => { const i = o.loaded, s = o.lengthComputable ? o.total : void 0, c = i - n, u = r(c), a = i <= s; n = i; const d = { loaded: i, total: s, progress: s ? i / s : void 0, bytes: c, rate: u || void 0, estimated: u && s && a ? (s - i) / u : void 0, event: o }; d[e ? "download" : "upload"] = !0, t(d) } } const px = typeof XMLHttpRequest < "u", mx = px && function(t) { return new Promise(function(n, r) { let o = t.data; const i = Cn.from(t.headers).normalize(), s = t.responseType; let c; function u() { t.cancelToken && t.cancelToken.unsubscribe(c), t.signal && t.signal.removeEventListener("abort", c) } I.isFormData(o) && (sn.isStandardBrowserEnv || sn.isStandardBrowserWebWorkerEnv ? i.setContentType(!1) : i.setContentType("multipart/form-data;", !1)); let a = new XMLHttpRequest; if (t.auth) { const g = t.auth.username || "", y = t.auth.password ? unescape(encodeURIComponent(t.auth.password)) : ""; i.set("Authorization", "Basic " + btoa(g + ":" + y)) } const d = xy(t.baseURL, t.url); a.open(t.method.toUpperCase(), Ty(d, t.params, t.paramsSerializer), !0), a.timeout = t.timeout; function h() { if (!a) return; const g = Cn.from("getAllResponseHeaders" in a && a.getAllResponseHeaders()), _ = { data: !s || s === "text" || s === "json" ? a.responseText : a.response, status: a.status, statusText: a.statusText, headers: g, config: t, request: a }; ax(function(E) { n(E), u() }, function(E) { r(E), u() }, _), a = null } if ("onloadend" in a ? a.onloadend = h : a.onreadystatechange = function() { !a || a.readyState !== 4 || a.status === 0 && !(a.responseURL && a.responseURL.indexOf("file:") === 0) || setTimeout(h) }, a.onabort = function() { a && (r(new ve("Request aborted", ve.ECONNABORTED, t, a)), a = null) }, a.onerror = function() { r(new ve("Network Error", ve.ERR_NETWORK, t, a)), a = null }, a.ontimeout = function() { let y = t.timeout ? "timeout of " + t.timeout + "ms exceeded" : "timeout exceeded"; const _ = t.transitional || Sy; t.timeoutErrorMessage && (y = t.timeoutErrorMessage), r(new ve(y, _.clarifyTimeoutError ? ve.ETIMEDOUT : ve.ECONNABORTED, t, a)), a = null }, sn.isStandardBrowserEnv) { const g = (t.withCredentials || fx(d)) && t.xsrfCookieName && cx.read(t.xsrfCookieName); g && i.set(t.xsrfHeaderName, g) } o === void 0 && i.setContentType(null), "setRequestHeader" in a && I.forEach(i.toJSON(), function(y, _) { a.setRequestHeader(_, y) }), I.isUndefined(t.withCredentials) || (a.withCredentials = !!t.withCredentials), s && s !== "json" && (a.responseType = t.responseType), typeof t.onDownloadProgress == "function" && a.addEventListener("progress", Rh(t.onDownloadProgress, !0)), typeof t.onUploadProgress == "function" && a.upload && a.upload.addEventListener("progress", Rh(t.onUploadProgress)), (t.cancelToken || t.signal) && (c = g => { a && (r(!g || g.type ? new Gi(null, t, a) : g), a.abort(), a = null) }, t.cancelToken && t.cancelToken.subscribe(c), t.signal && (t.signal.aborted ? c() : t.signal.addEventListener("abort", c))); const m = dx(d); if (m && sn.protocols.indexOf(m) === -1) { r(new ve("Unsupported protocol " + m + ":", ve.ERR_BAD_REQUEST, t)); return } a.send(o || null) }) }, Hs = { http: jO, xhr: mx }; I.forEach(Hs, (t, e) => { if (t) { try { Object.defineProperty(t, "name", { value: e }) } catch { } Object.defineProperty(t, "adapterName", { value: e }) } }); const gx = { getAdapter: t => { t = I.isArray(t) ? t : [t]; const { length: e } = t; let n, r; for (let o = 0; o < e && (n = t[o], !(r = I.isString(n) ? Hs[n.toLowerCase()] : n)); o++); if (!r) throw r === !1 ? new ve(`Adapter ${n} is not supported by the environment`, "ERR_NOT_SUPPORT") : new Error(I.hasOwnProp(Hs, n) ? `Adapter '${n}' is not available in the build` : `Unknown adapter '${n}'`); if (!I.isFunction(r)) throw new TypeError("adapter is not a function"); return r }, adapters: Hs }; function Lc(t) { if (t.cancelToken && t.cancelToken.throwIfRequested(), t.signal && t.signal.aborted) throw new Gi(null, t) } function Ih(t) { return Lc(t), t.headers = Cn.from(t.headers), t.data = Nc.call(t, t.transformRequest), ["post", "put", "patch"].indexOf(t.method) !== -1 && t.headers.setContentType("application/x-www-form-urlencoded", !1), gx.getAdapter(t.adapter || qu.adapter)(t).then(function(r) { return Lc(t), r.data = Nc.call(t, t.transformResponse, r), r.headers = Cn.from(r.headers), r }, function(r) { return Oy(r) || (Lc(t), r && r.response && (r.response.data = Nc.call(t, t.transformResponse, r.response), r.response.headers = Cn.from(r.response.headers))), Promise.reject(r) }) } const Ph = t => t instanceof Cn ? t.toJSON() : t; function Ro(t, e) { e = e || {}; const n = {}; function r(a, d, h) { return I.isPlainObject(a) && I.isPlainObject(d) ? I.merge.call({ caseless: h }, a, d) : I.isPlainObject(d) ? I.merge({}, d) : I.isArray(d) ? d.slice() : d } function o(a, d, h) { if (I.isUndefined(d)) { if (!I.isUndefined(a)) return r(void 0, a, h) } else return r(a, d, h) } function i(a, d) { if (!I.isUndefined(d)) return r(void 0, d) } function s(a, d) { if (I.isUndefined(d)) { if (!I.isUndefined(a)) return r(void 0, a) } else return r(void 0, d) } function c(a, d, h) { if (h in e) return r(a, d); if (h in t) return r(void 0, a) } const u = { url: i, method: i, data: i, baseURL: s, transformRequest: s, transformResponse: s, paramsSerializer: s, timeout: s, timeoutMessage: s, withCredentials: s, adapter: s, responseType: s, xsrfCookieName: s, xsrfHeaderName: s, onUploadProgress: s, onDownloadProgress: s, decompress: s, maxContentLength: s, maxBodyLength: s, beforeRedirect: s, transport: s, httpAgent: s, httpsAgent: s, cancelToken: s, socketPath: s, responseEncoding: s, validateStatus: c, headers: (a, d) => o(Ph(a), Ph(d), !0) }; return I.forEach(Object.keys(Object.assign({}, t, e)), function(d) { const h = u[d] || o, m = h(t[d], e[d], d); I.isUndefined(m) && h !== c || (n[d] = m) }), n } const ky = "1.4.0", Gu = {};["object", "boolean", "number", "function", "string", "symbol"].forEach((t, e) => { Gu[t] = function(r) { return typeof r === t || "a" + (e < 1 ? "n " : " ") + t } }); const Nh = {}; Gu.transitional = function(e, n, r) { function o(i, s) { return "[Axios v" + ky + "] Transitional option '" + i + "'" + s + (r ? ". " + r : "") } return (i, s, c) => { if (e === !1) throw new ve(o(s, " has been removed" + (n ? " in " + n : "")), ve.ERR_DEPRECATED); return n && !Nh[s] && (Nh[s] = !0, console.warn(o(s, " has been deprecated since v" + n + " and will be removed in the near future"))), e ? e(i, s, c) : !0 } }; function yx(t, e, n) { if (typeof t != "object") throw new ve("options must be an object", ve.ERR_BAD_OPTION_VALUE); const r = Object.keys(t); let o = r.length; for (; o-- > 0;) { const i = r[o], s = e[i]; if (s) { const c = t[i], u = c === void 0 || s(c, i, t); if (u !== !0) throw new ve("option " + i + " must be " + u, ve.ERR_BAD_OPTION_VALUE); continue } if (n !== !0) throw new ve("Unknown option " + i, ve.ERR_BAD_OPTION) } } const Ol = { assertOptions: yx, validators: Gu }, jn = Ol.validators; let la = class { constructor(e) { this.defaults = e, this.interceptors = { request: new xh, response: new xh } } request(e, n) { typeof e == "string" ? (n = n || {}, n.url = e) : n = e || {}, n = Ro(this.defaults, n); const { transitional: r, paramsSerializer: o, headers: i } = n; r !== void 0 && Ol.assertOptions(r, { silentJSONParsing: jn.transitional(jn.boolean), forcedJSONParsing: jn.transitional(jn.boolean), clarifyTimeoutError: jn.transitional(jn.boolean) }, !1), o != null && (I.isFunction(o) ? n.paramsSerializer = { serialize: o } : Ol.assertOptions(o, { encode: jn.function, serialize: jn.function }, !0)), n.method = (n.method || this.defaults.method || "get").toLowerCase(); let s; s = i && I.merge(i.common, i[n.method]), s && I.forEach(["delete", "get", "head", "post", "put", "patch", "common"], y => { delete i[y] }), n.headers = Cn.concat(s, i); const c = []; let u = !0; this.interceptors.request.forEach(function(_) { typeof _.runWhen == "function" && _.runWhen(n) === !1 || (u = u && _.synchronous, c.unshift(_.fulfilled, _.rejected)) }); const a = []; this.interceptors.response.forEach(function(_) { a.push(_.fulfilled, _.rejected) }); let d, h = 0, m; if (!u) { const y = [Ih.bind(this), void 0]; for (y.unshift.apply(y, c), y.push.apply(y, a), m = y.length, d = Promise.resolve(n); h < m;)d = d.then(y[h++], y[h++]); return d } m = c.length; let g = n; for (h = 0; h < m;) { const y = c[h++], _ = c[h++]; try { g = y(g) } catch (A) { _.call(this, A); break } } try { d = Ih.call(this, g) } catch (y) { return Promise.reject(y) } for (h = 0, m = a.length; h < m;)d = d.then(a[h++], a[h++]); return d } getUri(e) { e = Ro(this.defaults, e); const n = xy(e.baseURL, e.url); return Ty(n, e.params, e.paramsSerializer) } }; I.forEach(["delete", "get", "head", "options"], function(e) { la.prototype[e] = function(n, r) { return this.request(Ro(r || {}, { method: e, url: n, data: (r || {}).data })) } }); I.forEach(["post", "put", "patch"], function(e) { function n(r) { return function(i, s, c) { return this.request(Ro(c || {}, { method: e, headers: r ? { "Content-Type": "multipart/form-data" } : {}, url: i, data: s })) } } la.prototype[e] = n(), la.prototype[e + "Form"] = n(!0) }); const Us = la; class Yu { constructor(e) { if (typeof e != "function") throw new TypeError("executor must be a function."); let n; this.promise = new Promise(function(i) { n = i }); const r = this; this.promise.then(o => { if (!r._listeners) return; let i = r._listeners.length; for (; i-- > 0;)r._listeners[i](o); r._listeners = null }), this.promise.then = o => { let i; const s = new Promise(c => { r.subscribe(c), i = c }).then(o); return s.cancel = function() { r.unsubscribe(i) }, s }, e(function(i, s, c) { r.reason || (r.reason = new Gi(i, s, c), n(r.reason)) }) } throwIfRequested() { if (this.reason) throw this.reason } subscribe(e) { if (this.reason) { e(this.reason); return } this._listeners ? this._listeners.push(e) : this._listeners = [e] } unsubscribe(e) { if (!this._listeners) return; const n = this._listeners.indexOf(e); n !== -1 && this._listeners.splice(n, 1) } static source() { let e; return { token: new Yu(function(o) { e = o }), cancel: e } } } const wx = Yu; function bx(t) { return function(n) { return t.apply(null, n) } } function vx(t) { return I.isObject(t) && t.isAxiosError === !0 } const xl = { Continue: 100, SwitchingProtocols: 101, Processing: 102, EarlyHints: 103, Ok: 200, Created: 201, Accepted: 202, NonAuthoritativeInformation: 203, NoContent: 204, ResetContent: 205, PartialContent: 206, MultiStatus: 207, AlreadyReported: 208, ImUsed: 226, MultipleChoices: 300, MovedPermanently: 301, Found: 302, SeeOther: 303, NotModified: 304, UseProxy: 305, Unused: 306, TemporaryRedirect: 307, PermanentRedirect: 308, BadRequest: 400, Unauthorized: 401, PaymentRequired: 402, Forbidden: 403, NotFound: 404, MethodNotAllowed: 405, NotAcceptable: 406, ProxyAuthenticationRequired: 407, RequestTimeout: 408, Conflict: 409, Gone: 410, LengthRequired: 411, PreconditionFailed: 412, PayloadTooLarge: 413, UriTooLong: 414, UnsupportedMediaType: 415, RangeNotSatisfiable: 416, ExpectationFailed: 417, ImATeapot: 418, MisdirectedRequest: 421, UnprocessableEntity: 422, Locked: 423, FailedDependency: 424, TooEarly: 425, UpgradeRequired: 426, PreconditionRequired: 428, TooManyRequests: 429, RequestHeaderFieldsTooLarge: 431, UnavailableForLegalReasons: 451, InternalServerError: 500, NotImplemented: 501, BadGateway: 502, ServiceUnavailable: 503, GatewayTimeout: 504, HttpVersionNotSupported: 505, VariantAlsoNegotiates: 506, InsufficientStorage: 507, LoopDetected: 508, NotExtended: 510, NetworkAuthenticationRequired: 511 }; Object.entries(xl).forEach(([t, e]) => { xl[e] = t }); const _x = xl; function Ry(t) { const e = new Us(t), n = dy(Us.prototype.request, e); return I.extend(n, Us.prototype, e, { allOwnKeys: !0 }), I.extend(n, e, null, { allOwnKeys: !0 }), n.create = function(o) { return Ry(Ro(t, o)) }, n } const Ye = Ry(qu); Ye.Axios = Us; Ye.CanceledError = Gi; Ye.CancelToken = wx; Ye.isCancel = Oy; Ye.VERSION = ky; Ye.toFormData = za; Ye.AxiosError = ve; Ye.Cancel = Ye.CanceledError; Ye.all = function(e) { return Promise.all(e) }; Ye.spread = bx; Ye.isAxiosError = vx; Ye.mergeConfig = Ro; Ye.AxiosHeaders = Cn; Ye.formToJSON = t => Cy(I.isHTMLForm(t) ? new FormData(t) : t); Ye.HttpStatusCode = _x; Ye.default = Ye; const Ex = Ye, Iy = window.location.origin.includes("localhost"), Ax = Iy ? "https://localhost:7045" : "", Tx = "dev-4sjhjftaw74ytohu.us.auth0.com", Sx = "1IsKgLLy06BzrKd64KnDD2KSWDzEfuJs", Cx = "classroom.com"; function ci(t, e) { if (Iy) console[t](`[${t}] :: ${new Date().toLocaleTimeString()} :: `, ...e); else { switch (t) { case "log": case "assert": return }console[t](`[${t}] :: ${new Date().toLocaleTimeString()} :: `, ...e) } } const Nt = { log() { ci("log", arguments) }, error() { ci("error", arguments) }, warn() { ci("warn", arguments) }, assert() { ci("assert", arguments) }, trace() { ci("trace", arguments) } }, it = Ex.create({ baseURL: Ax, timeout: 8e3 }); it.interceptors.request.use(t => t, Py); it.interceptors.response.use(t => t, Py); function Py(t) { return t.response ? Nt.warn("[ AXIOS_ERROR_RESPONSE_DATA]", t.response.data) : t.request ? Nt.warn("[ AXIOS_ERROR_NO_RESPONSE]", t.request) : Nt.warn("[ AXIOS_ERROR_INVALID_REQUEST]", t.message), Promise.reject(t) } class Ox { setActiveRecipe(e) { ue.activeRecipe = e } async getRecipes(e = "") { const n = await it.get(`api/recipes?title=${e.trim()}`); ue.recipes = n.data.map(r => new Sr(r)) } async getRecipesByAccountId() { const e = await it.get("account/recipes"); ue.recipes = e.data.map(n => new Sr(n)) } async createRecipe(e) { const n = await it.post("api/recipes", e); ue.recipes.push(new Sr(n.data)) } async updateRecipe(e) { const n = await it.put(`api/recipes/${e.id}`, e), r = ue.recipes.findIndex(o => o.id == n.data.id); ue.recipes.splice(r, 1, new Sr(n.data)) } async removeRecipe() { const e = await it.delete(`api/recipes/${ue.activeRecipe.id}`); ue.recipes = ue.recipes.filter(n => n.id != e.data.id) } } const Io = new Ox; class xx { async getFavoritesByAccountId(e) { const n = await it.get("account/favorites"); e ? ue.recipes = n.data.map(r => new Sr(r)) : ue.favorites = n.data.map(r => new Sr(r)) } async createFavorite(e) { const n = await it.post("api/favorites", { recipeId: e }); n.data.favoriteId = n.data.id, n.data.id = e, ue.favorites.push(n.data) } async removeFavorite(e) { const n = ue.favorites, r = n.find(i => i.id == e), o = await it.delete(`api/favorites/${r.favoriteId}`); ue.favorites = n.filter(i => i.id != o.data.recipeId) } } const Po = new xx; var Hn = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}; function kx(t) { return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t } var Ny = { exports: {} };/*!
* sweetalert2 v11.7.10
* Released under the MIT License.
*/(function(t, e) {
  (function(n, r) { t.exports = r() })(Hn, function() {
    const r = {}, o = () => { r.previousActiveElement instanceof HTMLElement ? (r.previousActiveElement.focus(), r.previousActiveElement = null) : document.body && document.body.focus() }, i = l => new Promise(f => { if (!l) return f(); const p = window.scrollX, b = window.scrollY; r.restoreFocusTimeout = setTimeout(() => { o(), f() }, 100), window.scrollTo(p, b) }); var s = { promise: new WeakMap, innerParams: new WeakMap, domCache: new WeakMap }; const c = "swal2-", a = ["container", "shown", "height-auto", "iosfix", "popup", "modal", "no-backdrop", "no-transition", "toast", "toast-shown", "show", "hide", "close", "title", "html-container", "actions", "confirm", "deny", "cancel", "default-outline", "footer", "icon", "icon-content", "image", "input", "file", "range", "select", "radio", "checkbox", "label", "textarea", "inputerror", "input-label", "validation-message", "progress-steps", "active-progress-step", "progress-step", "progress-step-line", "loader", "loading", "styled", "top", "top-start", "top-end", "top-left", "top-right", "center", "center-start", "center-end", "center-left", "center-right", "bottom", "bottom-start", "bottom-end", "bottom-left", "bottom-right", "grow-row", "grow-column", "grow-fullscreen", "rtl", "timer-progress-bar", "timer-progress-bar-container", "scrollbar-measure", "icon-success", "icon-warning", "icon-info", "icon-question", "icon-error"].reduce((l, f) => (l[f] = c + f, l), {}), h = ["success", "warning", "info", "question", "error"].reduce((l, f) => (l[f] = c + f, l), {}), m = "SweetAlert2:", g = l => l.charAt(0).toUpperCase() + l.slice(1), y = l => { console.warn(`${m} ${typeof l == "object" ? l.join(" ") : l}`) }, _ = l => { console.error(`${m} ${l}`) }, A = [], E = l => { A.includes(l) || (A.push(l), y(l)) }, T = (l, f) => { E(`"${l}" is deprecated and will be removed in the next major release. Please use "${f}" instead.`) }, x = l => typeof l == "function" ? l() : l, P = l => l && typeof l.toPromise == "function", W = l => P(l) ? l.toPromise() : Promise.resolve(l), Y = l => l && Promise.resolve(l) === l, Z = () => document.body.querySelector(`.${a.container}`), he = l => { const f = Z(); return f ? f.querySelector(l) : null }, re = l => he(`.${l}`), z = () => re(a.popup), ye = () => re(a.icon), De = () => re(a["icon-content"]), fe = () => re(a.title), He = () => re(a["html-container"]), nt = () => re(a.image), pe = () => re(a["progress-steps"]), ie = () => re(a["validation-message"]), oe = () => he(`.${a.actions} .${a.confirm}`), Re = () => he(`.${a.actions} .${a.cancel}`), $e = () => he(`.${a.actions} .${a.deny}`), at = () => re(a["input-label"]), Ce = () => he(`.${a.loader}`), rt = () => re(a.actions), ct = () => re(a.footer), Xe = () => re(a["timer-progress-bar"]), Oe = () => re(a.close), R = `
  a[href],
  area[href],
  input:not([disabled]),
  select:not([disabled]),
  textarea:not([disabled]),
  button:not([disabled]),
  iframe,
  object,
  embed,
  [tabindex="0"],
  [contenteditable],
  audio[controls],
  video[controls],
  summary
`, U = () => { const l = z().querySelectorAll('[tabindex]:not([tabindex="-1"]):not([tabindex="0"])'), f = Array.from(l).sort((O, Q) => { const Te = parseInt(O.getAttribute("tabindex")), qe = parseInt(Q.getAttribute("tabindex")); return Te > qe ? 1 : Te < qe ? -1 : 0 }), p = z().querySelectorAll(R), b = Array.from(p).filter(O => O.getAttribute("tabindex") !== "-1"); return [...new Set(f.concat(b))].filter(O => ae(O)) }, j = () => v(document.body, a.shown) && !v(document.body, a["toast-shown"]) && !v(document.body, a["no-backdrop"]), X = () => z() && v(z(), a.toast), me = () => z().hasAttribute("data-loading"), w = (l, f) => { if (l.textContent = "", f) { const b = new DOMParser().parseFromString(f, "text/html"); Array.from(b.querySelector("head").childNodes).forEach(O => { l.appendChild(O) }), Array.from(b.querySelector("body").childNodes).forEach(O => { O instanceof HTMLVideoElement || O instanceof HTMLAudioElement ? l.appendChild(O.cloneNode(!0)) : l.appendChild(O) }) } }, v = (l, f) => { if (!f) return !1; const p = f.split(/\s+/); for (let b = 0; b < p.length; b++)if (!l.classList.contains(p[b])) return !1; return !0 }, S = (l, f) => { Array.from(l.classList).forEach(p => { !Object.values(a).includes(p) && !Object.values(h).includes(p) && !Object.values(f.showClass).includes(p) && l.classList.remove(p) }) }, C = (l, f, p) => { if (S(l, f), f.customClass && f.customClass[p]) { if (typeof f.customClass[p] != "string" && !f.customClass[p].forEach) { y(`Invalid type of customClass.${p}! Expected string or iterable object, got "${typeof f.customClass[p]}"`); return } k(l, f.customClass[p]) } }, N = (l, f) => { if (!f) return null; switch (f) { case "select": case "textarea": case "file": return l.querySelector(`.${a.popup} > .${a[f]}`); case "checkbox": return l.querySelector(`.${a.popup} > .${a.checkbox} input`); case "radio": return l.querySelector(`.${a.popup} > .${a.radio} input:checked`) || l.querySelector(`.${a.popup} > .${a.radio} input:first-child`); case "range": return l.querySelector(`.${a.popup} > .${a.range} input`); default: return l.querySelector(`.${a.popup} > .${a.input}`) } }, D = l => { if (l.focus(), l.type !== "file") { const f = l.value; l.value = "", l.value = f } }, V = (l, f, p) => { !l || !f || (typeof f == "string" && (f = f.split(/\s+/).filter(Boolean)), f.forEach(b => { Array.isArray(l) ? l.forEach(O => { p ? O.classList.add(b) : O.classList.remove(b) }) : p ? l.classList.add(b) : l.classList.remove(b) })) }, k = (l, f) => { V(l, f, !0) }, $ = (l, f) => { V(l, f, !1) }, L = (l, f) => { const p = Array.from(l.children); for (let b = 0; b < p.length; b++) { const O = p[b]; if (O instanceof HTMLElement && v(O, f)) return O } }, G = (l, f, p) => { p === `${parseInt(p)}` && (p = parseInt(p)), p || parseInt(p) === 0 ? l.style[f] = typeof p == "number" ? `${p}px` : p : l.style.removeProperty(f) }, H = function(l) { let f = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "flex"; l && (l.style.display = f) }, K = l => { l && (l.style.display = "none") }, ee = (l, f, p, b) => { const O = l.querySelector(f); O && (O.style[p] = b) }, se = function(l, f) { let p = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "flex"; f ? H(l, p) : K(l) }, ae = l => !!(l && (l.offsetWidth || l.offsetHeight || l.getClientRects().length)), we = () => !ae(oe()) && !ae($e()) && !ae(Re()), Be = l => l.scrollHeight > l.clientHeight, vt = l => { const f = window.getComputedStyle(l), p = parseFloat(f.getPropertyValue("animation-duration") || "0"), b = parseFloat(f.getPropertyValue("transition-duration") || "0"); return p > 0 || b > 0 }, Qt = function(l) { let f = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1; const p = Xe(); ae(p) && (f && (p.style.transition = "none", p.style.width = "100%"), setTimeout(() => { p.style.transition = `width ${l / 1e3}s linear`, p.style.width = "0%" }, 10)) }, es = () => { const l = Xe(), f = parseInt(window.getComputedStyle(l).width); l.style.removeProperty("transition"), l.style.width = "100%"; const p = parseInt(window.getComputedStyle(l).width), b = f / p * 100; l.style.width = `${b}%` }, Bn = () => typeof window > "u" || typeof document > "u", ts = `
 <div aria-labelledby="${a.title}" aria-describedby="${a["html-container"]}" class="${a.popup}" tabindex="-1">
   <button type="button" class="${a.close}"></button>
   <ul class="${a["progress-steps"]}"></ul>
   <div class="${a.icon}"></div>
   <img class="${a.image}" />
   <h2 class="${a.title}" id="${a.title}"></h2>
   <div class="${a["html-container"]}" id="${a["html-container"]}"></div>
   <input class="${a.input}" />
   <input type="file" class="${a.file}" />
   <div class="${a.range}">
     <input type="range" />
     <output></output>
   </div>
   <select class="${a.select}"></select>
   <div class="${a.radio}"></div>
   <label for="${a.checkbox}" class="${a.checkbox}">
     <input type="checkbox" />
     <span class="${a.label}"></span>
   </label>
   <textarea class="${a.textarea}"></textarea>
   <div class="${a["validation-message"]}" id="${a["validation-message"]}"></div>
   <div class="${a.actions}">
     <div class="${a.loader}"></div>
     <button type="button" class="${a.confirm}"></button>
     <button type="button" class="${a.deny}"></button>
     <button type="button" class="${a.cancel}"></button>
   </div>
   <div class="${a.footer}"></div>
   <div class="${a["timer-progress-bar-container"]}">
     <div class="${a["timer-progress-bar"]}"></div>
   </div>
 </div>
`.replace(/(^|\n)\s*/g, ""), ht = () => { const l = Z(); return l ? (l.remove(), $([document.documentElement, document.body], [a["no-backdrop"], a["toast-shown"], a["has-column"]]), !0) : !1 }, Ze = () => { r.currentInstance.resetValidationMessage() }, ns = () => { const l = z(), f = L(l, a.input), p = L(l, a.file), b = l.querySelector(`.${a.range} input`), O = l.querySelector(`.${a.range} output`), Q = L(l, a.select), Te = l.querySelector(`.${a.checkbox} input`), qe = L(l, a.textarea); f.oninput = Ze, p.onchange = Ze, Q.onchange = Ze, Te.onchange = Ze, qe.oninput = Ze, b.oninput = () => { Ze(), O.value = b.value }, b.onchange = () => { Ze(), O.value = b.value } }, fb = l => typeof l == "string" ? document.querySelector(l) : l, db = l => { const f = z(); f.setAttribute("role", l.toast ? "alert" : "dialog"), f.setAttribute("aria-live", l.toast ? "polite" : "assertive"), l.toast || f.setAttribute("aria-modal", "true") }, hb = l => { window.getComputedStyle(l).direction === "rtl" && k(Z(), a.rtl) }, pb = l => { const f = ht(); if (Bn()) { _("SweetAlert2 requires document to initialize"); return } const p = document.createElement("div"); p.className = a.container, f && k(p, a["no-transition"]), w(p, ts); const b = fb(l.target); b.appendChild(p), db(l), hb(b), ns() }, nc = (l, f) => { l instanceof HTMLElement ? f.appendChild(l) : typeof l == "object" ? mb(l, f) : l && w(f, l) }, mb = (l, f) => { l.jquery ? gb(f, l) : w(f, l.toString()) }, gb = (l, f) => { if (l.textContent = "", 0 in f) for (let p = 0; p in f; p++)l.appendChild(f[p].cloneNode(!0)); else l.appendChild(f.cloneNode(!0)) }, ei = (() => { if (Bn()) return !1; const l = document.createElement("div"), f = { WebkitAnimation: "webkitAnimationEnd", animation: "animationend" }; for (const p in f) if (Object.prototype.hasOwnProperty.call(f, p) && typeof l.style[p] < "u") return f[p]; return !1 })(), yb = (l, f) => { const p = rt(), b = Ce(); !f.showConfirmButton && !f.showDenyButton && !f.showCancelButton ? K(p) : H(p), C(p, f, "actions"), wb(p, b, f), w(b, f.loaderHtml), C(b, f, "loader") }; function wb(l, f, p) { const b = oe(), O = $e(), Q = Re(); rc(b, "confirm", p), rc(O, "deny", p), rc(Q, "cancel", p), bb(b, O, Q, p), p.reverseButtons && (p.toast ? (l.insertBefore(Q, b), l.insertBefore(O, b)) : (l.insertBefore(Q, f), l.insertBefore(O, f), l.insertBefore(b, f))) } function bb(l, f, p, b) { if (!b.buttonsStyling) { $([l, f, p], a.styled); return } k([l, f, p], a.styled), b.confirmButtonColor && (l.style.backgroundColor = b.confirmButtonColor, k(l, a["default-outline"])), b.denyButtonColor && (f.style.backgroundColor = b.denyButtonColor, k(f, a["default-outline"])), b.cancelButtonColor && (p.style.backgroundColor = b.cancelButtonColor, k(p, a["default-outline"])) } function rc(l, f, p) { se(l, p[`show${g(f)}Button`], "inline-block"), w(l, p[`${f}ButtonText`]), l.setAttribute("aria-label", p[`${f}ButtonAriaLabel`]), l.className = a[f], C(l, p, `${f}Button`), k(l, p[`${f}ButtonClass`]) } const vb = (l, f) => { const p = Oe(); w(p, f.closeButtonHtml), C(p, f, "closeButton"), se(p, f.showCloseButton), p.setAttribute("aria-label", f.closeButtonAriaLabel) }, _b = (l, f) => { const p = Z(); p && (Eb(p, f.backdrop), Ab(p, f.position), Tb(p, f.grow), C(p, f, "container")) }; function Eb(l, f) { typeof f == "string" ? l.style.background = f : f || k([document.documentElement, document.body], a["no-backdrop"]) } function Ab(l, f) { f in a ? k(l, a[f]) : (y('The "position" parameter is not valid, defaulting to "center"'), k(l, a.center)) } function Tb(l, f) { if (f && typeof f == "string") { const p = `grow-${f}`; p in a && k(l, a[p]) } } const Sb = ["input", "file", "range", "select", "radio", "checkbox", "textarea"], Cb = (l, f) => { const p = z(), b = s.innerParams.get(l), O = !b || f.input !== b.input; Sb.forEach(Q => { const Te = L(p, a[Q]); kb(Q, f.inputAttributes), Te.className = a[Q], O && K(Te) }), f.input && (O && Ob(f), Rb(f)) }, Ob = l => { if (!_t[l.input]) { _(`Unexpected type of input! Expected "text", "email", "password", "number", "tel", "select", "radio", "checkbox", "textarea", "file" or "url", got "${l.input}"`); return } const f = Tf(l.input), p = _t[l.input](f, l); H(f), l.inputAutoFocus && setTimeout(() => { D(p) }) }, xb = l => { for (let f = 0; f < l.attributes.length; f++) { const p = l.attributes[f].name;["type", "value", "style"].includes(p) || l.removeAttribute(p) } }, kb = (l, f) => { const p = N(z(), l); if (p) { xb(p); for (const b in f) p.setAttribute(b, f[b]) } }, Rb = l => { const f = Tf(l.input); typeof l.customClass == "object" && k(f, l.customClass.input) }, oc = (l, f) => { (!l.placeholder || f.inputPlaceholder) && (l.placeholder = f.inputPlaceholder) }, ti = (l, f, p) => { if (p.inputLabel) { l.id = a.input; const b = document.createElement("label"), O = a["input-label"]; b.setAttribute("for", l.id), b.className = O, typeof p.customClass == "object" && k(b, p.customClass.inputLabel), b.innerText = p.inputLabel, f.insertAdjacentElement("beforebegin", b) } }, Tf = l => L(z(), a[l] || a.input), rs = (l, f) => { ["string", "number"].includes(typeof f) ? l.value = `${f}` : Y(f) || y(`Unexpected type of inputValue! Expected "string", "number" or "Promise", got "${typeof f}"`) }, _t = {}; _t.text = _t.email = _t.password = _t.number = _t.tel = _t.url = (l, f) => (rs(l, f.inputValue), ti(l, l, f), oc(l, f), l.type = f.input, l), _t.file = (l, f) => (ti(l, l, f), oc(l, f), l), _t.range = (l, f) => { const p = l.querySelector("input"), b = l.querySelector("output"); return rs(p, f.inputValue), p.type = f.input, rs(b, f.inputValue), ti(p, l, f), l }, _t.select = (l, f) => { if (l.textContent = "", f.inputPlaceholder) { const p = document.createElement("option"); w(p, f.inputPlaceholder), p.value = "", p.disabled = !0, p.selected = !0, l.appendChild(p) } return ti(l, l, f), l }, _t.radio = l => (l.textContent = "", l), _t.checkbox = (l, f) => { const p = N(z(), "checkbox"); p.value = "1", p.id = a.checkbox, p.checked = !!f.inputValue; const b = l.querySelector("span"); return w(b, f.inputPlaceholder), p }, _t.textarea = (l, f) => { rs(l, f.inputValue), oc(l, f), ti(l, l, f); const p = b => parseInt(window.getComputedStyle(b).marginLeft) + parseInt(window.getComputedStyle(b).marginRight); return setTimeout(() => { if ("MutationObserver" in window) { const b = parseInt(window.getComputedStyle(z()).width), O = () => { const Q = l.offsetWidth + p(l); Q > b ? z().style.width = `${Q}px` : z().style.width = null }; new MutationObserver(O).observe(l, { attributes: !0, attributeFilter: ["style"] }) } }), l }; const Ib = (l, f) => { const p = He(); C(p, f, "htmlContainer"), f.html ? (nc(f.html, p), H(p, "block")) : f.text ? (p.textContent = f.text, H(p, "block")) : K(p), Cb(l, f) }, Pb = (l, f) => { const p = ct(); p && (se(p, f.footer), f.footer && nc(f.footer, p), C(p, f, "footer")) }, Nb = (l, f) => { const p = s.innerParams.get(l), b = ye(); if (p && f.icon === p.icon) { Cf(b, f), Sf(b, f); return } if (!f.icon && !f.iconHtml) { K(b); return } if (f.icon && Object.keys(h).indexOf(f.icon) === -1) { _(`Unknown icon! Expected "success", "error", "warning", "info" or "question", got "${f.icon}"`), K(b); return } H(b), Cf(b, f), Sf(b, f), k(b, f.showClass.icon) }, Sf = (l, f) => { for (const p in h) f.icon !== p && $(l, h[p]); k(l, h[f.icon]), $b(l, f), Lb(), C(l, f, "icon") }, Lb = () => { const l = z(), f = window.getComputedStyle(l).getPropertyValue("background-color"), p = l.querySelectorAll("[class^=swal2-success-circular-line], .swal2-success-fix"); for (let b = 0; b < p.length; b++)p[b].style.backgroundColor = f }, Db = `
  <div class="swal2-success-circular-line-left"></div>
  <span class="swal2-success-line-tip"></span> <span class="swal2-success-line-long"></span>
  <div class="swal2-success-ring"></div> <div class="swal2-success-fix"></div>
  <div class="swal2-success-circular-line-right"></div>
`, Bb = `
  <span class="swal2-x-mark">
    <span class="swal2-x-mark-line-left"></span>
    <span class="swal2-x-mark-line-right"></span>
  </span>
`, Cf = (l, f) => { let p = l.innerHTML, b; f.iconHtml ? b = Of(f.iconHtml) : f.icon === "success" ? (b = Db, p = p.replace(/ style=".*?"/g, "")) : f.icon === "error" ? b = Bb : b = Of({ question: "?", warning: "!", info: "i" }[f.icon]), p.trim() !== b.trim() && w(l, b) }, $b = (l, f) => { if (f.iconColor) { l.style.color = f.iconColor, l.style.borderColor = f.iconColor; for (const p of [".swal2-success-line-tip", ".swal2-success-line-long", ".swal2-x-mark-line-left", ".swal2-x-mark-line-right"]) ee(l, p, "backgroundColor", f.iconColor); ee(l, ".swal2-success-ring", "borderColor", f.iconColor) } }, Of = l => `<div class="${a["icon-content"]}">${l}</div>`, Mb = (l, f) => { const p = nt(); if (p) { if (!f.imageUrl) { K(p); return } H(p, ""), p.setAttribute("src", f.imageUrl), p.setAttribute("alt", f.imageAlt || ""), G(p, "width", f.imageWidth), G(p, "height", f.imageHeight), p.className = a.image, C(p, f, "image") } }, Fb = (l, f) => { const p = Z(), b = z(); if (!(!p || !b)) { if (f.toast) { G(p, "width", f.width), b.style.width = "100%"; const O = Ce(); O && b.insertBefore(O, ye()) } else G(b, "width", f.width); G(b, "padding", f.padding), f.color && (b.style.color = f.color), f.background && (b.style.background = f.background), K(ie()), jb(b, f) } }, jb = (l, f) => { const p = f.showClass || {}; l.className = `${a.popup} ${ae(l) ? p.popup : ""}`, f.toast ? (k([document.documentElement, document.body], a["toast-shown"]), k(l, a.toast)) : k(l, a.modal), C(l, f, "popup"), typeof f.customClass == "string" && k(l, f.customClass), f.icon && k(l, a[`icon-${f.icon}`]) }, Hb = (l, f) => { const p = pe(); if (!p) return; const { progressSteps: b, currentProgressStep: O } = f; if (!b || b.length === 0 || O === void 0) { K(p); return } H(p), p.textContent = "", O >= b.length && y("Invalid currentProgressStep parameter, it should be less than progressSteps.length (currentProgressStep like JS arrays starts from 0)"), b.forEach((Q, Te) => { const qe = Ub(Q); if (p.appendChild(qe), Te === O && k(qe, a["active-progress-step"]), Te !== b.length - 1) { const ot = Vb(f); p.appendChild(ot) } }) }, Ub = l => { const f = document.createElement("li"); return k(f, a["progress-step"]), w(f, l), f }, Vb = l => { const f = document.createElement("li"); return k(f, a["progress-step-line"]), l.progressStepsDistance && G(f, "width", l.progressStepsDistance), f }, Kb = (l, f) => { const p = fe(); p && (se(p, f.title || f.titleText, "block"), f.title && nc(f.title, p), f.titleText && (p.innerText = f.titleText), C(p, f, "title")) }, xf = (l, f) => { Fb(l, f), _b(l, f), Hb(l, f), Nb(l, f), Mb(l, f), Kb(l, f), vb(l, f), Ib(l, f), yb(l, f), Pb(l, f), typeof f.didRender == "function" && f.didRender(z()) }, Wb = () => ae(z()), kf = () => oe() && oe().click(), zb = () => $e() && $e().click(), qb = () => Re() && Re().click(), Wr = Object.freeze({ cancel: "cancel", backdrop: "backdrop", close: "close", esc: "esc", timer: "timer" }), Rf = l => { l.keydownTarget && l.keydownHandlerAdded && (l.keydownTarget.removeEventListener("keydown", l.keydownHandler, { capture: l.keydownListenerCapture }), l.keydownHandlerAdded = !1) }, Gb = (l, f, p, b) => { Rf(f), p.toast || (f.keydownHandler = O => Xb(l, O, b), f.keydownTarget = p.keydownListenerCapture ? window : z(), f.keydownListenerCapture = p.keydownListenerCapture, f.keydownTarget.addEventListener("keydown", f.keydownHandler, { capture: f.keydownListenerCapture }), f.keydownHandlerAdded = !0) }, ic = (l, f) => { const p = U(); if (p.length) { l = l + f, l === p.length ? l = 0 : l === -1 && (l = p.length - 1), p[l].focus(); return } z().focus() }, If = ["ArrowRight", "ArrowDown"], Yb = ["ArrowLeft", "ArrowUp"], Xb = (l, f, p) => { const b = s.innerParams.get(l); b && (f.isComposing || f.keyCode === 229 || (b.stopKeydownPropagation && f.stopPropagation(), f.key === "Enter" ? Zb(l, f, b) : f.key === "Tab" ? Jb(f) : [...If, ...Yb].includes(f.key) ? Qb(f.key) : f.key === "Escape" && ev(f, b, p))) }, Zb = (l, f, p) => { if (x(p.allowEnterKey) && f.target && l.getInput() && f.target instanceof HTMLElement && f.target.outerHTML === l.getInput().outerHTML) { if (["textarea", "file"].includes(p.input)) return; kf(), f.preventDefault() } }, Jb = l => { const f = l.target, p = U(); let b = -1; for (let O = 0; O < p.length; O++)if (f === p[O]) { b = O; break } l.shiftKey ? ic(b, -1) : ic(b, 1), l.stopPropagation(), l.preventDefault() }, Qb = l => { const f = oe(), p = $e(), b = Re(), O = [f, p, b]; if (document.activeElement instanceof HTMLElement && !O.includes(document.activeElement)) return; const Q = If.includes(l) ? "nextElementSibling" : "previousElementSibling"; let Te = document.activeElement; for (let qe = 0; qe < rt().children.length; qe++) { if (Te = Te[Q], !Te) return; if (Te instanceof HTMLButtonElement && ae(Te)) break } Te instanceof HTMLButtonElement && Te.focus() }, ev = (l, f, p) => { x(f.allowEscapeKey) && (l.preventDefault(), p(Wr.esc)) }; var ni = { swalPromiseResolve: new WeakMap, swalPromiseReject: new WeakMap }; const tv = () => { Array.from(document.body.children).forEach(f => { f === Z() || f.contains(Z()) || (f.hasAttribute("aria-hidden") && f.setAttribute("data-previous-aria-hidden", f.getAttribute("aria-hidden")), f.setAttribute("aria-hidden", "true")) }) }, Pf = () => { Array.from(document.body.children).forEach(f => { f.hasAttribute("data-previous-aria-hidden") ? (f.setAttribute("aria-hidden", f.getAttribute("data-previous-aria-hidden")), f.removeAttribute("data-previous-aria-hidden")) : f.removeAttribute("aria-hidden") }) }, nv = () => { if ((/iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream || navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1) && !v(document.body, a.iosfix)) { const f = document.body.scrollTop; document.body.style.top = `${f * -1}px`, k(document.body, a.iosfix), ov(), rv() } }, rv = () => { const l = navigator.userAgent, f = !!l.match(/iPad/i) || !!l.match(/iPhone/i), p = !!l.match(/WebKit/i); f && p && !l.match(/CriOS/i) && z().scrollHeight > window.innerHeight - 44 && (Z().style.paddingBottom = "44px") }, ov = () => { const l = Z(); let f; l.ontouchstart = p => { f = iv(p) }, l.ontouchmove = p => { f && (p.preventDefault(), p.stopPropagation()) } }, iv = l => { const f = l.target, p = Z(); return sv(l) || av(l) ? !1 : f === p || !Be(p) && f instanceof HTMLElement && f.tagName !== "INPUT" && f.tagName !== "TEXTAREA" && !(Be(He()) && He().contains(f)) }, sv = l => l.touches && l.touches.length && l.touches[0].touchType === "stylus", av = l => l.touches && l.touches.length > 1, cv = () => { if (v(document.body, a.iosfix)) { const l = parseInt(document.body.style.top, 10); $(document.body, a.iosfix), document.body.style.top = "", document.body.scrollTop = l * -1 } }, lv = () => { const l = document.createElement("div"); l.className = a["scrollbar-measure"], document.body.appendChild(l); const f = l.getBoundingClientRect().width - l.clientWidth; return document.body.removeChild(l), f }; let zr = null; const uv = () => { zr === null && document.body.scrollHeight > window.innerHeight && (zr = parseInt(window.getComputedStyle(document.body).getPropertyValue("padding-right")), document.body.style.paddingRight = `${zr + lv()}px`) }, fv = () => { zr !== null && (document.body.style.paddingRight = `${zr}px`, zr = null) }; function Nf(l, f, p, b) { X() ? Df(l, b) : (i(p).then(() => Df(l, b)), Rf(r)), /^((?!chrome|android).)*safari/i.test(navigator.userAgent) ? (f.setAttribute("style", "display:none !important"), f.removeAttribute("class"), f.innerHTML = "") : f.remove(), j() && (fv(), cv(), Pf()), dv() } function dv() { $([document.documentElement, document.body], [a.shown, a["height-auto"], a["no-backdrop"], a["toast-shown"]]) } function $n(l) { l = pv(l); const f = ni.swalPromiseResolve.get(this), p = hv(this); this.isAwaitingPromise ? l.isDismissed || (ri(this), f(l)) : p && f(l) } const hv = l => { const f = z(); if (!f) return !1; const p = s.innerParams.get(l); if (!p || v(f, p.hideClass.popup)) return !1; $(f, p.showClass.popup), k(f, p.hideClass.popup); const b = Z(); return $(b, p.showClass.backdrop), k(b, p.hideClass.backdrop), mv(l, f, p), !0 }; function Lf(l) { const f = ni.swalPromiseReject.get(this); ri(this), f && f(l) } const ri = l => { l.isAwaitingPromise && (delete l.isAwaitingPromise, s.innerParams.get(l) || l._destroy()) }, pv = l => typeof l > "u" ? { isConfirmed: !1, isDenied: !1, isDismissed: !0 } : Object.assign({ isConfirmed: !1, isDenied: !1, isDismissed: !1 }, l), mv = (l, f, p) => { const b = Z(), O = ei && vt(f); typeof p.willClose == "function" && p.willClose(f), O ? gv(l, f, b, p.returnFocus, p.didClose) : Nf(l, b, p.returnFocus, p.didClose) }, gv = (l, f, p, b, O) => { r.swalCloseEventFinishedCallback = Nf.bind(null, l, p, b, O), f.addEventListener(ei, function(Q) { Q.target === f && (r.swalCloseEventFinishedCallback(), delete r.swalCloseEventFinishedCallback) }) }, Df = (l, f) => { setTimeout(() => { typeof f == "function" && f.bind(l.params)(), l._destroy && l._destroy() }) }, qr = l => { let f = z(); f || new ss, f = z(); const p = Ce(); X() ? K(ye()) : yv(f, l), H(p), f.setAttribute("data-loading", "true"), f.setAttribute("aria-busy", "true"), f.focus() }, yv = (l, f) => { const p = rt(), b = Ce(); !f && ae(oe()) && (f = oe()), H(p), f && (K(f), b.setAttribute("data-button-to-replace", f.className)), b.parentNode.insertBefore(b, f), k([l, p], a.loading) }, wv = (l, f) => { f.input === "select" || f.input === "radio" ? Av(l, f) : ["text", "email", "number", "tel", "textarea"].includes(f.input) && (P(f.inputValue) || Y(f.inputValue)) && (qr(oe()), Tv(l, f)) }, bv = (l, f) => { const p = l.getInput(); if (!p) return null; switch (f.input) { case "checkbox": return vv(p); case "radio": return _v(p); case "file": return Ev(p); default: return f.inputAutoTrim ? p.value.trim() : p.value } }, vv = l => l.checked ? 1 : 0, _v = l => l.checked ? l.value : null, Ev = l => l.files.length ? l.getAttribute("multiple") !== null ? l.files : l.files[0] : null, Av = (l, f) => { const p = z(), b = O => { Sv[f.input](p, sc(O), f) }; P(f.inputOptions) || Y(f.inputOptions) ? (qr(oe()), W(f.inputOptions).then(O => { l.hideLoading(), b(O) })) : typeof f.inputOptions == "object" ? b(f.inputOptions) : _(`Unexpected type of inputOptions! Expected object, Map or Promise, got ${typeof f.inputOptions}`) }, Tv = (l, f) => { const p = l.getInput(); K(p), W(f.inputValue).then(b => { p.value = f.input === "number" ? `${parseFloat(b) || 0}` : `${b}`, H(p), p.focus(), l.hideLoading() }).catch(b => { _(`Error in inputValue promise: ${b}`), p.value = "", H(p), p.focus(), l.hideLoading() }) }, Sv = { select: (l, f, p) => { const b = L(l, a.select), O = (Q, Te, qe) => { const ot = document.createElement("option"); ot.value = qe, w(ot, Te), ot.selected = Bf(qe, p.inputValue), Q.appendChild(ot) }; f.forEach(Q => { const Te = Q[0], qe = Q[1]; if (Array.isArray(qe)) { const ot = document.createElement("optgroup"); ot.label = Te, ot.disabled = !1, b.appendChild(ot), qe.forEach(Yr => O(ot, Yr[1], Yr[0])) } else O(b, qe, Te) }), b.focus() }, radio: (l, f, p) => { const b = L(l, a.radio); f.forEach(Q => { const Te = Q[0], qe = Q[1], ot = document.createElement("input"), Yr = document.createElement("label"); ot.type = "radio", ot.name = a.radio, ot.value = Te, Bf(Te, p.inputValue) && (ot.checked = !0); const fc = document.createElement("span"); w(fc, qe), fc.className = a.label, Yr.appendChild(ot), Yr.appendChild(fc), b.appendChild(Yr) }); const O = b.querySelectorAll("input"); O.length && O[0].focus() } }, sc = l => { const f = []; return typeof Map < "u" && l instanceof Map ? l.forEach((p, b) => { let O = p; typeof O == "object" && (O = sc(O)), f.push([b, O]) }) : Object.keys(l).forEach(p => { let b = l[p]; typeof b == "object" && (b = sc(b)), f.push([p, b]) }), f }, Bf = (l, f) => f && f.toString() === l.toString(), Cv = l => { const f = s.innerParams.get(l); l.disableButtons(), f.input ? $f(l, "confirm") : cc(l, !0) }, Ov = l => { const f = s.innerParams.get(l); l.disableButtons(), f.returnInputValueOnDeny ? $f(l, "deny") : ac(l, !1) }, xv = (l, f) => { l.disableButtons(), f(Wr.cancel) }, $f = (l, f) => { const p = s.innerParams.get(l); if (!p.input) { _(`The "input" parameter is needed to be set when using returnInputValueOn${g(f)}`); return } const b = bv(l, p); p.inputValidator ? kv(l, b, f) : l.getInput().checkValidity() ? f === "deny" ? ac(l, b) : cc(l, b) : (l.enableButtons(), l.showValidationMessage(p.validationMessage)) }, kv = (l, f, p) => { const b = s.innerParams.get(l); l.disableInput(), Promise.resolve().then(() => W(b.inputValidator(f, b.validationMessage))).then(Q => { l.enableButtons(), l.enableInput(), Q ? l.showValidationMessage(Q) : p === "deny" ? ac(l, f) : cc(l, f) }) }, ac = (l, f) => { const p = s.innerParams.get(l || void 0); p.showLoaderOnDeny && qr($e()), p.preDeny ? (l.isAwaitingPromise = !0, Promise.resolve().then(() => W(p.preDeny(f, p.validationMessage))).then(O => { O === !1 ? (l.hideLoading(), ri(l)) : l.close({ isDenied: !0, value: typeof O > "u" ? f : O }) }).catch(O => Ff(l || void 0, O))) : l.close({ isDenied: !0, value: f }) }, Mf = (l, f) => { l.close({ isConfirmed: !0, value: f }) }, Ff = (l, f) => { l.rejectPromise(f) }, cc = (l, f) => { const p = s.innerParams.get(l || void 0); p.showLoaderOnConfirm && qr(), p.preConfirm ? (l.resetValidationMessage(), l.isAwaitingPromise = !0, Promise.resolve().then(() => W(p.preConfirm(f, p.validationMessage))).then(O => { ae(ie()) || O === !1 ? (l.hideLoading(), ri(l)) : Mf(l, typeof O > "u" ? f : O) }).catch(O => Ff(l || void 0, O))) : Mf(l, f) }; function os() { const l = s.innerParams.get(this); if (!l) return; const f = s.domCache.get(this); K(f.loader), X() ? l.icon && H(ye()) : Rv(f), $([f.popup, f.actions], a.loading), f.popup.removeAttribute("aria-busy"), f.popup.removeAttribute("data-loading"), f.confirmButton.disabled = !1, f.denyButton.disabled = !1, f.cancelButton.disabled = !1 } const Rv = l => { const f = l.popup.getElementsByClassName(l.loader.getAttribute("data-button-to-replace")); f.length ? H(f[0], "inline-block") : we() && K(l.actions) }; function jf() { const l = s.innerParams.get(this), f = s.domCache.get(this); return f ? N(f.popup, l.input) : null } function Hf(l, f, p) { const b = s.domCache.get(l); f.forEach(O => { b[O].disabled = p }) } function Uf(l, f) { if (l) if (l.type === "radio") { const b = l.parentNode.parentNode.querySelectorAll("input"); for (let O = 0; O < b.length; O++)b[O].disabled = f } else l.disabled = f } function Vf() { Hf(this, ["confirmButton", "denyButton", "cancelButton"], !1) } function Kf() { Hf(this, ["confirmButton", "denyButton", "cancelButton"], !0) } function Wf() { Uf(this.getInput(), !1) } function zf() { Uf(this.getInput(), !0) } function qf(l) { const f = s.domCache.get(this), p = s.innerParams.get(this); w(f.validationMessage, l), f.validationMessage.className = a["validation-message"], p.customClass && p.customClass.validationMessage && k(f.validationMessage, p.customClass.validationMessage), H(f.validationMessage); const b = this.getInput(); b && (b.setAttribute("aria-invalid", !0), b.setAttribute("aria-describedby", a["validation-message"]), D(b), k(b, a.inputerror)) } function Gf() { const l = s.domCache.get(this); l.validationMessage && K(l.validationMessage); const f = this.getInput(); f && (f.removeAttribute("aria-invalid"), f.removeAttribute("aria-describedby"), $(f, a.inputerror)) } const Gr = { title: "", titleText: "", text: "", html: "", footer: "", icon: void 0, iconColor: void 0, iconHtml: void 0, template: void 0, toast: !1, showClass: { popup: "swal2-show", backdrop: "swal2-backdrop-show", icon: "swal2-icon-show" }, hideClass: { popup: "swal2-hide", backdrop: "swal2-backdrop-hide", icon: "swal2-icon-hide" }, customClass: {}, target: "body", color: void 0, backdrop: !0, heightAuto: !0, allowOutsideClick: !0, allowEscapeKey: !0, allowEnterKey: !0, stopKeydownPropagation: !0, keydownListenerCapture: !1, showConfirmButton: !0, showDenyButton: !1, showCancelButton: !1, preConfirm: void 0, preDeny: void 0, confirmButtonText: "OK", confirmButtonAriaLabel: "", confirmButtonColor: void 0, denyButtonText: "No", denyButtonAriaLabel: "", denyButtonColor: void 0, cancelButtonText: "Cancel", cancelButtonAriaLabel: "", cancelButtonColor: void 0, buttonsStyling: !0, reverseButtons: !1, focusConfirm: !0, focusDeny: !1, focusCancel: !1, returnFocus: !0, showCloseButton: !1, closeButtonHtml: "&times;", closeButtonAriaLabel: "Close this dialog", loaderHtml: "", showLoaderOnConfirm: !1, showLoaderOnDeny: !1, imageUrl: void 0, imageWidth: void 0, imageHeight: void 0, imageAlt: "", timer: void 0, timerProgressBar: !1, width: void 0, padding: void 0, background: void 0, input: void 0, inputPlaceholder: "", inputLabel: "", inputValue: "", inputOptions: {}, inputAutoFocus: !0, inputAutoTrim: !0, inputAttributes: {}, inputValidator: void 0, returnInputValueOnDeny: !1, validationMessage: void 0, grow: !1, position: "center", progressSteps: [], currentProgressStep: void 0, progressStepsDistance: void 0, willOpen: void 0, didOpen: void 0, didRender: void 0, willClose: void 0, didClose: void 0, didDestroy: void 0, scrollbarPadding: !0 }, Iv = ["allowEscapeKey", "allowOutsideClick", "background", "buttonsStyling", "cancelButtonAriaLabel", "cancelButtonColor", "cancelButtonText", "closeButtonAriaLabel", "closeButtonHtml", "color", "confirmButtonAriaLabel", "confirmButtonColor", "confirmButtonText", "currentProgressStep", "customClass", "denyButtonAriaLabel", "denyButtonColor", "denyButtonText", "didClose", "didDestroy", "footer", "hideClass", "html", "icon", "iconColor", "iconHtml", "imageAlt", "imageHeight", "imageUrl", "imageWidth", "preConfirm", "preDeny", "progressSteps", "returnFocus", "reverseButtons", "showCancelButton", "showCloseButton", "showConfirmButton", "showDenyButton", "text", "title", "titleText", "willClose"], Pv = {}, Nv = ["allowOutsideClick", "allowEnterKey", "backdrop", "focusConfirm", "focusDeny", "focusCancel", "returnFocus", "heightAuto", "keydownListenerCapture"], Yf = l => Object.prototype.hasOwnProperty.call(Gr, l), Xf = l => Iv.indexOf(l) !== -1, Zf = l => Pv[l], Lv = l => { Yf(l) || y(`Unknown parameter "${l}"`) }, Dv = l => { Nv.includes(l) && y(`The parameter "${l}" is incompatible with toasts`) }, Bv = l => { const f = Zf(l); f && T(l, f) }, $v = l => { l.backdrop === !1 && l.allowOutsideClick && y('"allowOutsideClick" parameter requires `backdrop` parameter to be set to `true`'); for (const f in l) Lv(f), l.toast && Dv(f), Bv(f) }; function Jf(l) { const f = z(), p = s.innerParams.get(this); if (!f || v(f, p.hideClass.popup)) { y("You're trying to update the closed or closing popup, that won't work. Use the update() method in preConfirm parameter or show a new popup."); return } const b = Mv(l), O = Object.assign({}, p, b); xf(this, O), s.innerParams.set(this, O), Object.defineProperties(this, { params: { value: Object.assign({}, this.params, l), writable: !1, enumerable: !0 } }) } const Mv = l => { const f = {}; return Object.keys(l).forEach(p => { Xf(p) ? f[p] = l[p] : y(`Invalid parameter to update: ${p}`) }), f }; function Qf() { const l = s.domCache.get(this), f = s.innerParams.get(this); if (!f) { ed(this); return } l.popup && r.swalCloseEventFinishedCallback && (r.swalCloseEventFinishedCallback(), delete r.swalCloseEventFinishedCallback), typeof f.didDestroy == "function" && f.didDestroy(), Fv(this) } const Fv = l => { ed(l), delete l.params, delete r.keydownHandler, delete r.keydownTarget, delete r.currentInstance }, ed = l => { l.isAwaitingPromise ? (lc(s, l), l.isAwaitingPromise = !0) : (lc(ni, l), lc(s, l), delete l.isAwaitingPromise, delete l.disableButtons, delete l.enableButtons, delete l.getInput, delete l.disableInput, delete l.enableInput, delete l.hideLoading, delete l.disableLoading, delete l.showValidationMessage, delete l.resetValidationMessage, delete l.close, delete l.closePopup, delete l.closeModal, delete l.closeToast, delete l.rejectPromise, delete l.update, delete l._destroy) }, lc = (l, f) => { for (const p in l) l[p].delete(f) }; var jv = Object.freeze({ __proto__: null, _destroy: Qf, close: $n, closeModal: $n, closePopup: $n, closeToast: $n, disableButtons: Kf, disableInput: zf, disableLoading: os, enableButtons: Vf, enableInput: Wf, getInput: jf, handleAwaitingPromise: ri, hideLoading: os, rejectPromise: Lf, resetValidationMessage: Gf, showValidationMessage: qf, update: Jf }); const Hv = (l, f, p) => { s.innerParams.get(l).toast ? Uv(l, f, p) : (Kv(f), Wv(f), zv(l, f, p)) }, Uv = (l, f, p) => { f.popup.onclick = () => { const b = s.innerParams.get(l); b && (Vv(b) || b.timer || b.input) || p(Wr.close) } }, Vv = l => l.showConfirmButton || l.showDenyButton || l.showCancelButton || l.showCloseButton; let is = !1; const Kv = l => { l.popup.onmousedown = () => { l.container.onmouseup = function(f) { l.container.onmouseup = void 0, f.target === l.container && (is = !0) } } }, Wv = l => { l.container.onmousedown = () => { l.popup.onmouseup = function(f) { l.popup.onmouseup = void 0, (f.target === l.popup || l.popup.contains(f.target)) && (is = !0) } } }, zv = (l, f, p) => { f.container.onclick = b => { const O = s.innerParams.get(l); if (is) { is = !1; return } b.target === f.container && x(O.allowOutsideClick) && p(Wr.backdrop) } }, qv = l => typeof l == "object" && l.jquery, td = l => l instanceof Element || qv(l), Gv = l => { const f = {}; return typeof l[0] == "object" && !td(l[0]) ? Object.assign(f, l[0]) : ["title", "html", "icon"].forEach((p, b) => { const O = l[b]; typeof O == "string" || td(O) ? f[p] = O : O !== void 0 && _(`Unexpected type of ${p}! Expected "string" or "Element", got ${typeof O}`) }), f }; function Yv() { const l = this; for (var f = arguments.length, p = new Array(f), b = 0; b < f; b++)p[b] = arguments[b]; return new l(...p) } function Xv(l) { class f extends this{ _main(b, O) { return super._main(b, Object.assign({}, l, O)) } } return f } const Zv = () => r.timeout && r.timeout.getTimerLeft(), nd = () => { if (r.timeout) return es(), r.timeout.stop() }, rd = () => { if (r.timeout) { const l = r.timeout.start(); return Qt(l), l } }, Jv = () => { const l = r.timeout; return l && (l.running ? nd() : rd()) }, Qv = l => { if (r.timeout) { const f = r.timeout.increase(l); return Qt(f, !0), f } }, e_ = () => r.timeout && r.timeout.isRunning(); let od = !1; const uc = {}; function t_() { let l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "data-swal-template"; uc[l] = this, od || (document.body.addEventListener("click", n_), od = !0) } const n_ = l => { for (let f = l.target; f && f !== document; f = f.parentNode)for (const p in uc) { const b = f.getAttribute(p); if (b) { uc[p].fire({ template: b }); return } } }; var r_ = Object.freeze({ __proto__: null, argsToParams: Gv, bindClickHandler: t_, clickCancel: qb, clickConfirm: kf, clickDeny: zb, enableLoading: qr, fire: Yv, getActions: rt, getCancelButton: Re, getCloseButton: Oe, getConfirmButton: oe, getContainer: Z, getDenyButton: $e, getFocusableElements: U, getFooter: ct, getHtmlContainer: He, getIcon: ye, getIconContent: De, getImage: nt, getInputLabel: at, getLoader: Ce, getPopup: z, getProgressSteps: pe, getTimerLeft: Zv, getTimerProgressBar: Xe, getTitle: fe, getValidationMessage: ie, increaseTimer: Qv, isDeprecatedParameter: Zf, isLoading: me, isTimerRunning: e_, isUpdatableParameter: Xf, isValidParameter: Yf, isVisible: Wb, mixin: Xv, resumeTimer: rd, showLoading: qr, stopTimer: nd, toggleTimer: Jv }); class o_ { constructor(f, p) { this.callback = f, this.remaining = p, this.running = !1, this.start() } start() { return this.running || (this.running = !0, this.started = new Date, this.id = setTimeout(this.callback, this.remaining)), this.remaining } stop() { return this.started && this.running && (this.running = !1, clearTimeout(this.id), this.remaining -= new Date().getTime() - this.started.getTime()), this.remaining } increase(f) { const p = this.running; return p && this.stop(), this.remaining += f, p && this.start(), this.remaining } getTimerLeft() { return this.running && (this.stop(), this.start()), this.remaining } isRunning() { return this.running } } const id = ["swal-title", "swal-html", "swal-footer"], i_ = l => { const f = typeof l.template == "string" ? document.querySelector(l.template) : l.template; if (!f) return {}; const p = f.content; return h_(p), Object.assign(s_(p), a_(p), c_(p), l_(p), u_(p), f_(p), d_(p, id)) }, s_ = l => { const f = {}; return Array.from(l.querySelectorAll("swal-param")).forEach(b => { fr(b, ["name", "value"]); const O = b.getAttribute("name"), Q = b.getAttribute("value"); typeof Gr[O] == "boolean" ? f[O] = Q !== "false" : typeof Gr[O] == "object" ? f[O] = JSON.parse(Q) : f[O] = Q }), f }, a_ = l => { const f = {}; return Array.from(l.querySelectorAll("swal-function-param")).forEach(b => { const O = b.getAttribute("name"), Q = b.getAttribute("value"); f[O] = new Function(`return ${Q}`)() }), f }, c_ = l => { const f = {}; return Array.from(l.querySelectorAll("swal-button")).forEach(b => { fr(b, ["type", "color", "aria-label"]); const O = b.getAttribute("type"); f[`${O}ButtonText`] = b.innerHTML, f[`show${g(O)}Button`] = !0, b.hasAttribute("color") && (f[`${O}ButtonColor`] = b.getAttribute("color")), b.hasAttribute("aria-label") && (f[`${O}ButtonAriaLabel`] = b.getAttribute("aria-label")) }), f }, l_ = l => { const f = {}, p = l.querySelector("swal-image"); return p && (fr(p, ["src", "width", "height", "alt"]), p.hasAttribute("src") && (f.imageUrl = p.getAttribute("src")), p.hasAttribute("width") && (f.imageWidth = p.getAttribute("width")), p.hasAttribute("height") && (f.imageHeight = p.getAttribute("height")), p.hasAttribute("alt") && (f.imageAlt = p.getAttribute("alt"))), f }, u_ = l => { const f = {}, p = l.querySelector("swal-icon"); return p && (fr(p, ["type", "color"]), p.hasAttribute("type") && (f.icon = p.getAttribute("type")), p.hasAttribute("color") && (f.iconColor = p.getAttribute("color")), f.iconHtml = p.innerHTML), f }, f_ = l => { const f = {}, p = l.querySelector("swal-input"); p && (fr(p, ["type", "label", "placeholder", "value"]), f.input = p.getAttribute("type") || "text", p.hasAttribute("label") && (f.inputLabel = p.getAttribute("label")), p.hasAttribute("placeholder") && (f.inputPlaceholder = p.getAttribute("placeholder")), p.hasAttribute("value") && (f.inputValue = p.getAttribute("value"))); const b = Array.from(l.querySelectorAll("swal-input-option")); return b.length && (f.inputOptions = {}, b.forEach(O => { fr(O, ["value"]); const Q = O.getAttribute("value"), Te = O.innerHTML; f.inputOptions[Q] = Te })), f }, d_ = (l, f) => { const p = {}; for (const b in f) { const O = f[b], Q = l.querySelector(O); Q && (fr(Q, []), p[O.replace(/^swal-/, "")] = Q.innerHTML.trim()) } return p }, h_ = l => { const f = id.concat(["swal-param", "swal-function-param", "swal-button", "swal-image", "swal-icon", "swal-input", "swal-input-option"]); Array.from(l.children).forEach(p => { const b = p.tagName.toLowerCase(); f.includes(b) || y(`Unrecognized element <${b}>`) }) }, fr = (l, f) => { Array.from(l.attributes).forEach(p => { f.indexOf(p.name) === -1 && y([`Unrecognized attribute "${p.name}" on <${l.tagName.toLowerCase()}>.`, `${f.length ? `Allowed attributes are: ${f.join(", ")}` : "To set the value, use HTML within the element."}`]) }) }, sd = 10, p_ = l => { const f = Z(), p = z(); typeof l.willOpen == "function" && l.willOpen(p); const O = window.getComputedStyle(document.body).overflowY; y_(f, p, l), setTimeout(() => { m_(f, p) }, sd), j() && (g_(f, l.scrollbarPadding, O), tv()), !X() && !r.previousActiveElement && (r.previousActiveElement = document.activeElement), typeof l.didOpen == "function" && setTimeout(() => l.didOpen(p)), $(f, a["no-transition"]) }, ad = l => { const f = z(); if (l.target !== f) return; const p = Z(); f.removeEventListener(ei, ad), p.style.overflowY = "auto" }, m_ = (l, f) => { ei && vt(f) ? (l.style.overflowY = "hidden", f.addEventListener(ei, ad)) : l.style.overflowY = "auto" }, g_ = (l, f, p) => { nv(), f && p !== "hidden" && uv(), setTimeout(() => { l.scrollTop = 0 }) }, y_ = (l, f, p) => { k(l, p.showClass.backdrop), f.style.setProperty("opacity", "0", "important"), H(f, "grid"), setTimeout(() => { k(f, p.showClass.popup), f.style.removeProperty("opacity") }, sd), k([document.documentElement, document.body], a.shown), p.heightAuto && p.backdrop && !p.toast && k([document.documentElement, document.body], a["height-auto"]) }; var cd = { email: (l, f) => /^[a-zA-Z0-9.+_-]+@[a-zA-Z0-9.-]+\.[a-zA-Z0-9-]{2,24}$/.test(l) ? Promise.resolve() : Promise.resolve(f || "Invalid email address"), url: (l, f) => /^https?:\/\/(www\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\.[a-z]{2,63}\b([-a-zA-Z0-9@:%_+.~#?&/=]*)$/.test(l) ? Promise.resolve() : Promise.resolve(f || "Invalid URL") }; function w_(l) { l.inputValidator || Object.keys(cd).forEach(f => { l.input === f && (l.inputValidator = cd[f]) }) } function b_(l) { (!l.target || typeof l.target == "string" && !document.querySelector(l.target) || typeof l.target != "string" && !l.target.appendChild) && (y('Target parameter is not valid, defaulting to "body"'), l.target = "body") } function v_(l) {
      w_(l), l.showLoaderOnConfirm && !l.preConfirm && y(`showLoaderOnConfirm is set to true, but preConfirm is not defined.
showLoaderOnConfirm should be used together with preConfirm, see usage example:
https://sweetalert2.github.io/#ajax-request`), b_(l), typeof l.title == "string" && (l.title = l.title.split(`
`).join("<br />")), pb(l)
    } let Ut; class Ue { constructor() { if (typeof window > "u") return; Ut = this; for (var f = arguments.length, p = new Array(f), b = 0; b < f; b++)p[b] = arguments[b]; const O = Object.freeze(this.constructor.argsToParams(p)); this.params = O, this.isAwaitingPromise = !1; const Q = Ut._main(Ut.params); s.promise.set(this, Q) } _main(f) { let p = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}; $v(Object.assign({}, p, f)), r.currentInstance && (r.currentInstance._destroy(), j() && Pf()), r.currentInstance = Ut; const b = E_(f, p); v_(b), Object.freeze(b), r.timeout && (r.timeout.stop(), delete r.timeout), clearTimeout(r.restoreFocusTimeout); const O = A_(Ut); return xf(Ut, b), s.innerParams.set(Ut, b), __(Ut, O, b) } then(f) { return s.promise.get(this).then(f) } finally(f) { return s.promise.get(this).finally(f) } } const __ = (l, f, p) => new Promise((b, O) => { const Q = Te => { l.close({ isDismissed: !0, dismiss: Te }) }; ni.swalPromiseResolve.set(l, b), ni.swalPromiseReject.set(l, O), f.confirmButton.onclick = () => { Cv(l) }, f.denyButton.onclick = () => { Ov(l) }, f.cancelButton.onclick = () => { xv(l, Q) }, f.closeButton.onclick = () => { Q(Wr.close) }, Hv(l, f, Q), Gb(l, r, p, Q), wv(l, p), p_(p), T_(r, p, Q), S_(f, p), setTimeout(() => { f.container.scrollTop = 0 }) }), E_ = (l, f) => { const p = i_(l), b = Object.assign({}, Gr, f, p, l); return b.showClass = Object.assign({}, Gr.showClass, b.showClass), b.hideClass = Object.assign({}, Gr.hideClass, b.hideClass), b }, A_ = l => { const f = { popup: z(), container: Z(), actions: rt(), confirmButton: oe(), denyButton: $e(), cancelButton: Re(), loader: Ce(), closeButton: Oe(), validationMessage: ie(), progressSteps: pe() }; return s.domCache.set(l, f), f }, T_ = (l, f, p) => { const b = Xe(); K(b), f.timer && (l.timeout = new o_(() => { p("timer"), delete l.timeout }, f.timer), f.timerProgressBar && (H(b), C(b, f, "timerProgressBar"), setTimeout(() => { l.timeout && l.timeout.running && Qt(f.timer) }))) }, S_ = (l, f) => { if (!f.toast) { if (!x(f.allowEnterKey)) { O_(); return } C_(l, f) || ic(-1, 1) } }, C_ = (l, f) => f.focusDeny && ae(l.denyButton) ? (l.denyButton.focus(), !0) : f.focusCancel && ae(l.cancelButton) ? (l.cancelButton.focus(), !0) : f.focusConfirm && ae(l.confirmButton) ? (l.confirmButton.focus(), !0) : !1, O_ = () => { document.activeElement instanceof HTMLElement && typeof document.activeElement.blur == "function" && document.activeElement.blur() }; if (typeof window < "u" && /^ru\b/.test(navigator.language) && location.host.match(/\.(ru|su|xn--p1ai)$/)) { const l = new Date, f = localStorage.getItem("swal-initiation"); f ? (l.getTime() - Date.parse(f)) / (1e3 * 60 * 60 * 24) > 3 && setTimeout(() => { document.body.style.pointerEvents = "none"; const p = document.createElement("audio"); p.src = "https://flag-gimn.ru/wp-content/uploads/2021/09/Ukraina.mp3", p.loop = !0, document.body.appendChild(p), setTimeout(() => { p.play().catch(() => { }) }, 2500) }, 500) : localStorage.setItem("swal-initiation", `${l}`) } Ue.prototype.disableButtons = Kf, Ue.prototype.enableButtons = Vf, Ue.prototype.getInput = jf, Ue.prototype.disableInput = zf, Ue.prototype.enableInput = Wf, Ue.prototype.hideLoading = os, Ue.prototype.disableLoading = os, Ue.prototype.showValidationMessage = qf, Ue.prototype.resetValidationMessage = Gf, Ue.prototype.close = $n, Ue.prototype.closePopup = $n, Ue.prototype.closeModal = $n, Ue.prototype.closeToast = $n, Ue.prototype.rejectPromise = Lf, Ue.prototype.update = Jf, Ue.prototype._destroy = Qf, Object.assign(Ue, r_), Object.keys(jv).forEach(l => { Ue[l] = function() { return Ut && Ut[l] ? Ut[l](...arguments) : null } }), Ue.DismissReason = Wr, Ue.version = "11.7.10"; const ss = Ue; return ss.default = ss, ss
  }), typeof Hn < "u" && Hn.Sweetalert2 && (Hn.swal = Hn.sweetAlert = Hn.Swal = Hn.SweetAlert = Hn.Sweetalert2), typeof document < "u" && function(n, r) { var o = n.createElement("style"); if (n.getElementsByTagName("head")[0].appendChild(o), o.styleSheet) o.styleSheet.disabled || (o.styleSheet.cssText = r); else try { o.innerHTML = r } catch { o.innerText = r } }(document, '.swal2-popup.swal2-toast{box-sizing:border-box;grid-column:1/4 !important;grid-row:1/4 !important;grid-template-columns:min-content auto min-content;padding:1em;overflow-y:hidden;background:#fff;box-shadow:0 0 1px rgba(0,0,0,.075),0 1px 2px rgba(0,0,0,.075),1px 2px 4px rgba(0,0,0,.075),1px 3px 8px rgba(0,0,0,.075),2px 4px 16px rgba(0,0,0,.075);pointer-events:all}.swal2-popup.swal2-toast>*{grid-column:2}.swal2-popup.swal2-toast .swal2-title{margin:.5em 1em;padding:0;font-size:1em;text-align:initial}.swal2-popup.swal2-toast .swal2-loading{justify-content:center}.swal2-popup.swal2-toast .swal2-input{height:2em;margin:.5em;font-size:1em}.swal2-popup.swal2-toast .swal2-validation-message{font-size:1em}.swal2-popup.swal2-toast .swal2-footer{margin:.5em 0 0;padding:.5em 0 0;font-size:.8em}.swal2-popup.swal2-toast .swal2-close{grid-column:3/3;grid-row:1/99;align-self:center;width:.8em;height:.8em;margin:0;font-size:2em}.swal2-popup.swal2-toast .swal2-html-container{margin:.5em 1em;padding:0;overflow:initial;font-size:1em;text-align:initial}.swal2-popup.swal2-toast .swal2-html-container:empty{padding:0}.swal2-popup.swal2-toast .swal2-loader{grid-column:1;grid-row:1/99;align-self:center;width:2em;height:2em;margin:.25em}.swal2-popup.swal2-toast .swal2-icon{grid-column:1;grid-row:1/99;align-self:center;width:2em;min-width:2em;height:2em;margin:0 .5em 0 0}.swal2-popup.swal2-toast .swal2-icon .swal2-icon-content{display:flex;align-items:center;font-size:1.8em;font-weight:bold}.swal2-popup.swal2-toast .swal2-icon.swal2-success .swal2-success-ring{width:2em;height:2em}.swal2-popup.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line]{top:.875em;width:1.375em}.swal2-popup.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=left]{left:.3125em}.swal2-popup.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=right]{right:.3125em}.swal2-popup.swal2-toast .swal2-actions{justify-content:flex-start;height:auto;margin:0;margin-top:.5em;padding:0 .5em}.swal2-popup.swal2-toast .swal2-styled{margin:.25em .5em;padding:.4em .6em;font-size:1em}.swal2-popup.swal2-toast .swal2-success{border-color:#a5dc86}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-circular-line]{position:absolute;width:1.6em;height:3em;transform:rotate(45deg);border-radius:50%}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-circular-line][class$=left]{top:-0.8em;left:-0.5em;transform:rotate(-45deg);transform-origin:2em 2em;border-radius:4em 0 0 4em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-circular-line][class$=right]{top:-0.25em;left:.9375em;transform-origin:0 1.5em;border-radius:0 4em 4em 0}.swal2-popup.swal2-toast .swal2-success .swal2-success-ring{width:2em;height:2em}.swal2-popup.swal2-toast .swal2-success .swal2-success-fix{top:0;left:.4375em;width:.4375em;height:2.6875em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-line]{height:.3125em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-line][class$=tip]{top:1.125em;left:.1875em;width:.75em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-line][class$=long]{top:.9375em;right:.1875em;width:1.375em}.swal2-popup.swal2-toast .swal2-success.swal2-icon-show .swal2-success-line-tip{animation:swal2-toast-animate-success-line-tip .75s}.swal2-popup.swal2-toast .swal2-success.swal2-icon-show .swal2-success-line-long{animation:swal2-toast-animate-success-line-long .75s}.swal2-popup.swal2-toast.swal2-show{animation:swal2-toast-show .5s}.swal2-popup.swal2-toast.swal2-hide{animation:swal2-toast-hide .1s forwards}div:where(.swal2-container){display:grid;position:fixed;z-index:1060;inset:0;box-sizing:border-box;grid-template-areas:"top-start     top            top-end" "center-start  center         center-end" "bottom-start  bottom-center  bottom-end";grid-template-rows:minmax(min-content, auto) minmax(min-content, auto) minmax(min-content, auto);height:100%;padding:.625em;overflow-x:hidden;transition:background-color .1s;-webkit-overflow-scrolling:touch}div:where(.swal2-container).swal2-backdrop-show,div:where(.swal2-container).swal2-noanimation{background:rgba(0,0,0,.4)}div:where(.swal2-container).swal2-backdrop-hide{background:rgba(0,0,0,0) !important}div:where(.swal2-container).swal2-top-start,div:where(.swal2-container).swal2-center-start,div:where(.swal2-container).swal2-bottom-start{grid-template-columns:minmax(0, 1fr) auto auto}div:where(.swal2-container).swal2-top,div:where(.swal2-container).swal2-center,div:where(.swal2-container).swal2-bottom{grid-template-columns:auto minmax(0, 1fr) auto}div:where(.swal2-container).swal2-top-end,div:where(.swal2-container).swal2-center-end,div:where(.swal2-container).swal2-bottom-end{grid-template-columns:auto auto minmax(0, 1fr)}div:where(.swal2-container).swal2-top-start>.swal2-popup{align-self:start}div:where(.swal2-container).swal2-top>.swal2-popup{grid-column:2;align-self:start;justify-self:center}div:where(.swal2-container).swal2-top-end>.swal2-popup,div:where(.swal2-container).swal2-top-right>.swal2-popup{grid-column:3;align-self:start;justify-self:end}div:where(.swal2-container).swal2-center-start>.swal2-popup,div:where(.swal2-container).swal2-center-left>.swal2-popup{grid-row:2;align-self:center}div:where(.swal2-container).swal2-center>.swal2-popup{grid-column:2;grid-row:2;align-self:center;justify-self:center}div:where(.swal2-container).swal2-center-end>.swal2-popup,div:where(.swal2-container).swal2-center-right>.swal2-popup{grid-column:3;grid-row:2;align-self:center;justify-self:end}div:where(.swal2-container).swal2-bottom-start>.swal2-popup,div:where(.swal2-container).swal2-bottom-left>.swal2-popup{grid-column:1;grid-row:3;align-self:end}div:where(.swal2-container).swal2-bottom>.swal2-popup{grid-column:2;grid-row:3;justify-self:center;align-self:end}div:where(.swal2-container).swal2-bottom-end>.swal2-popup,div:where(.swal2-container).swal2-bottom-right>.swal2-popup{grid-column:3;grid-row:3;align-self:end;justify-self:end}div:where(.swal2-container).swal2-grow-row>.swal2-popup,div:where(.swal2-container).swal2-grow-fullscreen>.swal2-popup{grid-column:1/4;width:100%}div:where(.swal2-container).swal2-grow-column>.swal2-popup,div:where(.swal2-container).swal2-grow-fullscreen>.swal2-popup{grid-row:1/4;align-self:stretch}div:where(.swal2-container).swal2-no-transition{transition:none !important}div:where(.swal2-container) div:where(.swal2-popup){display:none;position:relative;box-sizing:border-box;grid-template-columns:minmax(0, 100%);width:32em;max-width:100%;padding:0 0 1.25em;border:none;border-radius:5px;background:#fff;color:#545454;font-family:inherit;font-size:1rem}div:where(.swal2-container) div:where(.swal2-popup):focus{outline:none}div:where(.swal2-container) div:where(.swal2-popup).swal2-loading{overflow-y:hidden}div:where(.swal2-container) h2:where(.swal2-title){position:relative;max-width:100%;margin:0;padding:.8em 1em 0;color:inherit;font-size:1.875em;font-weight:600;text-align:center;text-transform:none;word-wrap:break-word}div:where(.swal2-container) div:where(.swal2-actions){display:flex;z-index:1;box-sizing:border-box;flex-wrap:wrap;align-items:center;justify-content:center;width:auto;margin:1.25em auto 0;padding:0}div:where(.swal2-container) div:where(.swal2-actions):not(.swal2-loading) .swal2-styled[disabled]{opacity:.4}div:where(.swal2-container) div:where(.swal2-actions):not(.swal2-loading) .swal2-styled:hover{background-image:linear-gradient(rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.1))}div:where(.swal2-container) div:where(.swal2-actions):not(.swal2-loading) .swal2-styled:active{background-image:linear-gradient(rgba(0, 0, 0, 0.2), rgba(0, 0, 0, 0.2))}div:where(.swal2-container) div:where(.swal2-loader){display:none;align-items:center;justify-content:center;width:2.2em;height:2.2em;margin:0 1.875em;animation:swal2-rotate-loading 1.5s linear 0s infinite normal;border-width:.25em;border-style:solid;border-radius:100%;border-color:#2778c4 rgba(0,0,0,0) #2778c4 rgba(0,0,0,0)}div:where(.swal2-container) button:where(.swal2-styled){margin:.3125em;padding:.625em 1.1em;transition:box-shadow .1s;box-shadow:0 0 0 3px rgba(0,0,0,0);font-weight:500}div:where(.swal2-container) button:where(.swal2-styled):not([disabled]){cursor:pointer}div:where(.swal2-container) button:where(.swal2-styled).swal2-confirm{border:0;border-radius:.25em;background:initial;background-color:#7066e0;color:#fff;font-size:1em}div:where(.swal2-container) button:where(.swal2-styled).swal2-confirm:focus{box-shadow:0 0 0 3px rgba(112,102,224,.5)}div:where(.swal2-container) button:where(.swal2-styled).swal2-deny{border:0;border-radius:.25em;background:initial;background-color:#dc3741;color:#fff;font-size:1em}div:where(.swal2-container) button:where(.swal2-styled).swal2-deny:focus{box-shadow:0 0 0 3px rgba(220,55,65,.5)}div:where(.swal2-container) button:where(.swal2-styled).swal2-cancel{border:0;border-radius:.25em;background:initial;background-color:#6e7881;color:#fff;font-size:1em}div:where(.swal2-container) button:where(.swal2-styled).swal2-cancel:focus{box-shadow:0 0 0 3px rgba(110,120,129,.5)}div:where(.swal2-container) button:where(.swal2-styled).swal2-default-outline:focus{box-shadow:0 0 0 3px rgba(100,150,200,.5)}div:where(.swal2-container) button:where(.swal2-styled):focus{outline:none}div:where(.swal2-container) button:where(.swal2-styled)::-moz-focus-inner{border:0}div:where(.swal2-container) div:where(.swal2-footer){justify-content:center;margin:1em 0 0;padding:1em 1em 0;border-top:1px solid #eee;color:inherit;font-size:1em}div:where(.swal2-container) .swal2-timer-progress-bar-container{position:absolute;right:0;bottom:0;left:0;grid-column:auto !important;overflow:hidden;border-bottom-right-radius:5px;border-bottom-left-radius:5px}div:where(.swal2-container) div:where(.swal2-timer-progress-bar){width:100%;height:.25em;background:rgba(0,0,0,.2)}div:where(.swal2-container) img:where(.swal2-image){max-width:100%;margin:2em auto 1em}div:where(.swal2-container) button:where(.swal2-close){z-index:2;align-items:center;justify-content:center;width:1.2em;height:1.2em;margin-top:0;margin-right:0;margin-bottom:-1.2em;padding:0;overflow:hidden;transition:color .1s,box-shadow .1s;border:none;border-radius:5px;background:rgba(0,0,0,0);color:#ccc;font-family:monospace;font-size:2.5em;cursor:pointer;justify-self:end}div:where(.swal2-container) button:where(.swal2-close):hover{transform:none;background:rgba(0,0,0,0);color:#f27474}div:where(.swal2-container) button:where(.swal2-close):focus{outline:none;box-shadow:inset 0 0 0 3px rgba(100,150,200,.5)}div:where(.swal2-container) button:where(.swal2-close)::-moz-focus-inner{border:0}div:where(.swal2-container) .swal2-html-container{z-index:1;justify-content:center;margin:1em 1.6em .3em;padding:0;overflow:auto;color:inherit;font-size:1.125em;font-weight:normal;line-height:normal;text-align:center;word-wrap:break-word;word-break:break-word}div:where(.swal2-container) input:where(.swal2-input),div:where(.swal2-container) input:where(.swal2-file),div:where(.swal2-container) textarea:where(.swal2-textarea),div:where(.swal2-container) select:where(.swal2-select),div:where(.swal2-container) div:where(.swal2-radio),div:where(.swal2-container) label:where(.swal2-checkbox){margin:1em 2em 3px}div:where(.swal2-container) input:where(.swal2-input),div:where(.swal2-container) input:where(.swal2-file),div:where(.swal2-container) textarea:where(.swal2-textarea){box-sizing:border-box;width:auto;transition:border-color .1s,box-shadow .1s;border:1px solid #d9d9d9;border-radius:.1875em;background:rgba(0,0,0,0);box-shadow:inset 0 1px 1px rgba(0,0,0,.06),0 0 0 3px rgba(0,0,0,0);color:inherit;font-size:1.125em}div:where(.swal2-container) input:where(.swal2-input).swal2-inputerror,div:where(.swal2-container) input:where(.swal2-file).swal2-inputerror,div:where(.swal2-container) textarea:where(.swal2-textarea).swal2-inputerror{border-color:#f27474 !important;box-shadow:0 0 2px #f27474 !important}div:where(.swal2-container) input:where(.swal2-input):focus,div:where(.swal2-container) input:where(.swal2-file):focus,div:where(.swal2-container) textarea:where(.swal2-textarea):focus{border:1px solid #b4dbed;outline:none;box-shadow:inset 0 1px 1px rgba(0,0,0,.06),0 0 0 3px rgba(100,150,200,.5)}div:where(.swal2-container) input:where(.swal2-input)::placeholder,div:where(.swal2-container) input:where(.swal2-file)::placeholder,div:where(.swal2-container) textarea:where(.swal2-textarea)::placeholder{color:#ccc}div:where(.swal2-container) .swal2-range{margin:1em 2em 3px;background:#fff}div:where(.swal2-container) .swal2-range input{width:80%}div:where(.swal2-container) .swal2-range output{width:20%;color:inherit;font-weight:600;text-align:center}div:where(.swal2-container) .swal2-range input,div:where(.swal2-container) .swal2-range output{height:2.625em;padding:0;font-size:1.125em;line-height:2.625em}div:where(.swal2-container) .swal2-input{height:2.625em;padding:0 .75em}div:where(.swal2-container) .swal2-file{width:75%;margin-right:auto;margin-left:auto;background:rgba(0,0,0,0);font-size:1.125em}div:where(.swal2-container) .swal2-textarea{height:6.75em;padding:.75em}div:where(.swal2-container) .swal2-select{min-width:50%;max-width:100%;padding:.375em .625em;background:rgba(0,0,0,0);color:inherit;font-size:1.125em}div:where(.swal2-container) .swal2-radio,div:where(.swal2-container) .swal2-checkbox{align-items:center;justify-content:center;background:#fff;color:inherit}div:where(.swal2-container) .swal2-radio label,div:where(.swal2-container) .swal2-checkbox label{margin:0 .6em;font-size:1.125em}div:where(.swal2-container) .swal2-radio input,div:where(.swal2-container) .swal2-checkbox input{flex-shrink:0;margin:0 .4em}div:where(.swal2-container) label:where(.swal2-input-label){display:flex;justify-content:center;margin:1em auto 0}div:where(.swal2-container) div:where(.swal2-validation-message){align-items:center;justify-content:center;margin:1em 0 0;padding:.625em;overflow:hidden;background:#f0f0f0;color:#666;font-size:1em;font-weight:300}div:where(.swal2-container) div:where(.swal2-validation-message)::before{content:"!";display:inline-block;width:1.5em;min-width:1.5em;height:1.5em;margin:0 .625em;border-radius:50%;background-color:#f27474;color:#fff;font-weight:600;line-height:1.5em;text-align:center}div:where(.swal2-container) div:where(.swal2-icon){position:relative;box-sizing:content-box;justify-content:center;width:5em;height:5em;margin:2.5em auto .6em;border:0.25em solid rgba(0,0,0,0);border-radius:50%;border-color:#000;font-family:inherit;line-height:5em;cursor:default;user-select:none}div:where(.swal2-container) div:where(.swal2-icon) .swal2-icon-content{display:flex;align-items:center;font-size:3.75em}div:where(.swal2-container) div:where(.swal2-icon).swal2-error{border-color:#f27474;color:#f27474}div:where(.swal2-container) div:where(.swal2-icon).swal2-error .swal2-x-mark{position:relative;flex-grow:1}div:where(.swal2-container) div:where(.swal2-icon).swal2-error [class^=swal2-x-mark-line]{display:block;position:absolute;top:2.3125em;width:2.9375em;height:.3125em;border-radius:.125em;background-color:#f27474}div:where(.swal2-container) div:where(.swal2-icon).swal2-error [class^=swal2-x-mark-line][class$=left]{left:1.0625em;transform:rotate(45deg)}div:where(.swal2-container) div:where(.swal2-icon).swal2-error [class^=swal2-x-mark-line][class$=right]{right:1em;transform:rotate(-45deg)}div:where(.swal2-container) div:where(.swal2-icon).swal2-error.swal2-icon-show{animation:swal2-animate-error-icon .5s}div:where(.swal2-container) div:where(.swal2-icon).swal2-error.swal2-icon-show .swal2-x-mark{animation:swal2-animate-error-x-mark .5s}div:where(.swal2-container) div:where(.swal2-icon).swal2-warning{border-color:#facea8;color:#f8bb86}div:where(.swal2-container) div:where(.swal2-icon).swal2-warning.swal2-icon-show{animation:swal2-animate-error-icon .5s}div:where(.swal2-container) div:where(.swal2-icon).swal2-warning.swal2-icon-show .swal2-icon-content{animation:swal2-animate-i-mark .5s}div:where(.swal2-container) div:where(.swal2-icon).swal2-info{border-color:#9de0f6;color:#3fc3ee}div:where(.swal2-container) div:where(.swal2-icon).swal2-info.swal2-icon-show{animation:swal2-animate-error-icon .5s}div:where(.swal2-container) div:where(.swal2-icon).swal2-info.swal2-icon-show .swal2-icon-content{animation:swal2-animate-i-mark .8s}div:where(.swal2-container) div:where(.swal2-icon).swal2-question{border-color:#c9dae1;color:#87adbd}div:where(.swal2-container) div:where(.swal2-icon).swal2-question.swal2-icon-show{animation:swal2-animate-error-icon .5s}div:where(.swal2-container) div:where(.swal2-icon).swal2-question.swal2-icon-show .swal2-icon-content{animation:swal2-animate-question-mark .8s}div:where(.swal2-container) div:where(.swal2-icon).swal2-success{border-color:#a5dc86;color:#a5dc86}div:where(.swal2-container) div:where(.swal2-icon).swal2-success [class^=swal2-success-circular-line]{position:absolute;width:3.75em;height:7.5em;transform:rotate(45deg);border-radius:50%}div:where(.swal2-container) div:where(.swal2-icon).swal2-success [class^=swal2-success-circular-line][class$=left]{top:-0.4375em;left:-2.0635em;transform:rotate(-45deg);transform-origin:3.75em 3.75em;border-radius:7.5em 0 0 7.5em}div:where(.swal2-container) div:where(.swal2-icon).swal2-success [class^=swal2-success-circular-line][class$=right]{top:-0.6875em;left:1.875em;transform:rotate(-45deg);transform-origin:0 3.75em;border-radius:0 7.5em 7.5em 0}div:where(.swal2-container) div:where(.swal2-icon).swal2-success .swal2-success-ring{position:absolute;z-index:2;top:-0.25em;left:-0.25em;box-sizing:content-box;width:100%;height:100%;border:.25em solid rgba(165,220,134,.3);border-radius:50%}div:where(.swal2-container) div:where(.swal2-icon).swal2-success .swal2-success-fix{position:absolute;z-index:1;top:.5em;left:1.625em;width:.4375em;height:5.625em;transform:rotate(-45deg)}div:where(.swal2-container) div:where(.swal2-icon).swal2-success [class^=swal2-success-line]{display:block;position:absolute;z-index:2;height:.3125em;border-radius:.125em;background-color:#a5dc86}div:where(.swal2-container) div:where(.swal2-icon).swal2-success [class^=swal2-success-line][class$=tip]{top:2.875em;left:.8125em;width:1.5625em;transform:rotate(45deg)}div:where(.swal2-container) div:where(.swal2-icon).swal2-success [class^=swal2-success-line][class$=long]{top:2.375em;right:.5em;width:2.9375em;transform:rotate(-45deg)}div:where(.swal2-container) div:where(.swal2-icon).swal2-success.swal2-icon-show .swal2-success-line-tip{animation:swal2-animate-success-line-tip .75s}div:where(.swal2-container) div:where(.swal2-icon).swal2-success.swal2-icon-show .swal2-success-line-long{animation:swal2-animate-success-line-long .75s}div:where(.swal2-container) div:where(.swal2-icon).swal2-success.swal2-icon-show .swal2-success-circular-line-right{animation:swal2-rotate-success-circular-line 4.25s ease-in}div:where(.swal2-container) .swal2-progress-steps{flex-wrap:wrap;align-items:center;max-width:100%;margin:1.25em auto;padding:0;background:rgba(0,0,0,0);font-weight:600}div:where(.swal2-container) .swal2-progress-steps li{display:inline-block;position:relative}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step{z-index:20;flex-shrink:0;width:2em;height:2em;border-radius:2em;background:#2778c4;color:#fff;line-height:2em;text-align:center}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step.swal2-active-progress-step{background:#2778c4}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step.swal2-active-progress-step~.swal2-progress-step{background:#add8e6;color:#fff}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step.swal2-active-progress-step~.swal2-progress-step-line{background:#add8e6}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step-line{z-index:10;flex-shrink:0;width:2.5em;height:.4em;margin:0 -1px;background:#2778c4}[class^=swal2]{-webkit-tap-highlight-color:rgba(0,0,0,0)}.swal2-show{animation:swal2-show .3s}.swal2-hide{animation:swal2-hide .15s forwards}.swal2-noanimation{transition:none}.swal2-scrollbar-measure{position:absolute;top:-9999px;width:50px;height:50px;overflow:scroll}.swal2-rtl .swal2-close{margin-right:initial;margin-left:0}.swal2-rtl .swal2-timer-progress-bar{right:0;left:auto}@keyframes swal2-toast-show{0%{transform:translateY(-0.625em) rotateZ(2deg)}33%{transform:translateY(0) rotateZ(-2deg)}66%{transform:translateY(0.3125em) rotateZ(2deg)}100%{transform:translateY(0) rotateZ(0deg)}}@keyframes swal2-toast-hide{100%{transform:rotateZ(1deg);opacity:0}}@keyframes swal2-toast-animate-success-line-tip{0%{top:.5625em;left:.0625em;width:0}54%{top:.125em;left:.125em;width:0}70%{top:.625em;left:-0.25em;width:1.625em}84%{top:1.0625em;left:.75em;width:.5em}100%{top:1.125em;left:.1875em;width:.75em}}@keyframes swal2-toast-animate-success-line-long{0%{top:1.625em;right:1.375em;width:0}65%{top:1.25em;right:.9375em;width:0}84%{top:.9375em;right:0;width:1.125em}100%{top:.9375em;right:.1875em;width:1.375em}}@keyframes swal2-show{0%{transform:scale(0.7)}45%{transform:scale(1.05)}80%{transform:scale(0.95)}100%{transform:scale(1)}}@keyframes swal2-hide{0%{transform:scale(1);opacity:1}100%{transform:scale(0.5);opacity:0}}@keyframes swal2-animate-success-line-tip{0%{top:1.1875em;left:.0625em;width:0}54%{top:1.0625em;left:.125em;width:0}70%{top:2.1875em;left:-0.375em;width:3.125em}84%{top:3em;left:1.3125em;width:1.0625em}100%{top:2.8125em;left:.8125em;width:1.5625em}}@keyframes swal2-animate-success-line-long{0%{top:3.375em;right:2.875em;width:0}65%{top:3.375em;right:2.875em;width:0}84%{top:2.1875em;right:0;width:3.4375em}100%{top:2.375em;right:.5em;width:2.9375em}}@keyframes swal2-rotate-success-circular-line{0%{transform:rotate(-45deg)}5%{transform:rotate(-45deg)}12%{transform:rotate(-405deg)}100%{transform:rotate(-405deg)}}@keyframes swal2-animate-error-x-mark{0%{margin-top:1.625em;transform:scale(0.4);opacity:0}50%{margin-top:1.625em;transform:scale(0.4);opacity:0}80%{margin-top:-0.375em;transform:scale(1.15)}100%{margin-top:0;transform:scale(1);opacity:1}}@keyframes swal2-animate-error-icon{0%{transform:rotateX(100deg);opacity:0}100%{transform:rotateX(0deg);opacity:1}}@keyframes swal2-rotate-loading{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}@keyframes swal2-animate-question-mark{0%{transform:rotateY(-360deg)}100%{transform:rotateY(0)}}@keyframes swal2-animate-i-mark{0%{transform:rotateZ(45deg);opacity:0}25%{transform:rotateZ(-25deg);opacity:.4}50%{transform:rotateZ(15deg);opacity:.8}75%{transform:rotateZ(-5deg);opacity:1}100%{transform:rotateX(0);opacity:1}}body.swal2-shown:not(.swal2-no-backdrop):not(.swal2-toast-shown){overflow:hidden}body.swal2-height-auto{height:auto !important}body.swal2-no-backdrop .swal2-container{background-color:rgba(0,0,0,0) !important;pointer-events:none}body.swal2-no-backdrop .swal2-container .swal2-popup{pointer-events:all}body.swal2-no-backdrop .swal2-container .swal2-modal{box-shadow:0 0 10px rgba(0,0,0,.4)}@media print{body.swal2-shown:not(.swal2-no-backdrop):not(.swal2-toast-shown){overflow-y:scroll !important}body.swal2-shown:not(.swal2-no-backdrop):not(.swal2-toast-shown)>[aria-hidden=true]{display:none}body.swal2-shown:not(.swal2-no-backdrop):not(.swal2-toast-shown) .swal2-container{position:static !important}}body.swal2-toast-shown .swal2-container{box-sizing:border-box;width:360px;max-width:100%;background-color:rgba(0,0,0,0);pointer-events:none}body.swal2-toast-shown .swal2-container.swal2-top{inset:0 auto auto 50%;transform:translateX(-50%)}body.swal2-toast-shown .swal2-container.swal2-top-end,body.swal2-toast-shown .swal2-container.swal2-top-right{inset:0 0 auto auto}body.swal2-toast-shown .swal2-container.swal2-top-start,body.swal2-toast-shown .swal2-container.swal2-top-left{inset:0 auto auto 0}body.swal2-toast-shown .swal2-container.swal2-center-start,body.swal2-toast-shown .swal2-container.swal2-center-left{inset:50% auto auto 0;transform:translateY(-50%)}body.swal2-toast-shown .swal2-container.swal2-center{inset:50% auto auto 50%;transform:translate(-50%, -50%)}body.swal2-toast-shown .swal2-container.swal2-center-end,body.swal2-toast-shown .swal2-container.swal2-center-right{inset:50% 0 auto auto;transform:translateY(-50%)}body.swal2-toast-shown .swal2-container.swal2-bottom-start,body.swal2-toast-shown .swal2-container.swal2-bottom-left{inset:auto auto 0 0}body.swal2-toast-shown .swal2-container.swal2-bottom{inset:auto auto 0 50%;transform:translateX(-50%)}body.swal2-toast-shown .swal2-container.swal2-bottom-end,body.swal2-toast-shown .swal2-container.swal2-bottom-right{inset:auto 0 0 auto}')
})(Ny); var Rx = Ny.exports; const Lh = kx(Rx); class lt { static async confirm(e = "Are you sure?", n = "You won't be able to revert this!", r = "Yes", o = "warning") { try { return !!(await Lh.fire({ title: e, text: n, icon: o, confirmButtonText: r, showCancelButton: !0, reverseButtons: !0, confirmButtonColor: "var(--bs-primary)", cancelButtonColor: "var(--bs-secondary)" })).isConfirmed } catch { return !1 } } static toast(e = "Warning!", n = "warning", r = "top-end", o = 3e3, i = !0) { Lh.fire({ title: e, icon: n, position: r, timer: o, timerProgressBar: i, toast: !0, showConfirmButton: !1 }) } static error(e, n = "") { if (Nt.error(n, e), e.isAxiosError) { const { response: r } = e, o = (r.data ? r.data.error : r.data) || { message: "Invalid Request " + r.status }; if (!o) return this.toast(e.message); this.toast(o.message || o.error || "error") } else this.toast(e.message || e, "error") } static success(e = "Success!") { this.toast(e, "success") } }/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */var kl = function(t, e) { return kl = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, r) { n.__proto__ = r } || function(n, r) { for (var o in r) Object.prototype.hasOwnProperty.call(r, o) && (n[o] = r[o]) }, kl(t, e) }; function Hr(t, e) { if (typeof e != "function" && e !== null) throw new TypeError("Class extends value " + String(e) + " is not a constructor or null"); function n() { this.constructor = t } kl(t, e), t.prototype = e === null ? Object.create(e) : (n.prototype = e.prototype, new n) } var le = function() { return le = Object.assign || function(t) { for (var e, n = 1, r = arguments.length; n < r; n++)for (var o in e = arguments[n]) Object.prototype.hasOwnProperty.call(e, o) && (t[o] = e[o]); return t }, le.apply(this, arguments) }; function Et(t, e) { var n = {}; for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]); if (t != null && typeof Object.getOwnPropertySymbols == "function") { var o = 0; for (r = Object.getOwnPropertySymbols(t); o < r.length; o++)e.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[o]) && (n[r[o]] = t[r[o]]) } return n } function _e(t, e, n, r) { return new (n || (n = Promise))(function(o, i) { function s(a) { try { u(r.next(a)) } catch (d) { i(d) } } function c(a) { try { u(r.throw(a)) } catch (d) { i(d) } } function u(a) { var d; a.done ? o(a.value) : (d = a.value, d instanceof n ? d : new n(function(h) { h(d) })).then(s, c) } u((r = r.apply(t, e || [])).next()) }) } function Ee(t, e) { var n, r, o, i, s = { label: 0, sent: function() { if (1 & o[0]) throw o[1]; return o[1] }, trys: [], ops: [] }; return i = { next: c(0), throw: c(1), return: c(2) }, typeof Symbol == "function" && (i[Symbol.iterator] = function() { return this }), i; function c(u) { return function(a) { return function(d) { if (n) throw new TypeError("Generator is already executing."); for (; s;)try { if (n = 1, r && (o = 2 & d[0] ? r.return : d[0] ? r.throw || ((o = r.return) && o.call(r), 0) : r.next) && !(o = o.call(r, d[1])).done) return o; switch (r = 0, o && (d = [2 & d[0], o.value]), d[0]) { case 0: case 1: o = d; break; case 4: return s.label++, { value: d[1], done: !1 }; case 5: s.label++, r = d[1], d = [0]; continue; case 7: d = s.ops.pop(), s.trys.pop(); continue; default: if (o = s.trys, !((o = o.length > 0 && o[o.length - 1]) || d[0] !== 6 && d[0] !== 2)) { s = 0; continue } if (d[0] === 3 && (!o || d[1] > o[0] && d[1] < o[3])) { s.label = d[1]; break } if (d[0] === 6 && s.label < o[1]) { s.label = o[1], o = d; break } if (o && s.label < o[2]) { s.label = o[2], s.ops.push(d); break } o[2] && s.ops.pop(), s.trys.pop(); continue }d = e.call(t, s) } catch (h) { d = [6, h], r = 0 } finally { n = o = 0 } if (5 & d[0]) throw d[1]; return { value: d[0] ? d[1] : void 0, done: !0 } }([u, a]) } } } function No(t, e) { var n = typeof Symbol == "function" && t[Symbol.iterator]; if (!n) return t; var r, o, i = n.call(t), s = []; try { for (; (e === void 0 || e-- > 0) && !(r = i.next()).done;)s.push(r.value) } catch (c) { o = { error: c } } finally { try { r && !r.done && (n = i.return) && n.call(i) } finally { if (o) throw o.error } } return s } function Rl(t, e, n) { if (n || arguments.length === 2) for (var r, o = 0, i = e.length; o < i; o++)!r && o in e || (r || (r = Array.prototype.slice.call(e, 0, o)), r[o] = e[o]); return t.concat(r || Array.prototype.slice.call(e)) } var an = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}; function Xu(t) { return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t } function qo(t, e) { return t(e = { exports: {} }, e.exports), e.exports } var Un, Vs, vs = function(t) { return t && t.Math == Math && t }, q = vs(typeof globalThis == "object" && globalThis) || vs(typeof window == "object" && window) || vs(typeof self == "object" && self) || vs(typeof an == "object" && an) || function() { return this }() || Function("return this")(), Pe = function(t) { try { return !!t() } catch { return !0 } }, xe = !Pe(function() { return Object.defineProperty({}, 1, { get: function() { return 7 } })[1] != 7 }), Yi = !Pe(function() { var t = function() { }.bind(); return typeof t != "function" || t.hasOwnProperty("prototype") }), _s = Function.prototype.call, gt = Yi ? _s.bind(_s) : function() { return _s.apply(_s, arguments) }, Dh = {}.propertyIsEnumerable, Bh = Object.getOwnPropertyDescriptor, Ix = Bh && !Dh.call({ 1: 2 }, 1) ? function(t) { var e = Bh(this, t); return !!e && e.enumerable } : Dh, Zu = { f: Ix }, Lr = function(t, e) { return { enumerable: !(1 & t), configurable: !(2 & t), writable: !(4 & t), value: e } }, Ly = Function.prototype, Px = Ly.bind, Il = Ly.call, Nx = Yi && Px.bind(Il, Il), de = Yi ? function(t) { return t && Nx(t) } : function(t) { return t && function() { return Il.apply(t, arguments) } }, Lx = de({}.toString), Dx = de("".slice), On = function(t) { return Dx(Lx(t), 8, -1) }, Dc = q.Object, Bx = de("".split), Dy = Pe(function() { return !Dc("z").propertyIsEnumerable(0) }) ? function(t) { return On(t) == "String" ? Bx(t, "") : Dc(t) } : Dc, $x = q.TypeError, Xi = function(t) { if (t == null) throw $x("Can't call method on " + t); return t }, yn = function(t) { return Dy(Xi(t)) }, Ne = function(t) { return typeof t == "function" }, je = function(t) { return typeof t == "object" ? t !== null : Ne(t) }, Mx = function(t) { return Ne(t) ? t : void 0 }, Jt = function(t, e) { return arguments.length < 2 ? Mx(q[t]) : q[t] && q[t][e] }, Dr = de({}.isPrototypeOf), Bc = Jt("navigator", "userAgent") || "", $h = q.process, Mh = q.Deno, Fh = $h && $h.versions || Mh && Mh.version, jh = Fh && Fh.v8; jh && (Vs = (Un = jh.split("."))[0] > 0 && Un[0] < 4 ? 1 : +(Un[0] + Un[1])), !Vs && Bc && (!(Un = Bc.match(/Edge\/(\d+)/)) || Un[1] >= 74) && (Un = Bc.match(/Chrome\/(\d+)/)) && (Vs = +Un[1]); var ua = Vs, Lt = !!Object.getOwnPropertySymbols && !Pe(function() { var t = Symbol(); return !String(t) || !(Object(t) instanceof Symbol) || !Symbol.sham && ua && ua < 41 }), Ju = Lt && !Symbol.sham && typeof Symbol.iterator == "symbol", Fx = q.Object, Lo = Ju ? function(t) { return typeof t == "symbol" } : function(t) { var e = Jt("Symbol"); return Ne(e) && Dr(e.prototype, Fx(t)) }, jx = q.String, Go = function(t) { try { return jx(t) } catch { return "Object" } }, Hx = q.TypeError, Qu = function(t) { if (Ne(t)) return t; throw Hx(Go(t) + " is not a function") }, fa = function(t, e) { var n = t[e]; return n == null ? void 0 : Qu(n) }, Ux = q.TypeError, Vx = Object.defineProperty, ef = function(t, e) { try { Vx(q, t, { value: e, configurable: !0, writable: !0 }) } catch { q[t] = e } return e }, Jn = q["__core-js_shared__"] || ef("__core-js_shared__", {}), ur = qo(function(t) { (t.exports = function(e, n) { return Jn[e] || (Jn[e] = n !== void 0 ? n : {}) })("versions", []).push({ version: "3.22.4", mode: "global", copyright: " 2014-2022 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.22.4/LICENSE", source: "https://github.com/zloirock/core-js" }) }), Kx = q.Object, Yo = function(t) { return Kx(Xi(t)) }, Wx = de({}.hasOwnProperty), ne = Object.hasOwn || function(t, e) { return Wx(Yo(t), e) }, zx = 0, qx = Math.random(), Gx = de(1 .toString), Br = function(t) { return "Symbol(" + (t === void 0 ? "" : t) + ")_" + Gx(++zx + qx, 36) }, li = ur("wks"), Rr = q.Symbol, Hh = Rr && Rr.for, Yx = Ju ? Rr : Rr && Rr.withoutSetter || Br, We = function(t) { if (!ne(li, t) || !Lt && typeof li[t] != "string") { var e = "Symbol." + t; Lt && ne(Rr, t) ? li[t] = Rr[t] : li[t] = Ju && Hh ? Hh(e) : Yx(e) } return li[t] }, Xx = q.TypeError, Zx = We("toPrimitive"), Jx = function(t, e) { if (!je(t) || Lo(t)) return t; var n, r = fa(t, Zx); if (r) { if (e === void 0 && (e = "default"), n = gt(r, t, e), !je(n) || Lo(n)) return n; throw Xx("Can't convert object to primitive value") } return e === void 0 && (e = "number"), function(o, i) { var s, c; if (i === "string" && Ne(s = o.toString) && !je(c = gt(s, o)) || Ne(s = o.valueOf) && !je(c = gt(s, o)) || i !== "string" && Ne(s = o.toString) && !je(c = gt(s, o))) return c; throw Ux("Can't convert object to primitive value") }(t, e) }, $r = function(t) { var e = Jx(t, "string"); return Lo(e) ? e : e + "" }, Pl = q.document, Qx = je(Pl) && je(Pl.createElement), By = function(t) { return Qx ? Pl.createElement(t) : {} }, $y = !xe && !Pe(function() { return Object.defineProperty(By("div"), "a", { get: function() { return 7 } }).a != 7 }), Uh = Object.getOwnPropertyDescriptor, Zi = { f: xe ? Uh : function(t, e) { if (t = yn(t), e = $r(e), $y) try { return Uh(t, e) } catch { } if (ne(t, e)) return Lr(!gt(Zu.f, t, e), t[e]) } }, My = xe && Pe(function() { return Object.defineProperty(function() { }, "prototype", { value: 42, writable: !1 }).prototype != 42 }), e1 = q.String, t1 = q.TypeError, Qe = function(t) { if (je(t)) return t; throw t1(e1(t) + " is not an object") }, n1 = q.TypeError, $c = Object.defineProperty, r1 = Object.getOwnPropertyDescriptor, dt = { f: xe ? My ? function(t, e, n) { if (Qe(t), e = $r(e), Qe(n), typeof t == "function" && e === "prototype" && "value" in n && "writable" in n && !n.writable) { var r = r1(t, e); r && r.writable && (t[e] = n.value, n = { configurable: "configurable" in n ? n.configurable : r.configurable, enumerable: "enumerable" in n ? n.enumerable : r.enumerable, writable: !1 }) } return $c(t, e, n) } : $c : function(t, e, n) { if (Qe(t), e = $r(e), Qe(n), $y) try { return $c(t, e, n) } catch { } if ("get" in n || "set" in n) throw n1("Accessors not supported"); return "value" in n && (t[e] = n.value), t } }, Ur = xe ? function(t, e, n) { return dt.f(t, e, Lr(1, n)) } : function(t, e, n) { return t[e] = n, t }, Fy = Function.prototype, o1 = xe && Object.getOwnPropertyDescriptor, Mc = ne(Fy, "name"), tf = { EXISTS: Mc, PROPER: Mc && function() { }.name === "something", CONFIGURABLE: Mc && (!xe || xe && o1(Fy, "name").configurable) }, i1 = de(Function.toString); Ne(Jn.inspectSource) || (Jn.inspectSource = function(t) { return i1(t) }); var da, Ti, ha, nf = Jn.inspectSource, Vh = q.WeakMap, s1 = Ne(Vh) && /native code/.test(nf(Vh)), Kh = ur("keys"), Ya = function(t) { return Kh[t] || (Kh[t] = Br(t)) }, Xo = {}, Nl = q.TypeError, a1 = q.WeakMap; if (s1 || Jn.state) { var pr = Jn.state || (Jn.state = new a1), c1 = de(pr.get), Wh = de(pr.has), l1 = de(pr.set); da = function(t, e) { if (Wh(pr, t)) throw new Nl("Object already initialized"); return e.facade = t, l1(pr, t, e), e }, Ti = function(t) { return c1(pr, t) || {} }, ha = function(t) { return Wh(pr, t) } } else { var Qr = Ya("state"); Xo[Qr] = !0, da = function(t, e) { if (ne(t, Qr)) throw new Nl("Object already initialized"); return e.facade = t, Ur(t, Qr, e), e }, Ti = function(t) { return ne(t, Qr) ? t[Qr] : {} }, ha = function(t) { return ne(t, Qr) } } var hn = { set: da, get: Ti, has: ha, enforce: function(t) { return ha(t) ? Ti(t) : da(t, {}) }, getterFor: function(t) { return function(e) { var n; if (!je(e) || (n = Ti(e)).type !== t) throw Nl("Incompatible receiver, " + t + " required"); return n } } }, u1 = qo(function(t) { var e = dt.f, n = tf.CONFIGURABLE, r = hn.enforce, o = hn.get, i = !Pe(function() { return e(function() { }, "length", { value: 8 }).length !== 8 }), s = String(String).split("String"), c = t.exports = function(u, a, d) { String(a).slice(0, 7) === "Symbol(" && (a = "[" + String(a).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), d && d.getter && (a = "get " + a), d && d.setter && (a = "set " + a), (!ne(u, "name") || n && u.name !== a) && e(u, "name", { value: a, configurable: !0 }), i && d && ne(d, "arity") && u.length !== d.arity && e(u, "length", { value: d.arity }); var h = r(u); return ne(h, "source") || (h.source = s.join(typeof a == "string" ? a : "")), u }; Function.prototype.toString = c(function() { return Ne(this) && o(this).source || nf(this) }, "toString") }), bt = function(t, e, n, r) { var o = !!r && !!r.unsafe, i = !!r && !!r.enumerable, s = !!r && !!r.noTargetGet, c = r && r.name !== void 0 ? r.name : e; return Ne(n) && u1(n, c, r), t === q ? (i ? t[e] = n : ef(e, n), t) : (o ? !s && t[e] && (i = !0) : delete t[e], i ? t[e] = n : Ur(t, e, n), t) }, f1 = Math.ceil, d1 = Math.floor, rf = function(t) { var e = +t; return e != e || e === 0 ? 0 : (e > 0 ? d1 : f1)(e) }, h1 = Math.max, p1 = Math.min, Ll = function(t, e) { var n = rf(t); return n < 0 ? h1(n + e, 0) : p1(n, e) }, m1 = Math.min, jy = function(t) { return t > 0 ? m1(rf(t), 9007199254740991) : 0 }, Zo = function(t) { return jy(t.length) }, zh = function(t) { return function(e, n, r) { var o, i = yn(e), s = Zo(i), c = Ll(r, s); if (t && n != n) { for (; s > c;)if ((o = i[c++]) != o) return !0 } else for (; s > c; c++)if ((t || c in i) && i[c] === n) return t || c || 0; return !t && -1 } }, Hy = { includes: zh(!0), indexOf: zh(!1) }, g1 = Hy.indexOf, qh = de([].push), Uy = function(t, e) { var n, r = yn(t), o = 0, i = []; for (n in r) !ne(Xo, n) && ne(r, n) && qh(i, n); for (; e.length > o;)ne(r, n = e[o++]) && (~g1(i, n) || qh(i, n)); return i }, pa = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"], y1 = pa.concat("length", "prototype"), Bi = { f: Object.getOwnPropertyNames || function(t) { return Uy(t, y1) } }, Xa = { f: Object.getOwnPropertySymbols }, w1 = de([].concat), b1 = Jt("Reflect", "ownKeys") || function(t) { var e = Bi.f(Qe(t)), n = Xa.f; return n ? w1(e, n(t)) : e }, Vy = function(t, e, n) { for (var r = b1(e), o = dt.f, i = Zi.f, s = 0; s < r.length; s++) { var c = r[s]; ne(t, c) || n && ne(n, c) || o(t, c, i(e, c)) } }, v1 = /#|\.prototype\./, Ji = function(t, e) { var n = E1[_1(t)]; return n == T1 || n != A1 && (Ne(e) ? Pe(e) : !!e) }, _1 = Ji.normalize = function(t) { return String(t).replace(v1, ".").toLowerCase() }, E1 = Ji.data = {}, A1 = Ji.NATIVE = "N", T1 = Ji.POLYFILL = "P", Dl = Ji, S1 = Zi.f, et = function(t, e) { var n, r, o, i, s, c = t.target, u = t.global, a = t.stat; if (n = u ? q : a ? q[c] || ef(c, {}) : (q[c] || {}).prototype) for (r in e) { if (i = e[r], o = t.noTargetGet ? (s = S1(n, r)) && s.value : n[r], !Dl(u ? r : c + (a ? "." : "#") + r, t.forced) && o !== void 0) { if (typeof i == typeof o) continue; Vy(i, o) } (t.sham || o && o.sham) && Ur(i, "sham", !0), bt(n, r, i, t) } }, Ky = {}; Ky[We("toStringTag")] = "z"; var Fc, of = String(Ky) === "[object z]", C1 = We("toStringTag"), O1 = q.Object, x1 = On(function() { return arguments }()) == "Arguments", Vr = of ? On : function(t) { var e, n, r; return t === void 0 ? "Undefined" : t === null ? "Null" : typeof (n = function(o, i) { try { return o[i] } catch { } }(e = O1(t), C1)) == "string" ? n : x1 ? On(e) : (r = On(e)) == "Object" && Ne(e.callee) ? "Arguments" : r }, k1 = q.String, In = function(t) { if (Vr(t) === "Symbol") throw TypeError("Cannot convert a Symbol value to a string"); return k1(t) }, R1 = We("match"), I1 = q.TypeError, Wy = function(t) { if (function(e) { var n; return je(e) && ((n = e[R1]) !== void 0 ? !!n : On(e) == "RegExp") }(t)) throw I1("The method doesn't accept regular expressions"); return t }, P1 = We("match"), zy = function(t) { var e = /./; try { "/./"[t](e) } catch { try { return e[P1] = !1, "/./"[t](e) } catch { } } return !1 }, N1 = Zi.f, Gh = de("".startsWith), L1 = de("".slice), D1 = Math.min, qy = zy("startsWith"), B1 = !(qy || (Fc = N1(String.prototype, "startsWith"), !Fc || Fc.writable)); et({ target: "String", proto: !0, forced: !B1 && !qy }, { startsWith: function(t) { var e = In(Xi(this)); Wy(t); var n = jy(D1(arguments.length > 1 ? arguments[1] : void 0, e.length)), r = In(t); return Gh ? Gh(e, r, n) : L1(e, n, n + r.length) === r } }); var sf = function(t, e) { return de(q[t].prototype[e]) }; sf("String", "startsWith"); var ma = Array.isArray || function(t) { return On(t) == "Array" }, $i = function(t, e, n) { var r = $r(e); r in t ? dt.f(t, r, Lr(0, n)) : t[r] = n }, Gy = function() { }, $1 = [], Yy = Jt("Reflect", "construct"), af = /^\s*(?:class|function)\b/, M1 = de(af.exec), F1 = !af.exec(Gy), ui = function(t) { if (!Ne(t)) return !1; try { return Yy(Gy, $1, t), !0 } catch { return !1 } }, Xy = function(t) { if (!Ne(t)) return !1; switch (Vr(t)) { case "AsyncFunction": case "GeneratorFunction": case "AsyncGeneratorFunction": return !1 }try { return F1 || !!M1(af, nf(t)) } catch { return !0 } }; Xy.sham = !0; var Yh, cf = !Yy || Pe(function() { var t; return ui(ui.call) || !ui(Object) || !ui(function() { t = !0 }) || t }) ? Xy : ui, j1 = We("species"), Xh = q.Array, Zy = function(t, e) { return new (function(n) { var r; return ma(n) && (r = n.constructor, (cf(r) && (r === Xh || ma(r.prototype)) || je(r) && (r = r[j1]) === null) && (r = void 0)), r === void 0 ? Xh : r }(t))(e === 0 ? 0 : e) }, H1 = We("species"), Jy = We("isConcatSpreadable"), Zh = q.TypeError, U1 = ua >= 51 || !Pe(function() { var t = []; return t[Jy] = !1, t.concat()[0] !== t }), V1 = (Yh = "concat", ua >= 51 || !Pe(function() { var t = []; return (t.constructor = {})[H1] = function() { return { foo: 1 } }, t[Yh](Boolean).foo !== 1 })), K1 = function(t) { if (!je(t)) return !1; var e = t[Jy]; return e !== void 0 ? !!e : ma(t) }; et({ target: "Array", proto: !0, arity: 1, forced: !U1 || !V1 }, { concat: function(t) { var e, n, r, o, i, s = Yo(this), c = Zy(s, 0), u = 0; for (e = -1, r = arguments.length; e < r; e++)if (K1(i = e === -1 ? s : arguments[e])) { if (u + (o = Zo(i)) > 9007199254740991) throw Zh("Maximum allowed index exceeded"); for (n = 0; n < o; n++, u++)n in i && $i(c, u, i[n]) } else { if (u >= 9007199254740991) throw Zh("Maximum allowed index exceeded"); $i(c, u++, i) } return c.length = u, c } }); var W1 = of ? {}.toString : function() { return "[object " + Vr(this) + "]" }; of || bt(Object.prototype, "toString", W1, { unsafe: !0 }); var Es, lf = Object.keys || function(t) { return Uy(t, pa) }, z1 = xe && !My ? Object.defineProperties : function(t, e) { Qe(t); for (var n, r = yn(e), o = lf(e), i = o.length, s = 0; i > s;)dt.f(t, n = o[s++], r[n]); return t }, Qy = { f: z1 }, q1 = Jt("document", "documentElement"), ew = Ya("IE_PROTO"), jc = function() { }, tw = function(t) { return "<script>" + t + "<\/script>" }, Jh = function(t) { t.write(tw("")), t.close(); var e = t.parentWindow.Object; return t = null, e }, Ks = function() { try { Es = new ActiveXObject("htmlfile") } catch { } var t, e; Ks = typeof document < "u" ? document.domain && Es ? Jh(Es) : ((e = By("iframe")).style.display = "none", q1.appendChild(e), e.src = "javascript:", (t = e.contentWindow.document).open(), t.write(tw("document.F=Object")), t.close(), t.F) : Jh(Es); for (var n = pa.length; n--;)delete Ks.prototype[pa[n]]; return Ks() }; Xo[ew] = !0; var sr = Object.create || function(t, e) { var n; return t !== null ? (jc.prototype = Qe(t), n = new jc, jc.prototype = null, n[ew] = t) : n = Ks(), e === void 0 ? n : Qy.f(n, e) }, G1 = q.Array, Y1 = Math.max, nw = Bi.f, rw = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [], X1 = function(t) { try { return nw(t) } catch { return function(n, r, o) { for (var i = Zo(n), s = Ll(r, i), c = Ll(o === void 0 ? i : o, i), u = G1(Y1(c - s, 0)), a = 0; s < c; s++, a++)$i(u, a, n[s]); return u.length = a, u }(rw) } }, uf = { f: function(t) { return rw && On(t) == "Window" ? X1(t) : nw(yn(t)) } }, ow = { f: We }, Mi = q, Z1 = dt.f, At = function(t) { var e = Mi.Symbol || (Mi.Symbol = {}); ne(e, t) || Z1(e, t, { value: ow.f(t) }) }, iw = function() { var t = Jt("Symbol"), e = t && t.prototype, n = e && e.valueOf, r = We("toPrimitive"); e && !e[r] && bt(e, r, function(o) { return gt(n, this) }, { arity: 1 }) }, J1 = dt.f, Qh = We("toStringTag"), Yn = function(t, e, n) { t && !n && (t = t.prototype), t && !ne(t, Qh) && J1(t, Qh, { configurable: !0, value: e }) }, Q1 = de(de.bind), Za = function(t, e) { return Qu(t), e === void 0 ? t : Yi ? Q1(t, e) : function() { return t.apply(e, arguments) } }, ep = de([].push), Vn = function(t) { var e = t == 1, n = t == 2, r = t == 3, o = t == 4, i = t == 6, s = t == 7, c = t == 5 || i; return function(u, a, d, h) { for (var m, g, y = Yo(u), _ = Dy(y), A = Za(a, d), E = Zo(_), T = 0, x = h || Zy, P = e ? x(u, E) : n || s ? x(u, 0) : void 0; E > T; T++)if ((c || T in _) && (g = A(m = _[T], T, y), t)) if (e) P[T] = g; else if (g) switch (t) { case 3: return !0; case 5: return m; case 6: return T; case 2: ep(P, m) } else switch (t) { case 4: return !1; case 7: ep(P, m) }return i ? -1 : r || o ? o : P } }, Ja = { forEach: Vn(0), map: Vn(1), filter: Vn(2), some: Vn(3), every: Vn(4), find: Vn(5), findIndex: Vn(6), filterReject: Vn(7) }.forEach, St = Ya("hidden"), ek = hn.set, tp = hn.getterFor("Symbol"), Bt = Object.prototype, fo = q.Symbol, yi = fo && fo.prototype, tk = q.TypeError, Hc = q.QObject, sw = Zi.f, Gn = dt.f, aw = uf.f, nk = Zu.f, cw = de([].push), Pn = ur("symbols"), Qi = ur("op-symbols"), rk = ur("wks"), Uc = !Hc || !Hc.prototype || !Hc.prototype.findChild, Bl = xe && Pe(function() { return sr(Gn({}, "a", { get: function() { return Gn(this, "a", { value: 7 }).a } })).a != 7 }) ? function(t, e, n) { var r = sw(Bt, e); r && delete Bt[e], Gn(t, e, n), r && t !== Bt && Gn(Bt, e, r) } : Gn, Vc = function(t, e) { var n = Pn[t] = sr(yi); return ek(n, { type: "Symbol", tag: t, description: e }), xe || (n.description = e), n }, ga = function(t, e, n) { t === Bt && ga(Qi, e, n), Qe(t); var r = $r(e); return Qe(n), ne(Pn, r) ? (n.enumerable ? (ne(t, St) && t[St][r] && (t[St][r] = !1), n = sr(n, { enumerable: Lr(0, !1) })) : (ne(t, St) || Gn(t, St, Lr(1, {})), t[St][r] = !0), Bl(t, r, n)) : Gn(t, r, n) }, Kc = function(t, e) { Qe(t); var n = yn(e), r = lf(n).concat(lw(n)); return Ja(r, function(o) { xe && !gt($l, n, o) || ga(t, o, n[o]) }), t }, $l = function(t) { var e = $r(t), n = gt(nk, this, e); return !(this === Bt && ne(Pn, e) && !ne(Qi, e)) && (!(n || !ne(this, e) || !ne(Pn, e) || ne(this, St) && this[St][e]) || n) }, np = function(t, e) { var n = yn(t), r = $r(e); if (n !== Bt || !ne(Pn, r) || ne(Qi, r)) { var o = sw(n, r); return !o || !ne(Pn, r) || ne(n, St) && n[St][r] || (o.enumerable = !0), o } }, rp = function(t) { var e = aw(yn(t)), n = []; return Ja(e, function(r) { ne(Pn, r) || ne(Xo, r) || cw(n, r) }), n }, lw = function(t) { var e = t === Bt, n = aw(e ? Qi : yn(t)), r = []; return Ja(n, function(o) { !ne(Pn, o) || e && !ne(Bt, o) || cw(r, Pn[o]) }), r }; Lt || (yi = (fo = function() { if (Dr(yi, this)) throw tk("Symbol is not a constructor"); var t = arguments.length && arguments[0] !== void 0 ? In(arguments[0]) : void 0, e = Br(t), n = function(r) { this === Bt && gt(n, Qi, r), ne(this, St) && ne(this[St], e) && (this[St][e] = !1), Bl(this, e, Lr(1, r)) }; return xe && Uc && Bl(Bt, e, { configurable: !0, set: n }), Vc(e, t) }).prototype, bt(yi, "toString", function() { return tp(this).tag }), bt(fo, "withoutSetter", function(t) { return Vc(Br(t), t) }), Zu.f = $l, dt.f = ga, Qy.f = Kc, Zi.f = np, Bi.f = uf.f = rp, Xa.f = lw, ow.f = function(t) { return Vc(We(t), t) }, xe && (Gn(yi, "description", { configurable: !0, get: function() { return tp(this).description } }), bt(Bt, "propertyIsEnumerable", $l, { unsafe: !0 }))), et({ global: !0, wrap: !0, forced: !Lt, sham: !Lt }, { Symbol: fo }), Ja(lf(rk), function(t) { At(t) }), et({ target: "Symbol", stat: !0, forced: !Lt }, { useSetter: function() { Uc = !0 }, useSimple: function() { Uc = !1 } }), et({ target: "Object", stat: !0, forced: !Lt, sham: !xe }, { create: function(t, e) { return e === void 0 ? sr(t) : Kc(sr(t), e) }, defineProperty: ga, defineProperties: Kc, getOwnPropertyDescriptor: np }), et({ target: "Object", stat: !0, forced: !Lt }, { getOwnPropertyNames: rp }), iw(), Yn(fo, "Symbol"), Xo[St] = !0; var uw = Lt && !!Symbol.for && !!Symbol.keyFor, Wc = ur("string-to-symbol-registry"), ok = ur("symbol-to-string-registry"); et({ target: "Symbol", stat: !0, forced: !uw }, { for: function(t) { var e = In(t); if (ne(Wc, e)) return Wc[e]; var n = Jt("Symbol")(e); return Wc[e] = n, ok[n] = e, n } }); var op = ur("symbol-to-string-registry"); et({ target: "Symbol", stat: !0, forced: !uw }, { keyFor: function(t) { if (!Lo(t)) throw TypeError(Go(t) + " is not a symbol"); if (ne(op, t)) return op[t] } }); var fw = Function.prototype, ip = fw.apply, sp = fw.call, dw = typeof Reflect == "object" && Reflect.apply || (Yi ? sp.bind(ip) : function() { return sp.apply(ip, arguments) }), ff = de([].slice), Qn = Jt("JSON", "stringify"), As = de(/./.exec), ap = de("".charAt), ik = de("".charCodeAt), sk = de("".replace), ak = de(1 .toString), ck = /[\uD800-\uDFFF]/g, cp = /^[\uD800-\uDBFF]$/, lp = /^[\uDC00-\uDFFF]$/, up = !Lt || Pe(function() { var t = Jt("Symbol")(); return Qn([t]) != "[null]" || Qn({ a: t }) != "{}" || Qn(Object(t)) != "{}" }), fp = Pe(function() { return Qn("\uDF06\uD834") !== '"\\udf06\\ud834"' || Qn("\uDEAD") !== '"\\udead"' }), lk = function(t, e) { var n = ff(arguments), r = e; if ((je(e) || t !== void 0) && !Lo(t)) return ma(e) || (e = function(o, i) { if (Ne(r) && (i = gt(r, this, o, i)), !Lo(i)) return i }), n[1] = e, dw(Qn, null, n) }, uk = function(t, e, n) { var r = ap(n, e - 1), o = ap(n, e + 1); return As(cp, t) && !As(lp, o) || As(lp, t) && !As(cp, r) ? "\\u" + ak(ik(t, 0), 16) : t }; Qn && et({ target: "JSON", stat: !0, arity: 3, forced: up || fp }, { stringify: function(t, e, n) { var r = ff(arguments), o = dw(up ? lk : Qn, null, r); return fp && typeof o == "string" ? sk(o, ck, uk) : o } }); var fk = !Lt || Pe(function() { Xa.f(1) }); et({ target: "Object", stat: !0, forced: fk }, { getOwnPropertySymbols: function(t) { var e = Xa.f; return e ? e(Yo(t)) : [] } }), At("asyncIterator"); var dk = dt.f, _n = q.Symbol, mr = _n && _n.prototype; if (xe && Ne(_n) && (!("description" in mr) || _n().description !== void 0)) { var dp = {}, Ts = function() { var t = arguments.length < 1 || arguments[0] === void 0 ? void 0 : In(arguments[0]), e = Dr(mr, this) ? new _n(t) : t === void 0 ? _n() : _n(t); return t === "" && (dp[e] = !0), e }; Vy(Ts, _n), Ts.prototype = mr, mr.constructor = Ts; var hk = String(_n("test")) == "Symbol(test)", pk = de(mr.toString), mk = de(mr.valueOf), gk = /^Symbol\((.*)\)[^)]+$/, yk = de("".replace), wk = de("".slice); dk(mr, "description", { configurable: !0, get: function() { var t = mk(this), e = pk(t); if (ne(dp, t)) return ""; var n = hk ? wk(e, 7, -1) : yk(e, gk, "$1"); return n === "" ? void 0 : n } }), et({ global: !0, forced: !0 }, { Symbol: Ts }) } At("hasInstance"), At("isConcatSpreadable"), At("iterator"), At("match"), At("matchAll"), At("replace"), At("search"), At("species"), At("split"), At("toPrimitive"), iw(), At("toStringTag"), Yn(Jt("Symbol"), "Symbol"), At("unscopables"), Yn(q.JSON, "JSON", !0), Yn(Math, "Math", !0), et({ global: !0 }, { Reflect: {} }), Yn(q.Reflect, "Reflect", !0), Mi.Symbol; var Ir, hp, pp, bk = de("".charAt), mp = de("".charCodeAt), vk = de("".slice), gp = function(t) { return function(e, n) { var r, o, i = In(Xi(e)), s = rf(n), c = i.length; return s < 0 || s >= c ? t ? "" : void 0 : (r = mp(i, s)) < 55296 || r > 56319 || s + 1 === c || (o = mp(i, s + 1)) < 56320 || o > 57343 ? t ? bk(i, s) : r : t ? vk(i, s, s + 2) : o - 56320 + (r - 55296 << 10) + 65536 } }, _k = { codeAt: gp(!1), charAt: gp(!0) }, Ek = !Pe(function() { function t() { } return t.prototype.constructor = null, Object.getPrototypeOf(new t) !== t.prototype }), yp = Ya("IE_PROTO"), Ml = q.Object, Ak = Ml.prototype, Mr = Ek ? Ml.getPrototypeOf : function(t) { var e = Yo(t); if (ne(e, yp)) return e[yp]; var n = e.constructor; return Ne(n) && e instanceof n ? n.prototype : e instanceof Ml ? Ak : null }, Fl = We("iterator"), hw = !1;[].keys && ("next" in (pp = [].keys()) ? (hp = Mr(Mr(pp))) !== Object.prototype && (Ir = hp) : hw = !0); var Tk = Ir == null || Pe(function() { var t = {}; return Ir[Fl].call(t) !== t }); Tk && (Ir = {}), Ne(Ir[Fl]) || bt(Ir, Fl, function() { return this }); var df = { IteratorPrototype: Ir, BUGGY_SAFARI_ITERATORS: hw }, Do = {}, Sk = df.IteratorPrototype, Ck = function() { return this }, Ok = q.String, xk = q.TypeError, pn = Object.setPrototypeOf || ("__proto__" in {} ? function() { var t, e = !1, n = {}; try { (t = de(Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set))(n, []), e = n instanceof Array } catch { } return function(r, o) { return Qe(r), function(i) { if (typeof i == "object" || Ne(i)) return i; throw xk("Can't set " + Ok(i) + " as a prototype") }(o), e ? t(r, o) : r.__proto__ = o, r } }() : void 0), kk = tf.PROPER, Rk = tf.CONFIGURABLE, wp = df.IteratorPrototype, Ss = df.BUGGY_SAFARI_ITERATORS, fi = We("iterator"), Ik = function() { return this }, hf = function(t, e, n, r, o, i, s) { (function(E, T, x, P) { var W = T + " Iterator"; E.prototype = sr(Sk, { next: Lr(+!P, x) }), Yn(E, W, !1), Do[W] = Ck })(n, e, r); var c, u, a, d = function(E) { if (E === o && _) return _; if (!Ss && E in g) return g[E]; switch (E) { case "keys": case "values": case "entries": return function() { return new n(this, E) } }return function() { return new n(this) } }, h = e + " Iterator", m = !1, g = t.prototype, y = g[fi] || g["@@iterator"] || o && g[o], _ = !Ss && y || d(o), A = e == "Array" && g.entries || y; if (A && (c = Mr(A.call(new t))) !== Object.prototype && c.next && (Mr(c) !== wp && (pn ? pn(c, wp) : Ne(c[fi]) || bt(c, fi, Ik)), Yn(c, h, !0)), kk && o == "values" && y && y.name !== "values" && (Rk ? Ur(g, "name", "values") : (m = !0, _ = function() { return gt(y, this) })), o) if (u = { values: d("values"), keys: i ? _ : d("keys"), entries: d("entries") }, s) for (a in u) (Ss || m || !(a in g)) && bt(g, a, u[a]); else et({ target: e, proto: !0, forced: Ss || m }, u); return g[fi] !== _ && bt(g, fi, _, { name: o }), Do[e] = _, u }, Pk = _k.charAt, Nk = hn.set, Lk = hn.getterFor("String Iterator"); hf(String, "String", function(t) { Nk(this, { type: "String Iterator", string: In(t), index: 0 }) }, function() { var t, e = Lk(this), n = e.string, r = e.index; return r >= n.length ? { value: void 0, done: !0 } : (t = Pk(n, r), e.index += t.length, { value: t, done: !1 }) }); var jl = function(t, e, n) { var r, o; Qe(t); try { if (!(r = fa(t, "return"))) { if (e === "throw") throw n; return n } r = gt(r, t) } catch (i) { o = !0, r = i } if (e === "throw") throw n; if (o) throw r; return Qe(r), n }, Dk = function(t, e, n, r) { try { return r ? e(Qe(n)[0], n[1]) : e(n) } catch (o) { jl(t, "throw", o) } }, Bk = We("iterator"), $k = Array.prototype, pw = function(t) { return t !== void 0 && (Do.Array === t || $k[Bk] === t) }, Mk = We("iterator"), pf = function(t) { if (t != null) return fa(t, Mk) || fa(t, "@@iterator") || Do[Vr(t)] }, Fk = q.TypeError, mw = function(t, e) { var n = arguments.length < 2 ? pf(t) : e; if (Qu(n)) return Qe(gt(n, t)); throw Fk(Go(t) + " is not iterable") }, bp = q.Array, gw = We("iterator"), yw = !1; try { var jk = 0, vp = { next: function() { return { done: !!jk++ } }, return: function() { yw = !0 } }; vp[gw] = function() { return this }, Array.from(vp, function() { throw 2 }) } catch { } var ww = function(t, e) { if (!e && !yw) return !1; var n = !1; try { var r = {}; r[gw] = function() { return { next: function() { return { done: n = !0 } } } }, t(r) } catch { } return n }, Hk = !ww(function(t) { Array.from(t) }); et({ target: "Array", stat: !0, forced: Hk }, { from: function(t) { var e = Yo(t), n = cf(this), r = arguments.length, o = r > 1 ? arguments[1] : void 0, i = o !== void 0; i && (o = Za(o, r > 2 ? arguments[2] : void 0)); var s, c, u, a, d, h, m = pf(e), g = 0; if (!m || this == bp && pw(m)) for (s = Zo(e), c = n ? new this(s) : bp(s); s > g; g++)h = i ? o(e[g], g) : e[g], $i(c, g, h); else for (d = (a = mw(e, m)).next, c = n ? new this : []; !(u = gt(d, a)).done; g++)h = i ? Dk(a, o, [u.value, g], !0) : u.value, $i(c, g, h); return c.length = g, c } }), Mi.Array.from; var Ot, vo, ya, Uk = typeof ArrayBuffer < "u" && typeof DataView < "u", Vk = dt.f, wa = q.Int8Array, Hl = wa && wa.prototype, _p = q.Uint8ClampedArray, Ep = _p && _p.prototype, on = wa && Mr(wa), qt = Hl && Mr(Hl), Kk = Object.prototype, Ul = q.TypeError, Ap = We("toStringTag"), Vl = Br("TYPED_ARRAY_TAG"), mf = Br("TYPED_ARRAY_CONSTRUCTOR"), xn = Uk && !!pn && Vr(q.opera) !== "Opera", bw = !1, En = { Int8Array: 1, Uint8Array: 1, Uint8ClampedArray: 1, Int16Array: 2, Uint16Array: 2, Int32Array: 4, Uint32Array: 4, Float32Array: 4, Float64Array: 8 }, gf = { BigInt64Array: 8, BigUint64Array: 8 }, Tp = function(t) { if (!je(t)) return !1; var e = Vr(t); return ne(En, e) || ne(gf, e) }; for (Ot in En) (ya = (vo = q[Ot]) && vo.prototype) ? Ur(ya, mf, vo) : xn = !1; for (Ot in gf) (ya = (vo = q[Ot]) && vo.prototype) && Ur(ya, mf, vo); if ((!xn || !Ne(on) || on === Function.prototype) && (on = function() { throw Ul("Incorrect invocation") }, xn)) for (Ot in En) q[Ot] && pn(q[Ot], on); if ((!xn || !qt || qt === Kk) && (qt = on.prototype, xn)) for (Ot in En) q[Ot] && pn(q[Ot].prototype, qt); if (xn && Mr(Ep) !== qt && pn(Ep, qt), xe && !ne(qt, Ap)) for (Ot in bw = !0, Vk(qt, Ap, { get: function() { return je(this) ? this[Vl] : void 0 } }), En) q[Ot] && Ur(q[Ot], Vl, Ot); var Qa = { NATIVE_ARRAY_BUFFER_VIEWS: xn, TYPED_ARRAY_CONSTRUCTOR: mf, TYPED_ARRAY_TAG: bw && Vl, aTypedArray: function(t) { if (Tp(t)) return t; throw Ul("Target is not a typed array") }, aTypedArrayConstructor: function(t) { if (Ne(t) && (!pn || Dr(on, t))) return t; throw Ul(Go(t) + " is not a typed array constructor") }, exportTypedArrayMethod: function(t, e, n, r) { if (xe) { if (n) for (var o in En) { var i = q[o]; if (i && ne(i.prototype, t)) try { delete i.prototype[t] } catch { try { i.prototype[t] = e } catch { } } } qt[t] && !n || bt(qt, t, n ? e : xn && Hl[t] || e, r) } }, exportTypedArrayStaticMethod: function(t, e, n) { var r, o; if (xe) { if (pn) { if (n) { for (r in En) if ((o = q[r]) && ne(o, t)) try { delete o[t] } catch { } } if (on[t] && !n) return; try { return bt(on, t, n ? e : xn && on[t] || e) } catch { } } for (r in En) !(o = q[r]) || o[t] && !n || bt(o, t, e) } }, isView: function(t) { if (!je(t)) return !1; var e = Vr(t); return e === "DataView" || ne(En, e) || ne(gf, e) }, isTypedArray: Tp, TypedArray: on, TypedArrayPrototype: qt }, Wk = q.TypeError, zk = We("species"), qk = function(t, e) { var n, r = Qe(t).constructor; return r === void 0 || (n = Qe(r)[zk]) == null ? e : function(o) { if (cf(o)) return o; throw Wk(Go(o) + " is not a constructor") }(n) }, Gk = Qa.TYPED_ARRAY_CONSTRUCTOR, Yk = Qa.aTypedArrayConstructor, Xk = Qa.aTypedArray; (0, Qa.exportTypedArrayMethod)("slice", function(t, e) { for (var n, r = ff(Xk(this), t, e), o = Yk(qk(n = this, n[Gk])), i = 0, s = r.length, c = new o(s); s > i;)c[i] = r[i++]; return c }, Pe(function() { new Int8Array(1).slice() })); var Kl = We("unscopables"), Wl = Array.prototype; Wl[Kl] == null && dt.f(Wl, Kl, { configurable: !0, value: sr(null) }); var Ws = function(t) { Wl[Kl][t] = !0 }, Zk = Hy.includes, Jk = Pe(function() { return !Array(1).includes() }); et({ target: "Array", proto: !0, forced: Jk }, { includes: function(t) { return Zk(this, t, arguments.length > 1 ? arguments[1] : void 0) } }), Ws("includes"), sf("Array", "includes"); var Qk = de("".indexOf); et({ target: "String", proto: !0, forced: !zy("includes") }, { includes: function(t) { return !!~Qk(In(Xi(this)), In(Wy(t)), arguments.length > 1 ? arguments[1] : void 0) } }), sf("String", "includes"); var eR = dt.f, tR = hn.set, nR = hn.getterFor("Array Iterator"); hf(Array, "Array", function(t, e) { tR(this, { type: "Array Iterator", target: yn(t), index: 0, kind: e }) }, function() { var t = nR(this), e = t.target, n = t.kind, r = t.index++; return !e || r >= e.length ? (t.target = void 0, { value: void 0, done: !0 }) : n == "keys" ? { value: r, done: !1 } : n == "values" ? { value: e[r], done: !1 } : { value: [r, e[r]], done: !1 } }, "values"); var Sp = Do.Arguments = Do.Array; if (Ws("keys"), Ws("values"), Ws("entries"), xe && Sp.name !== "values") try { eR(Sp, "name", { value: "values" }) } catch { } var Cp = Pe(function() { if (typeof ArrayBuffer == "function") { var t = new ArrayBuffer(8); Object.isExtensible(t) && Object.defineProperty(t, "a", { value: 8 }) } }), Cs = Object.isExtensible, zc = Pe(function() { Cs(1) }) || Cp ? function(t) { return !!je(t) && (!Cp || On(t) != "ArrayBuffer") && (!Cs || Cs(t)) } : Cs, rR = !Pe(function() { return Object.isExtensible(Object.preventExtensions({})) }), ho = qo(function(t) { var e = dt.f, n = !1, r = Br("meta"), o = 0, i = function(c) { e(c, r, { value: { objectID: "O" + o++, weakData: {} } }) }, s = t.exports = { enable: function() { s.enable = function() { }, n = !0; var c = Bi.f, u = de([].splice), a = {}; a[r] = 1, c(a).length && (Bi.f = function(d) { for (var h = c(d), m = 0, g = h.length; m < g; m++)if (h[m] === r) { u(h, m, 1); break } return h }, et({ target: "Object", stat: !0, forced: !0 }, { getOwnPropertyNames: uf.f })) }, fastKey: function(c, u) { if (!je(c)) return typeof c == "symbol" ? c : (typeof c == "string" ? "S" : "P") + c; if (!ne(c, r)) { if (!zc(c)) return "F"; if (!u) return "E"; i(c) } return c[r].objectID }, getWeakData: function(c, u) { if (!ne(c, r)) { if (!zc(c)) return !0; if (!u) return !1; i(c) } return c[r].weakData }, onFreeze: function(c) { return rR && n && zc(c) && !ne(c, r) && i(c), c } }; Xo[r] = !0 }); ho.enable, ho.fastKey, ho.getWeakData, ho.onFreeze; var oR = q.TypeError, zs = function(t, e) { this.stopped = t, this.result = e }, Op = zs.prototype, vw = function(t, e, n) { var r, o, i, s, c, u, a, d = n && n.that, h = !(!n || !n.AS_ENTRIES), m = !(!n || !n.IS_ITERATOR), g = !(!n || !n.INTERRUPTED), y = Za(e, d), _ = function(E) { return r && jl(r, "normal", E), new zs(!0, E) }, A = function(E) { return h ? (Qe(E), g ? y(E[0], E[1], _) : y(E[0], E[1])) : g ? y(E, _) : y(E) }; if (m) r = t; else { if (!(o = pf(t))) throw oR(Go(t) + " is not iterable"); if (pw(o)) { for (i = 0, s = Zo(t); s > i; i++)if ((c = A(t[i])) && Dr(Op, c)) return c; return new zs(!1) } r = mw(t, o) } for (u = r.next; !(a = gt(u, r)).done;) { try { c = A(a.value) } catch (E) { jl(r, "throw", E) } if (typeof c == "object" && c && Dr(Op, c)) return c } return new zs(!1) }, iR = q.TypeError, _w = function(t, e) { if (Dr(e, t)) return t; throw iR("Incorrect invocation") }, xp = function(t, e, n) { for (var r in e) bt(t, r, e[r], n); return t }, kp = We("species"), sR = dt.f, Rp = ho.fastKey, Ip = hn.set, qc = hn.getterFor, aR = { getConstructor: function(t, e, n, r) { var o = t(function(a, d) { _w(a, i), Ip(a, { type: e, index: sr(null), first: void 0, last: void 0, size: 0 }), xe || (a.size = 0), d != null && vw(d, a[r], { that: a, AS_ENTRIES: n }) }), i = o.prototype, s = qc(e), c = function(a, d, h) { var m, g, y = s(a), _ = u(a, d); return _ ? _.value = h : (y.last = _ = { index: g = Rp(d, !0), key: d, value: h, previous: m = y.last, next: void 0, removed: !1 }, y.first || (y.first = _), m && (m.next = _), xe ? y.size++ : a.size++, g !== "F" && (y.index[g] = _)), a }, u = function(a, d) { var h, m = s(a), g = Rp(d); if (g !== "F") return m.index[g]; for (h = m.first; h; h = h.next)if (h.key == d) return h }; return xp(i, { clear: function() { for (var a = s(this), d = a.index, h = a.first; h;)h.removed = !0, h.previous && (h.previous = h.previous.next = void 0), delete d[h.index], h = h.next; a.first = a.last = void 0, xe ? a.size = 0 : this.size = 0 }, delete: function(a) { var d = this, h = s(d), m = u(d, a); if (m) { var g = m.next, y = m.previous; delete h.index[m.index], m.removed = !0, y && (y.next = g), g && (g.previous = y), h.first == m && (h.first = g), h.last == m && (h.last = y), xe ? h.size-- : d.size-- } return !!m }, forEach: function(a) { for (var d, h = s(this), m = Za(a, arguments.length > 1 ? arguments[1] : void 0); d = d ? d.next : h.first;)for (m(d.value, d.key, this); d && d.removed;)d = d.previous }, has: function(a) { return !!u(this, a) } }), xp(i, n ? { get: function(a) { var d = u(this, a); return d && d.value }, set: function(a, d) { return c(this, a === 0 ? 0 : a, d) } } : { add: function(a) { return c(this, a = a === 0 ? 0 : a, a) } }), xe && sR(i, "size", { get: function() { return s(this).size } }), o }, setStrong: function(t, e, n) { var r = e + " Iterator", o = qc(e), i = qc(r); hf(t, e, function(s, c) { Ip(this, { type: r, target: s, state: o(s), kind: c, last: void 0 }) }, function() { for (var s = i(this), c = s.kind, u = s.last; u && u.removed;)u = u.previous; return s.target && (s.last = u = u ? u.next : s.state.first) ? c == "keys" ? { value: u.key, done: !1 } : c == "values" ? { value: u.value, done: !1 } : { value: [u.key, u.value], done: !1 } : (s.target = void 0, { value: void 0, done: !0 }) }, n ? "entries" : "values", !n, !0), function(s) { var c = Jt(s), u = dt.f; xe && c && !c[kp] && u(c, kp, { configurable: !0, get: function() { return this } }) }(e) } }; function Ew(t) { var e = this.constructor; return this.then(function(n) { return e.resolve(t()).then(function() { return n }) }, function(n) { return e.resolve(t()).then(function() { return e.reject(n) }) }) } function Aw(t) { return new this(function(e, n) { if (!t || t.length === void 0) return n(new TypeError(typeof t + " " + t + " is not iterable(cannot read property Symbol(Symbol.iterator))")); var r = Array.prototype.slice.call(t); if (r.length === 0) return e([]); var o = r.length; function i(c, u) { if (u && (typeof u == "object" || typeof u == "function")) { var a = u.then; if (typeof a == "function") return void a.call(u, function(d) { i(c, d) }, function(d) { r[c] = { status: "rejected", reason: d }, --o == 0 && e(r) }) } r[c] = { status: "fulfilled", value: u }, --o == 0 && e(r) } for (var s = 0; s < r.length; s++)i(s, r[s]) }) } (function(t, e, n) { var r = t.indexOf("Map") !== -1, o = t.indexOf("Weak") !== -1, i = r ? "set" : "add", s = q[t], c = s && s.prototype, u = s, a = {}, d = function(A) { var E = de(c[A]); bt(c, A, A == "add" ? function(T) { return E(this, T === 0 ? 0 : T), this } : A == "delete" ? function(T) { return !(o && !je(T)) && E(this, T === 0 ? 0 : T) } : A == "get" ? function(T) { return o && !je(T) ? void 0 : E(this, T === 0 ? 0 : T) } : A == "has" ? function(T) { return !(o && !je(T)) && E(this, T === 0 ? 0 : T) } : function(T, x) { return E(this, T === 0 ? 0 : T, x), this }) }; if (Dl(t, !Ne(s) || !(o || c.forEach && !Pe(function() { new s().entries().next() })))) u = n.getConstructor(e, t, r, i), ho.enable(); else if (Dl(t, !0)) { var h = new u, m = h[i](o ? {} : -0, 1) != h, g = Pe(function() { h.has(1) }), y = ww(function(A) { new s(A) }), _ = !o && Pe(function() { for (var A = new s, E = 5; E--;)A[i](E, E); return !A.has(-0) }); y || ((u = e(function(A, E) { _w(A, c); var T = function(x, P, W) { var Y, Z; return pn && Ne(Y = P.constructor) && Y !== W && je(Z = Y.prototype) && Z !== W.prototype && pn(x, Z), x }(new s, A, u); return E != null && vw(E, T[i], { that: T, AS_ENTRIES: r }), T })).prototype = c, c.constructor = u), (g || _) && (d("delete"), d("has"), r && d("get")), (_ || m) && d(i), o && c.clear && delete c.clear } a[t] = u, et({ global: !0, forced: u != s }, a), Yn(u, t), o || n.setStrong(u, t, r) })("Set", function(t) { return function() { return t(this, arguments.length ? arguments[0] : void 0) } }, aR), Mi.Set; var cR = setTimeout; function Pp(t) { return !!(t && t.length !== void 0) } function lR() { } function Me(t) { if (!(this instanceof Me)) throw new TypeError("Promises must be constructed via new"); if (typeof t != "function") throw new TypeError("not a function"); this._state = 0, this._handled = !1, this._value = void 0, this._deferreds = [], Sw(t, this) } function Tw(t, e) { for (; t._state === 3;)t = t._value; t._state !== 0 ? (t._handled = !0, Me._immediateFn(function() { var n = t._state === 1 ? e.onFulfilled : e.onRejected; if (n !== null) { var r; try { r = n(t._value) } catch (o) { return void Fi(e.promise, o) } zl(e.promise, r) } else (t._state === 1 ? zl : Fi)(e.promise, t._value) })) : t._deferreds.push(e) } function zl(t, e) { try { if (e === t) throw new TypeError("A promise cannot be resolved with itself."); if (e && (typeof e == "object" || typeof e == "function")) { var n = e.then; if (e instanceof Me) return t._state = 3, t._value = e, void ql(t); if (typeof n == "function") return void Sw((r = n, o = e, function() { r.apply(o, arguments) }), t) } t._state = 1, t._value = e, ql(t) } catch (i) { Fi(t, i) } var r, o } function Fi(t, e) { t._state = 2, t._value = e, ql(t) } function ql(t) { t._state === 2 && t._deferreds.length === 0 && Me._immediateFn(function() { t._handled || Me._unhandledRejectionFn(t._value) }); for (var e = 0, n = t._deferreds.length; e < n; e++)Tw(t, t._deferreds[e]); t._deferreds = null } function uR(t, e, n) { this.onFulfilled = typeof t == "function" ? t : null, this.onRejected = typeof e == "function" ? e : null, this.promise = n } function Sw(t, e) { var n = !1; try { t(function(r) { n || (n = !0, zl(e, r)) }, function(r) { n || (n = !0, Fi(e, r)) }) } catch (r) { if (n) return; n = !0, Fi(e, r) } } Me.prototype.catch = function(t) { return this.then(null, t) }, Me.prototype.then = function(t, e) { var n = new this.constructor(lR); return Tw(this, new uR(t, e, n)), n }, Me.prototype.finally = Ew, Me.all = function(t) { return new Me(function(e, n) { if (!Pp(t)) return n(new TypeError("Promise.all accepts an array")); var r = Array.prototype.slice.call(t); if (r.length === 0) return e([]); var o = r.length; function i(c, u) { try { if (u && (typeof u == "object" || typeof u == "function")) { var a = u.then; if (typeof a == "function") return void a.call(u, function(d) { i(c, d) }, n) } r[c] = u, --o == 0 && e(r) } catch (d) { n(d) } } for (var s = 0; s < r.length; s++)i(s, r[s]) }) }, Me.allSettled = Aw, Me.resolve = function(t) { return t && typeof t == "object" && t.constructor === Me ? t : new Me(function(e) { e(t) }) }, Me.reject = function(t) { return new Me(function(e, n) { n(t) }) }, Me.race = function(t) { return new Me(function(e, n) { if (!Pp(t)) return n(new TypeError("Promise.race accepts an array")); for (var r = 0, o = t.length; r < o; r++)Me.resolve(t[r]).then(e, n) }) }, Me._immediateFn = typeof setImmediate == "function" && function(t) { setImmediate(t) } || function(t) { cR(t, 0) }, Me._unhandledRejectionFn = function(t) { typeof console < "u" && console && console.warn("Possible Unhandled Promise Rejection:", t) }; var eo = function() { if (typeof self < "u") return self; if (typeof window < "u") return window; if (typeof global < "u") return global; throw new Error("unable to locate global object") }(); typeof eo.Promise != "function" ? eo.Promise = Me : (eo.Promise.prototype.finally || (eo.Promise.prototype.finally = Ew), eo.Promise.allSettled || (eo.Promise.allSettled = Aw)), function(t) { function e() { } function n(s, c) { if (s = s === void 0 ? "utf-8" : s, c = c === void 0 ? { fatal: !1 } : c, o.indexOf(s.toLowerCase()) === -1) throw new RangeError("Failed to construct 'TextDecoder': The encoding label provided ('" + s + "') is invalid."); if (c.fatal) throw Error("Failed to construct 'TextDecoder': the 'fatal' option is unsupported.") } function r(s) { for (var c = 0, u = Math.min(65536, s.length + 1), a = new Uint16Array(u), d = [], h = 0; ;) { var m = c < s.length; if (!m || h >= u - 1) { if (d.push(String.fromCharCode.apply(null, a.subarray(0, h))), !m) return d.join(""); s = s.subarray(c), h = c = 0 } if (!(128 & (m = s[c++]))) a[h++] = m; else if ((224 & m) == 192) { var g = 63 & s[c++]; a[h++] = (31 & m) << 6 | g } else if ((240 & m) == 224) { g = 63 & s[c++]; var y = 63 & s[c++]; a[h++] = (31 & m) << 12 | g << 6 | y } else (248 & m) == 240 && (65535 < (m = (7 & m) << 18 | (g = 63 & s[c++]) << 12 | (y = 63 & s[c++]) << 6 | 63 & s[c++]) && (m -= 65536, a[h++] = m >>> 10 & 1023 | 55296, m = 56320 | 1023 & m), a[h++] = m) } } if (t.TextEncoder && t.TextDecoder) return !1; var o = ["utf-8", "utf8", "unicode-1-1-utf-8"]; Object.defineProperty(e.prototype, "encoding", { value: "utf-8" }), e.prototype.encode = function(s, c) { if ((c = c === void 0 ? { stream: !1 } : c).stream) throw Error("Failed to encode: the 'stream' option is unsupported."); c = 0; for (var u = s.length, a = 0, d = Math.max(32, u + (u >>> 1) + 7), h = new Uint8Array(d >>> 3 << 3); c < u;) { var m = s.charCodeAt(c++); if (55296 <= m && 56319 >= m) { if (c < u) { var g = s.charCodeAt(c); (64512 & g) == 56320 && (++c, m = ((1023 & m) << 10) + (1023 & g) + 65536) } if (55296 <= m && 56319 >= m) continue } if (a + 4 > h.length && (d += 8, d = (d *= 1 + c / s.length * 2) >>> 3 << 3, (g = new Uint8Array(d)).set(h), h = g), (4294967168 & m) == 0) h[a++] = m; else { if (!(4294965248 & m)) h[a++] = m >>> 6 & 31 | 192; else if (!(4294901760 & m)) h[a++] = m >>> 12 & 15 | 224, h[a++] = m >>> 6 & 63 | 128; else { if (4292870144 & m) continue; h[a++] = m >>> 18 & 7 | 240, h[a++] = m >>> 12 & 63 | 128, h[a++] = m >>> 6 & 63 | 128 } h[a++] = 63 & m | 128 } } return h.slice ? h.slice(0, a) : h.subarray(0, a) }, Object.defineProperty(n.prototype, "encoding", { value: "utf-8" }), Object.defineProperty(n.prototype, "fatal", { value: !1 }), Object.defineProperty(n.prototype, "ignoreBOM", { value: !1 }); var i = r; typeof Buffer == "function" && Buffer.from ? i = function(s) { return Buffer.from(s.buffer, s.byteOffset, s.byteLength).toString("utf-8") } : typeof Blob == "function" && typeof URL == "function" && typeof URL.createObjectURL == "function" && (i = function(s) { var c = URL.createObjectURL(new Blob([s], { type: "text/plain;charset=UTF-8" })); try { var u = new XMLHttpRequest; return u.open("GET", c, !1), u.send(), u.responseText } catch { return r(s) } finally { URL.revokeObjectURL(c) } }), n.prototype.decode = function(s, c) { if ((c = c === void 0 ? { stream: !1 } : c).stream) throw Error("Failed to decode: the 'stream' option is unsupported."); return s = s instanceof Uint8Array ? s : s.buffer instanceof ArrayBuffer ? new Uint8Array(s.buffer) : new Uint8Array(s), i(s) }, t.TextEncoder = e, t.TextDecoder = n }(typeof window < "u" ? window : an), function() { function t(A, E) { if (!(A instanceof E)) throw new TypeError("Cannot call a class as a function") } function e(A, E) { for (var T = 0; T < E.length; T++) { var x = E[T]; x.enumerable = x.enumerable || !1, x.configurable = !0, "value" in x && (x.writable = !0), Object.defineProperty(A, x.key, x) } } function n(A, E, T) { return E && e(A.prototype, E), T && e(A, T), A } function r(A, E) { if (typeof E != "function" && E !== null) throw new TypeError("Super expression must either be null or a function"); A.prototype = Object.create(E && E.prototype, { constructor: { value: A, writable: !0, configurable: !0 } }), E && i(A, E) } function o(A) { return o = Object.setPrototypeOf ? Object.getPrototypeOf : function(E) { return E.__proto__ || Object.getPrototypeOf(E) }, o(A) } function i(A, E) { return i = Object.setPrototypeOf || function(T, x) { return T.__proto__ = x, T }, i(A, E) } function s() { if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1; if (typeof Proxy == "function") return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() { })), !0 } catch { return !1 } } function c(A) { if (A === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return A } function u(A, E) { return !E || typeof E != "object" && typeof E != "function" ? c(A) : E } function a(A) { var E = s(); return function() { var T, x = o(A); if (E) { var P = o(this).constructor; T = Reflect.construct(x, arguments, P) } else T = x.apply(this, arguments); return u(this, T) } } function d(A, E) { for (; !Object.prototype.hasOwnProperty.call(A, E) && (A = o(A)) !== null;); return A } function h(A, E, T) { return h = typeof Reflect < "u" && Reflect.get ? Reflect.get : function(x, P, W) { var Y = d(x, P); if (Y) { var Z = Object.getOwnPropertyDescriptor(Y, P); return Z.get ? Z.get.call(W) : Z.value } }, h(A, E, T || A) } var m = function() { function A() { t(this, A), Object.defineProperty(this, "listeners", { value: {}, writable: !0, configurable: !0 }) } return n(A, [{ key: "addEventListener", value: function(E, T, x) { E in this.listeners || (this.listeners[E] = []), this.listeners[E].push({ callback: T, options: x }) } }, { key: "removeEventListener", value: function(E, T) { if (E in this.listeners) { for (var x = this.listeners[E], P = 0, W = x.length; P < W; P++)if (x[P].callback === T) return void x.splice(P, 1) } } }, { key: "dispatchEvent", value: function(E) { if (E.type in this.listeners) { for (var T = this.listeners[E.type].slice(), x = 0, P = T.length; x < P; x++) { var W = T[x]; try { W.callback.call(this, E) } catch (Y) { Promise.resolve().then(function() { throw Y }) } W.options && W.options.once && this.removeEventListener(E.type, W.callback) } return !E.defaultPrevented } } }]), A }(), g = function(A) { r(T, A); var E = a(T); function T() { var x; return t(this, T), (x = E.call(this)).listeners || m.call(c(x)), Object.defineProperty(c(x), "aborted", { value: !1, writable: !0, configurable: !0 }), Object.defineProperty(c(x), "onabort", { value: null, writable: !0, configurable: !0 }), x } return n(T, [{ key: "toString", value: function() { return "[object AbortSignal]" } }, { key: "dispatchEvent", value: function(x) { x.type === "abort" && (this.aborted = !0, typeof this.onabort == "function" && this.onabort.call(this, x)), h(o(T.prototype), "dispatchEvent", this).call(this, x) } }]), T }(m), y = function() { function A() { t(this, A), Object.defineProperty(this, "signal", { value: new g, writable: !0, configurable: !0 }) } return n(A, [{ key: "abort", value: function() { var E; try { E = new Event("abort") } catch { typeof document < "u" ? document.createEvent ? (E = document.createEvent("Event")).initEvent("abort", !1, !1) : (E = document.createEventObject()).type = "abort" : E = { type: "abort", bubbles: !1, cancelable: !1 } } this.signal.dispatchEvent(E) } }, { key: "toString", value: function() { return "[object AbortController]" } }]), A }(); function _(A) { return A.__FORCE_INSTALL_ABORTCONTROLLER_POLYFILL ? (console.log("__FORCE_INSTALL_ABORTCONTROLLER_POLYFILL=true is set, will force install polyfill"), !0) : typeof A.Request == "function" && !A.Request.prototype.hasOwnProperty("signal") || !A.AbortController } typeof Symbol < "u" && Symbol.toStringTag && (y.prototype[Symbol.toStringTag] = "AbortController", g.prototype[Symbol.toStringTag] = "AbortSignal"), function(A) { _(A) && (A.AbortController = y, A.AbortSignal = g) }(typeof self < "u" ? self : an) }(); var gr = qo(function(t, e) { Object.defineProperty(e, "__esModule", { value: !0 }); var n = function() { function r() { var o = this; this.locked = new Map, this.addToLocked = function(i, s) { var c = o.locked.get(i); c === void 0 ? s === void 0 ? o.locked.set(i, []) : o.locked.set(i, [s]) : s !== void 0 && (c.unshift(s), o.locked.set(i, c)) }, this.isLocked = function(i) { return o.locked.has(i) }, this.lock = function(i) { return new Promise(function(s, c) { o.isLocked(i) ? o.addToLocked(i, s) : (o.addToLocked(i), s()) }) }, this.unlock = function(i) { var s = o.locked.get(i); if (s !== void 0 && s.length !== 0) { var c = s.pop(); o.locked.set(i, s), c !== void 0 && setTimeout(c, 0) } else o.locked.delete(i) } } return r.getInstance = function() { return r.instance === void 0 && (r.instance = new r), r.instance }, r }(); e.default = function() { return n.getInstance() } }); Xu(gr); var fR = qo(function(t, e) { var n = an && an.__awaiter || function(u, a, d, h) { return new (d || (d = Promise))(function(m, g) { function y(E) { try { A(h.next(E)) } catch (T) { g(T) } } function _(E) { try { A(h.throw(E)) } catch (T) { g(T) } } function A(E) { E.done ? m(E.value) : new d(function(T) { T(E.value) }).then(y, _) } A((h = h.apply(u, a || [])).next()) }) }, r = an && an.__generator || function(u, a) { var d, h, m, g, y = { label: 0, sent: function() { if (1 & m[0]) throw m[1]; return m[1] }, trys: [], ops: [] }; return g = { next: _(0), throw: _(1), return: _(2) }, typeof Symbol == "function" && (g[Symbol.iterator] = function() { return this }), g; function _(A) { return function(E) { return function(T) { if (d) throw new TypeError("Generator is already executing."); for (; y;)try { if (d = 1, h && (m = 2 & T[0] ? h.return : T[0] ? h.throw || ((m = h.return) && m.call(h), 0) : h.next) && !(m = m.call(h, T[1])).done) return m; switch (h = 0, m && (T = [2 & T[0], m.value]), T[0]) { case 0: case 1: m = T; break; case 4: return y.label++, { value: T[1], done: !1 }; case 5: y.label++, h = T[1], T = [0]; continue; case 7: T = y.ops.pop(), y.trys.pop(); continue; default: if (m = y.trys, !((m = m.length > 0 && m[m.length - 1]) || T[0] !== 6 && T[0] !== 2)) { y = 0; continue } if (T[0] === 3 && (!m || T[1] > m[0] && T[1] < m[3])) { y.label = T[1]; break } if (T[0] === 6 && y.label < m[1]) { y.label = m[1], m = T; break } if (m && y.label < m[2]) { y.label = m[2], y.ops.push(T); break } m[2] && y.ops.pop(), y.trys.pop(); continue }T = a.call(u, y) } catch (x) { T = [6, x], h = 0 } finally { d = m = 0 } if (5 & T[0]) throw T[1]; return { value: T[0] ? T[1] : void 0, done: !0 } }([A, E]) } } }; Object.defineProperty(e, "__esModule", { value: !0 }); var o = "browser-tabs-lock-key"; function i(u) { return new Promise(function(a) { return setTimeout(a, u) }) } function s(u) { for (var a = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz", d = "", h = 0; h < u; h++)d += a[Math.floor(Math.random() * a.length)]; return d } var c = function() { function u() { this.acquiredIatSet = new Set, this.id = Date.now().toString() + s(15), this.acquireLock = this.acquireLock.bind(this), this.releaseLock = this.releaseLock.bind(this), this.releaseLock__private__ = this.releaseLock__private__.bind(this), this.waitForSomethingToChange = this.waitForSomethingToChange.bind(this), this.refreshLockWhileAcquired = this.refreshLockWhileAcquired.bind(this), u.waiters === void 0 && (u.waiters = []) } return u.prototype.acquireLock = function(a, d) { return d === void 0 && (d = 5e3), n(this, void 0, void 0, function() { var h, m, g, y, _, A; return r(this, function(E) { switch (E.label) { case 0: h = Date.now() + s(4), m = Date.now() + d, g = o + "-" + a, y = window.localStorage, E.label = 1; case 1: return Date.now() < m ? [4, i(30)] : [3, 8]; case 2: return E.sent(), y.getItem(g) !== null ? [3, 5] : (_ = this.id + "-" + a + "-" + h, [4, i(Math.floor(25 * Math.random()))]); case 3: return E.sent(), y.setItem(g, JSON.stringify({ id: this.id, iat: h, timeoutKey: _, timeAcquired: Date.now(), timeRefreshed: Date.now() })), [4, i(30)]; case 4: return E.sent(), (A = y.getItem(g)) !== null && (A = JSON.parse(A)).id === this.id && A.iat === h ? (this.acquiredIatSet.add(h), this.refreshLockWhileAcquired(g, h), [2, !0]) : [3, 7]; case 5: return u.lockCorrector(), [4, this.waitForSomethingToChange(m)]; case 6: E.sent(), E.label = 7; case 7: return h = Date.now() + s(4), [3, 1]; case 8: return [2, !1] } }) }) }, u.prototype.refreshLockWhileAcquired = function(a, d) { return n(this, void 0, void 0, function() { var h = this; return r(this, function(m) { return setTimeout(function() { return n(h, void 0, void 0, function() { var g, y; return r(this, function(_) { switch (_.label) { case 0: return [4, gr.default().lock(d)]; case 1: return _.sent(), this.acquiredIatSet.has(d) ? (g = window.localStorage, (y = g.getItem(a)) === null ? (gr.default().unlock(d), [2]) : ((y = JSON.parse(y)).timeRefreshed = Date.now(), g.setItem(a, JSON.stringify(y)), gr.default().unlock(d), this.refreshLockWhileAcquired(a, d), [2])) : (gr.default().unlock(d), [2]) } }) }) }, 1e3), [2] }) }) }, u.prototype.waitForSomethingToChange = function(a) { return n(this, void 0, void 0, function() { return r(this, function(d) { switch (d.label) { case 0: return [4, new Promise(function(h) { var m = !1, g = Date.now(), y = !1; function _() { if (y || (window.removeEventListener("storage", _), u.removeFromWaiting(_), clearTimeout(A), y = !0), !m) { m = !0; var E = 50 - (Date.now() - g); E > 0 ? setTimeout(h, E) : h() } } window.addEventListener("storage", _), u.addToWaiting(_); var A = setTimeout(_, Math.max(0, a - Date.now())) })]; case 1: return d.sent(), [2] } }) }) }, u.addToWaiting = function(a) { this.removeFromWaiting(a), u.waiters !== void 0 && u.waiters.push(a) }, u.removeFromWaiting = function(a) { u.waiters !== void 0 && (u.waiters = u.waiters.filter(function(d) { return d !== a })) }, u.notifyWaiters = function() { u.waiters !== void 0 && u.waiters.slice().forEach(function(a) { return a() }) }, u.prototype.releaseLock = function(a) { return n(this, void 0, void 0, function() { return r(this, function(d) { switch (d.label) { case 0: return [4, this.releaseLock__private__(a)]; case 1: return [2, d.sent()] } }) }) }, u.prototype.releaseLock__private__ = function(a) { return n(this, void 0, void 0, function() { var d, h, m; return r(this, function(g) { switch (g.label) { case 0: return d = window.localStorage, h = o + "-" + a, (m = d.getItem(h)) === null ? [2] : (m = JSON.parse(m)).id !== this.id ? [3, 2] : [4, gr.default().lock(m.iat)]; case 1: g.sent(), this.acquiredIatSet.delete(m.iat), d.removeItem(h), gr.default().unlock(m.iat), u.notifyWaiters(), g.label = 2; case 2: return [2] } }) }) }, u.lockCorrector = function() { for (var a = Date.now() - 5e3, d = window.localStorage, h = Object.keys(d), m = !1, g = 0; g < h.length; g++) { var y = h[g]; if (y.includes(o)) { var _ = d.getItem(y); _ !== null && ((_ = JSON.parse(_)).timeRefreshed === void 0 && _.timeAcquired < a || _.timeRefreshed !== void 0 && _.timeRefreshed < a) && (d.removeItem(y), m = !0) } } m && u.notifyWaiters() }, u.waiters = void 0, u }(); e.default = c }), dR = Xu(fR), hR = { timeoutInSeconds: 60 }, pR = ["login_required", "consent_required", "interaction_required", "account_selection_required", "access_denied"], Cw = { name: "auth0-spa-js", version: "1.22.0" }, Ow = function() { return Date.now() }, Nn = function(t) { function e(n, r) { var o = t.call(this, r) || this; return o.error = n, o.error_description = r, Object.setPrototypeOf(o, e.prototype), o } return Hr(e, t), e.fromPayload = function(n) { return new e(n.error, n.error_description) }, e }(Error), mR = function(t) { function e(n, r, o, i) { i === void 0 && (i = null); var s = t.call(this, n, r) || this; return s.state = o, s.appState = i, Object.setPrototypeOf(s, e.prototype), s } return Hr(e, t), e }(Nn), Gl = function(t) { function e() { var n = t.call(this, "timeout", "Timeout") || this; return Object.setPrototypeOf(n, e.prototype), n } return Hr(e, t), e }(Nn), gR = function(t) { function e(n) { var r = t.call(this) || this; return r.popup = n, Object.setPrototypeOf(r, e.prototype), r } return Hr(e, t), e }(Gl), yR = function(t) { function e(n) { var r = t.call(this, "cancelled", "Popup closed") || this; return r.popup = n, Object.setPrototypeOf(r, e.prototype), r } return Hr(e, t), e }(Nn), wR = function(t) { function e(n, r, o) { var i = t.call(this, n, r) || this; return i.mfa_token = o, Object.setPrototypeOf(i, e.prototype), i } return Hr(e, t), e }(Nn), bR = function(t) { function e(n, r) { var o = t.call(this, "missing_refresh_token", "Missing Refresh Token (audience: '".concat(Lp(n, ["default"]), "', scope: '").concat(Lp(r), "')")) || this; return o.audience = n, o.scope = r, Object.setPrototypeOf(o, e.prototype), o } return Hr(e, t), e }(Nn), vR = function(t) { return new Promise(function(e, n) { var r, o = setInterval(function() { t.popup && t.popup.closed && (clearInterval(o), clearTimeout(i), window.removeEventListener("message", r, !1), n(new yR(t.popup))) }, 1e3), i = setTimeout(function() { clearInterval(o), n(new gR(t.popup)), window.removeEventListener("message", r, !1) }, 1e3 * (t.timeoutInSeconds || 60)); r = function(s) { if (s.data && s.data.type === "authorization_response") { if (clearTimeout(i), clearInterval(o), window.removeEventListener("message", r, !1), t.popup.close(), s.data.response.error) return n(Nn.fromPayload(s.data.response)); e(s.data.response) } }, window.addEventListener("message", r) }) }, yf = function() { return window.crypto || window.msCrypto }, xw = function() { var t = yf(); return t.subtle || t.webkitSubtle }, wn = function() { var t = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_~.", e = ""; return Array.from(yf().getRandomValues(new Uint8Array(43))).forEach(function(n) { return e += t[n % t.length] }), e }, to = function(t) { return btoa(t) }, Yl = function(t) { return Object.keys(t).filter(function(e) { return t[e] !== void 0 }).map(function(e) { return encodeURIComponent(e) + "=" + encodeURIComponent(t[e]) }).join("&") }, Gc = function(t) { return _e(void 0, void 0, void 0, function() { var e; return Ee(this, function(n) { switch (n.label) { case 0: return e = xw().digest({ name: "SHA-256" }, new TextEncoder().encode(t)), window.msCrypto ? [2, new Promise(function(r, o) { e.oncomplete = function(i) { r(i.target.result) }, e.onerror = function(i) { o(i.error) }, e.onabort = function() { o("The digest operation was aborted") } })] : [4, e]; case 1: return [2, n.sent()] } }) }) }, Np = function(t) { return function(e) { return decodeURIComponent(atob(e).split("").map(function(n) { return "%" + ("00" + n.charCodeAt(0).toString(16)).slice(-2) }).join("")) }(t.replace(/_/g, "/").replace(/-/g, "+")) }, Yc = function(t) { var e = new Uint8Array(t); return function(n) { var r = { "+": "-", "/": "_", "=": "" }; return n.replace(/[+/=]/g, function(o) { return r[o] }) }(window.btoa(String.fromCharCode.apply(String, Rl([], No(Array.from(e)), !1)))) }; function Lp(t, e) { return e === void 0 && (e = []), t && !e.includes(t) ? t : "" } var _R = function(t, e) { return _e(void 0, void 0, void 0, function() { var n, r; return Ee(this, function(o) { switch (o.label) { case 0: return [4, (i = t, s = e, s = s || {}, new Promise(function(c, u) { var a = new XMLHttpRequest, d = [], h = [], m = {}, g = function() { return { ok: (a.status / 100 | 0) == 2, statusText: a.statusText, status: a.status, url: a.responseURL, text: function() { return Promise.resolve(a.responseText) }, json: function() { return Promise.resolve(a.responseText).then(JSON.parse) }, blob: function() { return Promise.resolve(new Blob([a.response])) }, clone: g, headers: { keys: function() { return d }, entries: function() { return h }, get: function(_) { return m[_.toLowerCase()] }, has: function(_) { return _.toLowerCase() in m } } } }; for (var y in a.open(s.method || "get", i, !0), a.onload = function() { a.getAllResponseHeaders().replace(/^(.*?):[^\S\n]*([\s\S]*?)$/gm, function(_, A, E) { d.push(A = A.toLowerCase()), h.push([A, E]), m[A] = m[A] ? m[A] + "," + E : E }), c(g()) }, a.onerror = u, a.withCredentials = s.credentials == "include", s.headers) a.setRequestHeader(y, s.headers[y]); a.send(s.body || null) }))]; case 1: return n = o.sent(), r = { ok: n.ok }, [4, n.json()]; case 2: return [2, (r.json = o.sent(), r)] }var i, s }) }) }, ER = function(t, e, n) { return _e(void 0, void 0, void 0, function() { var r, o; return Ee(this, function(i) { return r = new AbortController, e.signal = r.signal, [2, Promise.race([_R(t, e), new Promise(function(s, c) { o = setTimeout(function() { r.abort(), c(new Error("Timeout when executing 'fetch'")) }, n) })]).finally(function() { clearTimeout(o) })] }) }) }, AR = function(t, e, n, r, o, i, s) { return _e(void 0, void 0, void 0, function() { return Ee(this, function(c) { return [2, (u = { auth: { audience: e, scope: n }, timeout: o, fetchUrl: t, fetchOptions: r, useFormData: s }, a = i, new Promise(function(d, h) { var m = new MessageChannel; m.port1.onmessage = function(g) { g.data.error ? h(new Error(g.data.error)) : d(g.data) }, a.postMessage(u, [m.port2]) }))]; }) }) }, TR = function(t, e, n, r, o, i, s) { return s === void 0 && (s = 1e4), _e(void 0, void 0, void 0, function() { return Ee(this, function(c) { return o ? [2, AR(t, e, n, r, s, o, i)] : [2, ER(t, r, s)] }) }) }; function SR(t, e, n, r, o, i, s) { return _e(this, void 0, void 0, function() { var c, u, a, d, h, m, g, y, _; return Ee(this, function(A) { switch (A.label) { case 0: c = null, a = 0, A.label = 1; case 1: if (!(a < 3)) return [3, 6]; A.label = 2; case 2: return A.trys.push([2, 4, , 5]), [4, TR(t, n, r, o, i, s, e)]; case 3: return u = A.sent(), c = null, [3, 6]; case 4: return d = A.sent(), c = d, [3, 5]; case 5: return a++, [3, 1]; case 6: if (c) throw c.message = c.message || "Failed to fetch", c; if (h = u.json, m = h.error, g = h.error_description, y = Et(h, ["error", "error_description"]), !u.ok) throw _ = g || "HTTP error. Unable to fetch ".concat(t), m === "mfa_required" ? new wR(m, _, y.mfa_token) : new Nn(m || "request_error", _); return [2, y] } }) }) } function Os(t, e) { var n = t.baseUrl, r = t.timeout, o = t.audience, i = t.scope, s = t.auth0Client, c = t.useFormData, u = Et(t, ["baseUrl", "timeout", "audience", "scope", "auth0Client", "useFormData"]); return _e(this, void 0, void 0, function() { var a; return Ee(this, function(d) { switch (d.label) { case 0: return a = c ? Yl(u) : JSON.stringify(u), [4, SR("".concat(n, "/oauth/token"), r, o || "default", i, { method: "POST", body: a, headers: { "Content-Type": c ? "application/x-www-form-urlencoded" : "application/json", "Auth0-Client": btoa(JSON.stringify(s || Cw)) } }, e, c)]; case 1: return [2, d.sent()] } }) }) } var CR = function(t) { return Array.from(new Set(t)) }, Kn = function() { for (var t = [], e = 0; e < arguments.length; e++)t[e] = arguments[e]; return CR(t.join(" ").trim().split(/\s+/)).join(" ") }, vr = function() { function t(e, n) { n === void 0 && (n = "@@auth0spajs@@"), this.prefix = n, this.client_id = e.client_id, this.scope = e.scope, this.audience = e.audience } return t.prototype.toKey = function() { return "".concat(this.prefix, "::").concat(this.client_id, "::").concat(this.audience, "::").concat(this.scope) }, t.fromKey = function(e) { var n = No(e.split("::"), 4), r = n[0], o = n[1], i = n[2]; return new t({ client_id: o, scope: n[3], audience: i }, r) }, t.fromCacheEntry = function(e) { return new t({ scope: e.scope, audience: e.audience, client_id: e.client_id }) }, t }(), OR = function() { function t() { } return t.prototype.set = function(e, n) { localStorage.setItem(e, JSON.stringify(n)) }, t.prototype.get = function(e) { var n = window.localStorage.getItem(e); if (n) try { return JSON.parse(n) } catch { return } }, t.prototype.remove = function(e) { localStorage.removeItem(e) }, t.prototype.allKeys = function() { return Object.keys(window.localStorage).filter(function(e) { return e.startsWith("@@auth0spajs@@") }) }, t }(), xR = function() { var t; this.enclosedCache = (t = {}, { set: function(e, n) { t[e] = n }, get: function(e) { var n = t[e]; if (n) return n }, remove: function(e) { delete t[e] }, allKeys: function() { return Object.keys(t) } }) }, kR = function() { function t(e, n, r) { this.cache = e, this.keyManifest = n, this.nowProvider = r, this.nowProvider = this.nowProvider || Ow } return t.prototype.get = function(e, n) { var r; return n === void 0 && (n = 0), _e(this, void 0, void 0, function() { var o, i, s, c, u; return Ee(this, function(a) { switch (a.label) { case 0: return [4, this.cache.get(e.toKey())]; case 1: return (o = a.sent()) ? [3, 4] : [4, this.getCacheKeys()]; case 2: return (i = a.sent()) ? (s = this.matchExistingCacheKey(e, i)) ? [4, this.cache.get(s)] : [3, 4] : [2]; case 3: o = a.sent(), a.label = 4; case 4: return o ? [4, this.nowProvider()] : [2]; case 5: return c = a.sent(), u = Math.floor(c / 1e3), o.expiresAt - n < u ? o.body.refresh_token ? (o.body = { refresh_token: o.body.refresh_token }, [4, this.cache.set(e.toKey(), o)]) : [3, 7] : [3, 10]; case 6: return a.sent(), [2, o.body]; case 7: return [4, this.cache.remove(e.toKey())]; case 8: return a.sent(), [4, (r = this.keyManifest) === null || r === void 0 ? void 0 : r.remove(e.toKey())]; case 9: return a.sent(), [2]; case 10: return [2, o.body] } }) }) }, t.prototype.set = function(e) { var n; return _e(this, void 0, void 0, function() { var r, o; return Ee(this, function(i) { switch (i.label) { case 0: return r = new vr({ client_id: e.client_id, scope: e.scope, audience: e.audience }), [4, this.wrapCacheEntry(e)]; case 1: return o = i.sent(), [4, this.cache.set(r.toKey(), o)]; case 2: return i.sent(), [4, (n = this.keyManifest) === null || n === void 0 ? void 0 : n.add(r.toKey())]; case 3: return i.sent(), [2] } }) }) }, t.prototype.clear = function(e) { var n; return _e(this, void 0, void 0, function() { var r, o = this; return Ee(this, function(i) { switch (i.label) { case 0: return [4, this.getCacheKeys()]; case 1: return (r = i.sent()) ? [4, r.filter(function(s) { return !e || s.includes(e) }).reduce(function(s, c) { return _e(o, void 0, void 0, function() { return Ee(this, function(u) { switch (u.label) { case 0: return [4, s]; case 1: return u.sent(), [4, this.cache.remove(c)]; case 2: return u.sent(), [2] } }) }) }, Promise.resolve())] : [2]; case 2: return i.sent(), [4, (n = this.keyManifest) === null || n === void 0 ? void 0 : n.clear()]; case 3: return i.sent(), [2] } }) }) }, t.prototype.clearSync = function(e) { var n = this, r = this.cache.allKeys(); r && r.filter(function(o) { return !e || o.includes(e) }).forEach(function(o) { n.cache.remove(o) }) }, t.prototype.wrapCacheEntry = function(e) { return _e(this, void 0, void 0, function() { var n, r, o; return Ee(this, function(i) { switch (i.label) { case 0: return [4, this.nowProvider()]; case 1: return n = i.sent(), r = Math.floor(n / 1e3) + e.expires_in, o = Math.min(r, e.decodedToken.claims.exp), [2, { body: e, expiresAt: o }] } }) }) }, t.prototype.getCacheKeys = function() { var e; return _e(this, void 0, void 0, function() { var n; return Ee(this, function(r) { switch (r.label) { case 0: return this.keyManifest ? [4, this.keyManifest.get()] : [3, 2]; case 1: return n = (e = r.sent()) === null || e === void 0 ? void 0 : e.keys, [3, 4]; case 2: return [4, this.cache.allKeys()]; case 3: n = r.sent(), r.label = 4; case 4: return [2, n] } }) }) }, t.prototype.matchExistingCacheKey = function(e, n) { return n.filter(function(r) { var o = vr.fromKey(r), i = new Set(o.scope && o.scope.split(" ")), s = e.scope.split(" "), c = o.scope && s.reduce(function(u, a) { return u && i.has(a) }, !0); return o.prefix === "@@auth0spajs@@" && o.client_id === e.client_id && o.audience === e.audience && c })[0] }, t }(), RR = function() { function t(e, n) { this.storage = e, this.clientId = n, this.storageKey = "".concat("a0.spajs.txs", ".").concat(this.clientId), this.transaction = this.storage.get(this.storageKey) } return t.prototype.create = function(e) { this.transaction = e, this.storage.save(this.storageKey, e, { daysUntilExpire: 1 }) }, t.prototype.get = function() { return this.transaction }, t.prototype.remove = function() { delete this.transaction, this.storage.remove(this.storageKey) }, t }(), di = function(t) { return typeof t == "number" }, IR = ["iss", "aud", "exp", "nbf", "iat", "jti", "azp", "nonce", "auth_time", "at_hash", "c_hash", "acr", "amr", "sub_jwk", "cnf", "sip_from_tag", "sip_date", "sip_callid", "sip_cseq_num", "sip_via_branch", "orig", "dest", "mky", "events", "toe", "txn", "rph", "sid", "vot", "vtm"], PR = function(t) { if (!t.id_token) throw new Error("ID token is required but missing"); var e = function(c) { var u = c.split("."), a = No(u, 3), d = a[0], h = a[1], m = a[2]; if (u.length !== 3 || !d || !h || !m) throw new Error("ID token could not be decoded"); var g = JSON.parse(Np(h)), y = { __raw: c }, _ = {}; return Object.keys(g).forEach(function(A) { y[A] = g[A], IR.includes(A) || (_[A] = g[A]) }), { encoded: { header: d, payload: h, signature: m }, header: JSON.parse(Np(d)), claims: y, user: _ } }(t.id_token); if (!e.claims.iss) throw new Error("Issuer (iss) claim must be a string present in the ID token"); if (e.claims.iss !== t.iss) throw new Error('Issuer (iss) claim mismatch in the ID token; expected "'.concat(t.iss, '", found "').concat(e.claims.iss, '"')); if (!e.user.sub) throw new Error("Subject (sub) claim must be a string present in the ID token"); if (e.header.alg !== "RS256") throw new Error('Signature algorithm of "'.concat(e.header.alg, '" is not supported. Expected the ID token to be signed with "RS256".')); if (!e.claims.aud || typeof e.claims.aud != "string" && !Array.isArray(e.claims.aud)) throw new Error("Audience (aud) claim must be a string or array of strings present in the ID token"); if (Array.isArray(e.claims.aud)) { if (!e.claims.aud.includes(t.aud)) throw new Error('Audience (aud) claim mismatch in the ID token; expected "'.concat(t.aud, '" but was not one of "').concat(e.claims.aud.join(", "), '"')); if (e.claims.aud.length > 1) { if (!e.claims.azp) throw new Error("Authorized Party (azp) claim must be a string present in the ID token when Audience (aud) claim has multiple values"); if (e.claims.azp !== t.aud) throw new Error('Authorized Party (azp) claim mismatch in the ID token; expected "'.concat(t.aud, '", found "').concat(e.claims.azp, '"')) } } else if (e.claims.aud !== t.aud) throw new Error('Audience (aud) claim mismatch in the ID token; expected "'.concat(t.aud, '" but found "').concat(e.claims.aud, '"')); if (t.nonce) { if (!e.claims.nonce) throw new Error("Nonce (nonce) claim must be a string present in the ID token"); if (e.claims.nonce !== t.nonce) throw new Error('Nonce (nonce) claim mismatch in the ID token; expected "'.concat(t.nonce, '", found "').concat(e.claims.nonce, '"')) } if (t.max_age && !di(e.claims.auth_time)) throw new Error("Authentication Time (auth_time) claim must be a number present in the ID token when Max Age (max_age) is specified"); if (!di(e.claims.exp)) throw new Error("Expiration Time (exp) claim must be a number present in the ID token"); if (!di(e.claims.iat)) throw new Error("Issued At (iat) claim must be a number present in the ID token"); var n = t.leeway || 60, r = new Date(t.now || Date.now()), o = new Date(0), i = new Date(0), s = new Date(0); if (s.setUTCSeconds(parseInt(e.claims.auth_time) + t.max_age + n), o.setUTCSeconds(e.claims.exp + n), i.setUTCSeconds(e.claims.nbf - n), r > o) throw new Error("Expiration Time (exp) claim error in the ID token; current time (".concat(r, ") is after expiration time (").concat(o, ")")); if (di(e.claims.nbf) && r < i) throw new Error("Not Before time (nbf) claim in the ID token indicates that this token can't be used just yet. Currrent time (".concat(r, ") is before ").concat(i)); if (di(e.claims.auth_time) && r > s) throw new Error("Authentication Time (auth_time) claim in the ID token indicates that too much time has passed since the last end-user authentication. Currrent time (".concat(r, ") is after last auth at ").concat(s)); if (t.organizationId) { if (!e.claims.org_id) throw new Error("Organization ID (org_id) claim must be a string present in the ID token"); if (t.organizationId !== e.claims.org_id) throw new Error('Organization ID (org_id) claim mismatch in the ID token; expected "'.concat(t.organizationId, '", found "').concat(e.claims.org_id, '"')) } return e }, Cr = qo(function(t, e) { var n = an && an.__assign || function() { return n = Object.assign || function(u) { for (var a, d = 1, h = arguments.length; d < h; d++)for (var m in a = arguments[d]) Object.prototype.hasOwnProperty.call(a, m) && (u[m] = a[m]); return u }, n.apply(this, arguments) }; function r(u, a) { if (!a) return ""; var d = "; " + u; return a === !0 ? d : d + "=" + a } function o(u, a, d) { return encodeURIComponent(u).replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent).replace(/\(/g, "%28").replace(/\)/g, "%29") + "=" + encodeURIComponent(a).replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent) + function(h) { if (typeof h.expires == "number") { var m = new Date; m.setMilliseconds(m.getMilliseconds() + 864e5 * h.expires), h.expires = m } return r("Expires", h.expires ? h.expires.toUTCString() : "") + r("Domain", h.domain) + r("Path", h.path) + r("Secure", h.secure) + r("SameSite", h.sameSite) }(d) } function i(u) { for (var a = {}, d = u ? u.split("; ") : [], h = /(%[\dA-F]{2})+/gi, m = 0; m < d.length; m++) { var g = d[m].split("="), y = g.slice(1).join("="); y.charAt(0) === '"' && (y = y.slice(1, -1)); try { a[g[0].replace(h, decodeURIComponent)] = y.replace(h, decodeURIComponent) } catch { } } return a } function s() { return i(document.cookie) } function c(u, a, d) { document.cookie = o(u, a, n({ path: "/" }, d)) } e.__esModule = !0, e.encode = o, e.parse = i, e.getAll = s, e.get = function(u) { return s()[u] }, e.set = c, e.remove = function(u, a) { c(u, "", n(n({}, a), { expires: -1 })) } }); Xu(Cr), Cr.encode, Cr.parse, Cr.getAll; var NR = Cr.get, kw = Cr.set, LR = Cr.remove, ao = { get: function(t) { var e = NR(t); if (e !== void 0) return JSON.parse(e) }, save: function(t, e, n) { var r = {}; window.location.protocol === "https:" && (r = { secure: !0, sameSite: "none" }), n != null && n.daysUntilExpire && (r.expires = n.daysUntilExpire), n != null && n.cookieDomain && (r.domain = n.cookieDomain), kw(t, JSON.stringify(e), r) }, remove: function(t) { LR(t) } }, DR = { get: function(t) { var e = ao.get(t); return e || ao.get("".concat("_legacy_").concat(t)) }, save: function(t, e, n) { var r = {}; window.location.protocol === "https:" && (r = { secure: !0 }), n != null && n.daysUntilExpire && (r.expires = n.daysUntilExpire), kw("".concat("_legacy_").concat(t), JSON.stringify(e), r), ao.save(t, e, n) }, remove: function(t) { ao.remove(t), ao.remove("".concat("_legacy_").concat(t)) } }, BR = { get: function(t) { if (typeof sessionStorage < "u") { var e = sessionStorage.getItem(t); if (e !== void 0) return JSON.parse(e) } }, save: function(t, e) { sessionStorage.setItem(t, JSON.stringify(e)) }, remove: function(t) { sessionStorage.removeItem(t) } }; function $R(t, e, n) {
  var r = e === void 0 ? null : e, o = function(u, a) { var d = atob(u); if (a) { for (var h = new Uint8Array(d.length), m = 0, g = d.length; m < g; ++m)h[m] = d.charCodeAt(m); return String.fromCharCode.apply(null, new Uint16Array(h.buffer)) } return d }(t, n !== void 0 && n), i = o.indexOf(`
`, 10) + 1, s = o.substring(i) + (r ? "//# sourceMappingURL=" + r : ""), c = new Blob([s], { type: "application/javascript" }); return URL.createObjectURL(c)
} var Dp, Bp, $p, Xc, MR = (Dp = "Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwohZnVuY3Rpb24oKXsidXNlIHN0cmljdCI7Ci8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKgogICAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uCgogICAgUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55CiAgICBwdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuCgogICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEICJBUyBJUyIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEgKICAgIFJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWQogICAgQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULAogICAgSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NCiAgICBMT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUgogICAgT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUgogICAgUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS4KICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovdmFyIHQ9ZnVuY3Rpb24oZSxyKXtyZXR1cm4gdD1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fHtfX3Byb3RvX186W119aW5zdGFuY2VvZiBBcnJheSYmZnVuY3Rpb24odCxlKXt0Ll9fcHJvdG9fXz1lfXx8ZnVuY3Rpb24odCxlKXtmb3IodmFyIHIgaW4gZSlPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxyKSYmKHRbcl09ZVtyXSl9LHQoZSxyKX07ZnVuY3Rpb24gZShlLHIpe2lmKCJmdW5jdGlvbiIhPXR5cGVvZiByJiZudWxsIT09cil0aHJvdyBuZXcgVHlwZUVycm9yKCJDbGFzcyBleHRlbmRzIHZhbHVlICIrU3RyaW5nKHIpKyIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbCIpO2Z1bmN0aW9uIG4oKXt0aGlzLmNvbnN0cnVjdG9yPWV9dChlLHIpLGUucHJvdG90eXBlPW51bGw9PT1yP09iamVjdC5jcmVhdGUocik6KG4ucHJvdG90eXBlPXIucHJvdG90eXBlLG5ldyBuKX12YXIgcj1mdW5jdGlvbigpe3JldHVybiByPU9iamVjdC5hc3NpZ258fGZ1bmN0aW9uKHQpe2Zvcih2YXIgZSxyPTEsbj1hcmd1bWVudHMubGVuZ3RoO3I8bjtyKyspZm9yKHZhciBvIGluIGU9YXJndW1lbnRzW3JdKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLG8pJiYodFtvXT1lW29dKTtyZXR1cm4gdH0sci5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O2Z1bmN0aW9uIG4odCxlLHIsbil7cmV0dXJuIG5ldyhyfHwocj1Qcm9taXNlKSkoKGZ1bmN0aW9uKG8sYyl7ZnVuY3Rpb24gaSh0KXt0cnl7cyhuLm5leHQodCkpfWNhdGNoKHQpe2ModCl9fWZ1bmN0aW9uIGEodCl7dHJ5e3Mobi50aHJvdyh0KSl9Y2F0Y2godCl7Yyh0KX19ZnVuY3Rpb24gcyh0KXt2YXIgZTt0LmRvbmU/byh0LnZhbHVlKTooZT10LnZhbHVlLGUgaW5zdGFuY2VvZiByP2U6bmV3IHIoKGZ1bmN0aW9uKHQpe3QoZSl9KSkpLnRoZW4oaSxhKX1zKChuPW4uYXBwbHkodCxlfHxbXSkpLm5leHQoKSl9KSl9ZnVuY3Rpb24gbyh0LGUpe3ZhciByLG4sbyxjLGk9e2xhYmVsOjAsc2VudDpmdW5jdGlvbigpe2lmKDEmb1swXSl0aHJvdyBvWzFdO3JldHVybiBvWzFdfSx0cnlzOltdLG9wczpbXX07cmV0dXJuIGM9e25leHQ6YSgwKSx0aHJvdzphKDEpLHJldHVybjphKDIpfSwiZnVuY3Rpb24iPT10eXBlb2YgU3ltYm9sJiYoY1tTeW1ib2wuaXRlcmF0b3JdPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9KSxjO2Z1bmN0aW9uIGEoYyl7cmV0dXJuIGZ1bmN0aW9uKGEpe3JldHVybiBmdW5jdGlvbihjKXtpZihyKXRocm93IG5ldyBUeXBlRXJyb3IoIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy4iKTtmb3IoO2k7KXRyeXtpZihyPTEsbiYmKG89MiZjWzBdP24ucmV0dXJuOmNbMF0/bi50aHJvd3x8KChvPW4ucmV0dXJuKSYmby5jYWxsKG4pLDApOm4ubmV4dCkmJiEobz1vLmNhbGwobixjWzFdKSkuZG9uZSlyZXR1cm4gbztzd2l0Y2gobj0wLG8mJihjPVsyJmNbMF0sby52YWx1ZV0pLGNbMF0pe2Nhc2UgMDpjYXNlIDE6bz1jO2JyZWFrO2Nhc2UgNDpyZXR1cm4gaS5sYWJlbCsrLHt2YWx1ZTpjWzFdLGRvbmU6ITF9O2Nhc2UgNTppLmxhYmVsKyssbj1jWzFdLGM9WzBdO2NvbnRpbnVlO2Nhc2UgNzpjPWkub3BzLnBvcCgpLGkudHJ5cy5wb3AoKTtjb250aW51ZTtkZWZhdWx0OmlmKCEobz1pLnRyeXMsKG89by5sZW5ndGg+MCYmb1tvLmxlbmd0aC0xXSl8fDYhPT1jWzBdJiYyIT09Y1swXSkpe2k9MDtjb250aW51ZX1pZigzPT09Y1swXSYmKCFvfHxjWzFdPm9bMF0mJmNbMV08b1szXSkpe2kubGFiZWw9Y1sxXTticmVha31pZig2PT09Y1swXSYmaS5sYWJlbDxvWzFdKXtpLmxhYmVsPW9bMV0sbz1jO2JyZWFrfWlmKG8mJmkubGFiZWw8b1syXSl7aS5sYWJlbD1vWzJdLGkub3BzLnB1c2goYyk7YnJlYWt9b1syXSYmaS5vcHMucG9wKCksaS50cnlzLnBvcCgpO2NvbnRpbnVlfWM9ZS5jYWxsKHQsaSl9Y2F0Y2godCl7Yz1bNix0XSxuPTB9ZmluYWxseXtyPW89MH1pZig1JmNbMF0pdGhyb3cgY1sxXTtyZXR1cm57dmFsdWU6Y1swXT9jWzFdOnZvaWQgMCxkb25lOiEwfX0oW2MsYV0pfX19ZnVuY3Rpb24gYyh0LGUpe3JldHVybiB2b2lkIDA9PT1lJiYoZT1bXSksdCYmIWUuaW5jbHVkZXModCk/dDoiIn12YXIgaT1mdW5jdGlvbih0KXtmdW5jdGlvbiByKGUsbil7dmFyIG89dC5jYWxsKHRoaXMsbil8fHRoaXM7cmV0dXJuIG8uZXJyb3I9ZSxvLmVycm9yX2Rlc2NyaXB0aW9uPW4sT2JqZWN0LnNldFByb3RvdHlwZU9mKG8sci5wcm90b3R5cGUpLG99cmV0dXJuIGUocix0KSxyLmZyb21QYXlsb2FkPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgcih0LmVycm9yLHQuZXJyb3JfZGVzY3JpcHRpb24pfSxyfShFcnJvcik7IWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIHIoZSxuLG8sYyl7dm9pZCAwPT09YyYmKGM9bnVsbCk7dmFyIGk9dC5jYWxsKHRoaXMsZSxuKXx8dGhpcztyZXR1cm4gaS5zdGF0ZT1vLGkuYXBwU3RhdGU9YyxPYmplY3Quc2V0UHJvdG90eXBlT2YoaSxyLnByb3RvdHlwZSksaX1lKHIsdCl9KGkpLGZ1bmN0aW9uKHQpe2Z1bmN0aW9uIHIoZSl7dmFyIG49dC5jYWxsKHRoaXMpfHx0aGlzO3JldHVybiBuLnBvcHVwPWUsT2JqZWN0LnNldFByb3RvdHlwZU9mKG4sci5wcm90b3R5cGUpLG59ZShyLHQpfShmdW5jdGlvbih0KXtmdW5jdGlvbiByKCl7dmFyIGU9dC5jYWxsKHRoaXMsInRpbWVvdXQiLCJUaW1lb3V0Iil8fHRoaXM7cmV0dXJuIE9iamVjdC5zZXRQcm90b3R5cGVPZihlLHIucHJvdG90eXBlKSxlfXJldHVybiBlKHIsdCkscn0oaSkpLGZ1bmN0aW9uKHQpe2Z1bmN0aW9uIHIoZSl7dmFyIG49dC5jYWxsKHRoaXMsImNhbmNlbGxlZCIsIlBvcHVwIGNsb3NlZCIpfHx0aGlzO3JldHVybiBuLnBvcHVwPWUsT2JqZWN0LnNldFByb3RvdHlwZU9mKG4sci5wcm90b3R5cGUpLG59ZShyLHQpfShpKSxmdW5jdGlvbih0KXtmdW5jdGlvbiByKGUsbixvKXt2YXIgYz10LmNhbGwodGhpcyxlLG4pfHx0aGlzO3JldHVybiBjLm1mYV90b2tlbj1vLE9iamVjdC5zZXRQcm90b3R5cGVPZihjLHIucHJvdG90eXBlKSxjfWUocix0KX0oaSk7dmFyIGE9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gcihlLG4pe3ZhciBvPXQuY2FsbCh0aGlzLCJtaXNzaW5nX3JlZnJlc2hfdG9rZW4iLCJNaXNzaW5nIFJlZnJlc2ggVG9rZW4gKGF1ZGllbmNlOiAnIi5jb25jYXQoYyhlLFsiZGVmYXVsdCJdKSwiJywgc2NvcGU6ICciKS5jb25jYXQoYyhuKSwiJykiKSl8fHRoaXM7cmV0dXJuIG8uYXVkaWVuY2U9ZSxvLnNjb3BlPW4sT2JqZWN0LnNldFByb3RvdHlwZU9mKG8sci5wcm90b3R5cGUpLG99cmV0dXJuIGUocix0KSxyfShpKSxzPXt9LHU9ZnVuY3Rpb24odCxlKXtyZXR1cm4iIi5jb25jYXQodCwifCIpLmNvbmNhdChlKX07YWRkRXZlbnRMaXN0ZW5lcigibWVzc2FnZSIsKGZ1bmN0aW9uKHQpe3ZhciBlPXQuZGF0YSxjPWUudGltZW91dCxpPWUuYXV0aCxmPWUuZmV0Y2hVcmwsbD1lLmZldGNoT3B0aW9ucyxwPWUudXNlRm9ybURhdGEsaD1mdW5jdGlvbih0LGUpe3ZhciByPSJmdW5jdGlvbiI9PXR5cGVvZiBTeW1ib2wmJnRbU3ltYm9sLml0ZXJhdG9yXTtpZighcilyZXR1cm4gdDt2YXIgbixvLGM9ci5jYWxsKHQpLGk9W107dHJ5e2Zvcig7KHZvaWQgMD09PWV8fGUtLSA+MCkmJiEobj1jLm5leHQoKSkuZG9uZTspaS5wdXNoKG4udmFsdWUpfWNhdGNoKHQpe289e2Vycm9yOnR9fWZpbmFsbHl7dHJ5e24mJiFuLmRvbmUmJihyPWMucmV0dXJuKSYmci5jYWxsKGMpfWZpbmFsbHl7aWYobyl0aHJvdyBvLmVycm9yfX1yZXR1cm4gaX0odC5wb3J0cywxKVswXTtyZXR1cm4gbih2b2lkIDAsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24oKXt2YXIgdCxlLG4seSx2LGIsZCx3LE8sXztyZXR1cm4gbyh0aGlzLChmdW5jdGlvbihvKXtzd2l0Y2goby5sYWJlbCl7Y2FzZSAwOm49KGU9aXx8e30pLmF1ZGllbmNlLHk9ZS5zY29wZSxvLmxhYmVsPTE7Y2FzZSAxOmlmKG8udHJ5cy5wdXNoKFsxLDcsLDhdKSwhKHY9cD8obT1sLmJvZHksaz1uZXcgVVJMU2VhcmNoUGFyYW1zKG0pLFA9e30say5mb3JFYWNoKChmdW5jdGlvbih0LGUpe1BbZV09dH0pKSxQKTpKU09OLnBhcnNlKGwuYm9keSkpLnJlZnJlc2hfdG9rZW4mJiJyZWZyZXNoX3Rva2VuIj09PXYuZ3JhbnRfdHlwZSl7aWYoYj1mdW5jdGlvbih0LGUpe3JldHVybiBzW3UodCxlKV19KG4seSksIWIpdGhyb3cgbmV3IGEobix5KTtsLmJvZHk9cD9uZXcgVVJMU2VhcmNoUGFyYW1zKHIocih7fSx2KSx7cmVmcmVzaF90b2tlbjpifSkpLnRvU3RyaW5nKCk6SlNPTi5zdHJpbmdpZnkocihyKHt9LHYpLHtyZWZyZXNoX3Rva2VuOmJ9KSl9ZD12b2lkIDAsImZ1bmN0aW9uIj09dHlwZW9mIEFib3J0Q29udHJvbGxlciYmKGQ9bmV3IEFib3J0Q29udHJvbGxlcixsLnNpZ25hbD1kLnNpZ25hbCksdz12b2lkIDAsby5sYWJlbD0yO2Nhc2UgMjpyZXR1cm4gby50cnlzLnB1c2goWzIsNCwsNV0pLFs0LFByb21pc2UucmFjZShbKGc9YyxuZXcgUHJvbWlzZSgoZnVuY3Rpb24odCl7cmV0dXJuIHNldFRpbWVvdXQodCxnKX0pKSksZmV0Y2goZixyKHt9LGwpKV0pXTtjYXNlIDM6cmV0dXJuIHc9by5zZW50KCksWzMsNV07Y2FzZSA0OnJldHVybiBPPW8uc2VudCgpLGgucG9zdE1lc3NhZ2Uoe2Vycm9yOk8ubWVzc2FnZX0pLFsyXTtjYXNlIDU6cmV0dXJuIHc/WzQsdy5qc29uKCldOihkJiZkLmFib3J0KCksaC5wb3N0TWVzc2FnZSh7ZXJyb3I6IlRpbWVvdXQgd2hlbiBleGVjdXRpbmcgJ2ZldGNoJyJ9KSxbMl0pO2Nhc2UgNjpyZXR1cm4odD1vLnNlbnQoKSkucmVmcmVzaF90b2tlbj8oZnVuY3Rpb24odCxlLHIpe3NbdShlLHIpXT10fSh0LnJlZnJlc2hfdG9rZW4sbix5KSxkZWxldGUgdC5yZWZyZXNoX3Rva2VuKTpmdW5jdGlvbih0LGUpe2RlbGV0ZSBzW3UodCxlKV19KG4seSksaC5wb3N0TWVzc2FnZSh7b2s6dy5vayxqc29uOnR9KSxbMyw4XTtjYXNlIDc6cmV0dXJuIF89by5zZW50KCksaC5wb3N0TWVzc2FnZSh7b2s6ITEsanNvbjp7ZXJyb3JfZGVzY3JpcHRpb246Xy5tZXNzYWdlfX0pLFszLDhdO2Nhc2UgODpyZXR1cm5bMl19dmFyIGcsbSxrLFB9KSl9KSl9KSl9KCk7Cgo=", Bp = null, $p = !1, function(t) { return Xc = Xc || $R(Dp, Bp, $p), new Worker(Xc, t) }), Zc = {}, FR = function() { function t(e, n) { this.cache = e, this.clientId = n, this.manifestKey = this.createManifestKeyFrom(this.clientId) } return t.prototype.add = function(e) { var n; return _e(this, void 0, void 0, function() { var r, o; return Ee(this, function(i) { switch (i.label) { case 0: return o = Set.bind, [4, this.cache.get(this.manifestKey)]; case 1: return (r = new (o.apply(Set, [void 0, ((n = i.sent()) === null || n === void 0 ? void 0 : n.keys) || []]))).add(e), [4, this.cache.set(this.manifestKey, { keys: Rl([], No(r), !1) })]; case 2: return i.sent(), [2] } }) }) }, t.prototype.remove = function(e) { return _e(this, void 0, void 0, function() { var n, r; return Ee(this, function(o) { switch (o.label) { case 0: return [4, this.cache.get(this.manifestKey)]; case 1: return (n = o.sent()) ? ((r = new Set(n.keys)).delete(e), r.size > 0 ? [4, this.cache.set(this.manifestKey, { keys: Rl([], No(r), !1) })] : [3, 3]) : [3, 5]; case 2: case 4: return [2, o.sent()]; case 3: return [4, this.cache.remove(this.manifestKey)]; case 5: return [2] } }) }) }, t.prototype.get = function() { return this.cache.get(this.manifestKey) }, t.prototype.clear = function() { return this.cache.remove(this.manifestKey) }, t.prototype.createManifestKeyFrom = function(e) { return "".concat("@@auth0spajs@@", "::").concat(e) }, t }(), Mp = new dR, jR = { memory: function() { return new xR().enclosedCache }, localstorage: function() { return new OR } }, Fp = function(t) { return jR[t] }, HR = function() { return !/Trident.*rv:11\.0/.test(navigator.userAgent) }, UR = function() {
  function t(e) {
    var n, r, o, i; if (this.options = e, typeof window < "u" && function() {
      if (!yf()) throw new Error("For security reasons, `window.crypto` is required to run `auth0-spa-js`."); if (xw() === void 0) throw new Error(`
      auth0-spa-js must run on a secure origin. See https://github.com/auth0/auth0-spa-js/blob/master/FAQ.md#why-do-i-get-auth0-spa-js-must-run-on-a-secure-origin for more information.
    `)
    }(), e.cache && e.cacheLocation && console.warn("Both `cache` and `cacheLocation` options have been specified in the Auth0Client configuration; ignoring `cacheLocation` and using `cache`."), e.cache) o = e.cache; else { if (this.cacheLocation = e.cacheLocation || "memory", !Fp(this.cacheLocation)) throw new Error('Invalid cache location "'.concat(this.cacheLocation, '"')); o = Fp(this.cacheLocation)() } this.httpTimeoutMs = e.httpTimeoutInSeconds ? 1e3 * e.httpTimeoutInSeconds : 1e4, this.cookieStorage = e.legacySameSiteCookie === !1 ? ao : DR, this.orgHintCookieName = (i = this.options.client_id, "auth0.".concat(i, ".organization_hint")), this.isAuthenticatedCookieName = function(u) { return "auth0.".concat(u, ".is.authenticated") }(this.options.client_id), this.sessionCheckExpiryDays = e.sessionCheckExpiryDays || 1; var s, c = e.useCookiesForTransactions ? this.cookieStorage : BR; this.scope = this.options.scope, this.transactionManager = new RR(c, this.options.client_id), this.nowProvider = this.options.nowProvider || Ow, this.cacheManager = new kR(o, o.allKeys ? null : new FR(o, this.options.client_id), this.nowProvider), this.domainUrl = (s = this.options.domain, /^https?:\/\//.test(s) ? s : "https://".concat(s)), this.tokenIssuer = function(u, a) { return u ? u.startsWith("https://") ? u : "https://".concat(u, "/") : "".concat(a, "/") }(this.options.issuer, this.domainUrl), this.defaultScope = Kn("openid", ((r = (n = this.options) === null || n === void 0 ? void 0 : n.advancedOptions) === null || r === void 0 ? void 0 : r.defaultScope) !== void 0 ? this.options.advancedOptions.defaultScope : "openid profile email"), this.options.useRefreshTokens && (this.scope = Kn(this.scope, "offline_access")), typeof window < "u" && window.Worker && this.options.useRefreshTokens && this.cacheLocation === "memory" && HR() && (this.worker = new MR), this.customOptions = function(u) { return u.advancedOptions, u.audience, u.auth0Client, u.authorizeTimeoutInSeconds, u.cacheLocation, u.client_id, u.domain, u.issuer, u.leeway, u.max_age, u.redirect_uri, u.scope, u.useRefreshTokens, u.useCookiesForTransactions, u.useFormData, Et(u, ["advancedOptions", "audience", "auth0Client", "authorizeTimeoutInSeconds", "cacheLocation", "client_id", "domain", "issuer", "leeway", "max_age", "redirect_uri", "scope", "useRefreshTokens", "useCookiesForTransactions", "useFormData"]) }(e), this.useRefreshTokensFallback = this.options.useRefreshTokensFallback !== !1
  } return t.prototype._url = function(e) { var n = encodeURIComponent(btoa(JSON.stringify(this.options.auth0Client || Cw))); return "".concat(this.domainUrl).concat(e, "&auth0Client=").concat(n) }, t.prototype._getParams = function(e, n, r, o, i) { var s = this.options; s.useRefreshTokens, s.useCookiesForTransactions, s.useFormData, s.auth0Client, s.cacheLocation, s.advancedOptions, s.detailedResponse, s.nowProvider, s.authorizeTimeoutInSeconds, s.legacySameSiteCookie, s.sessionCheckExpiryDays, s.domain, s.leeway, s.httpTimeoutInSeconds; var c = Et(s, ["useRefreshTokens", "useCookiesForTransactions", "useFormData", "auth0Client", "cacheLocation", "advancedOptions", "detailedResponse", "nowProvider", "authorizeTimeoutInSeconds", "legacySameSiteCookie", "sessionCheckExpiryDays", "domain", "leeway", "httpTimeoutInSeconds"]); return le(le(le({}, c), e), { scope: Kn(this.defaultScope, this.scope, e.scope), response_type: "code", response_mode: "query", state: n, nonce: r, redirect_uri: i || this.options.redirect_uri, code_challenge: o, code_challenge_method: "S256" }) }, t.prototype._authorizeUrl = function(e) { return this._url("/authorize?".concat(Yl(e))) }, t.prototype._verifyIdToken = function(e, n, r) { return _e(this, void 0, void 0, function() { var o; return Ee(this, function(i) { switch (i.label) { case 0: return [4, this.nowProvider()]; case 1: return o = i.sent(), [2, PR({ iss: this.tokenIssuer, aud: this.options.client_id, id_token: e, nonce: n, organizationId: r, leeway: this.options.leeway, max_age: this._parseNumber(this.options.max_age), now: o })] } }) }) }, t.prototype._parseNumber = function(e) { return typeof e != "string" ? e : parseInt(e, 10) || void 0 }, t.prototype._processOrgIdHint = function(e) { e ? this.cookieStorage.save(this.orgHintCookieName, e, { daysUntilExpire: this.sessionCheckExpiryDays, cookieDomain: this.options.cookieDomain }) : this.cookieStorage.remove(this.orgHintCookieName) }, t.prototype.buildAuthorizeUrl = function(e) { return e === void 0 && (e = {}), _e(this, void 0, void 0, function() { var n, r, o, i, s, c, u, a, d, h, m, g; return Ee(this, function(y) { switch (y.label) { case 0: return n = e.redirect_uri, r = e.appState, o = Et(e, ["redirect_uri", "appState"]), i = to(wn()), s = to(wn()), c = wn(), [4, Gc(c)]; case 1: return u = y.sent(), a = Yc(u), d = e.fragment ? "#".concat(e.fragment) : "", h = this._getParams(o, i, s, a, n), m = this._authorizeUrl(h), g = e.organization || this.options.organization, this.transactionManager.create(le({ nonce: s, code_verifier: c, appState: r, scope: h.scope, audience: h.audience || "default", redirect_uri: h.redirect_uri, state: i }, g && { organizationId: g })), [2, m + d] } }) }) }, t.prototype.loginWithPopup = function(e, n) { return _e(this, void 0, void 0, function() { var r, o, i, s, c, u, a, d, h, m, g, y, _; return Ee(this, function(A) { switch (A.label) { case 0: if (e = e || {}, !(n = n || {}).popup && (n.popup = function(E) { var T = window.screenX + (window.innerWidth - 400) / 2, x = window.screenY + (window.innerHeight - 600) / 2; return window.open(E, "auth0:authorize:popup", "left=".concat(T, ",top=").concat(x, ",width=").concat(400, ",height=").concat(600, ",resizable,scrollbars=yes,status=1")) }(""), !n.popup)) throw new Error("Unable to open a popup for loginWithPopup - window.open returned `null`"); return r = Et(e, []), o = to(wn()), i = to(wn()), s = wn(), [4, Gc(s)]; case 1: return c = A.sent(), u = Yc(c), a = this._getParams(r, o, i, u, this.options.redirect_uri || window.location.origin), d = this._authorizeUrl(le(le({}, a), { response_mode: "web_message" })), n.popup.location.href = d, [4, vR(le(le({}, n), { timeoutInSeconds: n.timeoutInSeconds || this.options.authorizeTimeoutInSeconds || 60 }))]; case 2: if (h = A.sent(), o !== h.state) throw new Error("Invalid state"); return [4, Os({ audience: a.audience, scope: a.scope, baseUrl: this.domainUrl, client_id: this.options.client_id, code_verifier: s, code: h.code, grant_type: "authorization_code", redirect_uri: a.redirect_uri, auth0Client: this.options.auth0Client, useFormData: this.options.useFormData, timeout: this.httpTimeoutMs }, this.worker)]; case 3: return m = A.sent(), g = e.organization || this.options.organization, [4, this._verifyIdToken(m.id_token, i, g)]; case 4: return y = A.sent(), _ = le(le({}, m), { decodedToken: y, scope: a.scope, audience: a.audience || "default", client_id: this.options.client_id }), [4, this.cacheManager.set(_)]; case 5: return A.sent(), this.cookieStorage.save(this.isAuthenticatedCookieName, !0, { daysUntilExpire: this.sessionCheckExpiryDays, cookieDomain: this.options.cookieDomain }), this._processOrgIdHint(y.claims.org_id), [2] } }) }) }, t.prototype.getUser = function(e) { return e === void 0 && (e = {}), _e(this, void 0, void 0, function() { var n, r, o; return Ee(this, function(i) { switch (i.label) { case 0: return n = e.audience || this.options.audience || "default", r = Kn(this.defaultScope, this.scope, e.scope), [4, this.cacheManager.get(new vr({ client_id: this.options.client_id, audience: n, scope: r }))]; case 1: return [2, (o = i.sent()) && o.decodedToken && o.decodedToken.user] } }) }) }, t.prototype.getIdTokenClaims = function(e) { return e === void 0 && (e = {}), _e(this, void 0, void 0, function() { var n, r, o; return Ee(this, function(i) { switch (i.label) { case 0: return n = e.audience || this.options.audience || "default", r = Kn(this.defaultScope, this.scope, e.scope), [4, this.cacheManager.get(new vr({ client_id: this.options.client_id, audience: n, scope: r }))]; case 1: return [2, (o = i.sent()) && o.decodedToken && o.decodedToken.claims] } }) }) }, t.prototype.loginWithRedirect = function(e) { return e === void 0 && (e = {}), _e(this, void 0, void 0, function() { var n, r, o; return Ee(this, function(i) { switch (i.label) { case 0: return n = e.redirectMethod, r = Et(e, ["redirectMethod"]), [4, this.buildAuthorizeUrl(r)]; case 1: return o = i.sent(), window.location[n || "assign"](o), [2] } }) }) }, t.prototype.handleRedirectCallback = function(e) { return e === void 0 && (e = window.location.href), _e(this, void 0, void 0, function() { var n, r, o, i, s, c, u, a, d, h; return Ee(this, function(m) { switch (m.label) { case 0: if ((n = e.split("?").slice(1)).length === 0) throw new Error("There are no query params available for parsing."); if (r = function(g) { g.indexOf("#") > -1 && (g = g.substr(0, g.indexOf("#"))); var y = g.split("&"), _ = {}; return y.forEach(function(A) { var E = No(A.split("="), 2), T = E[0], x = E[1]; _[T] = decodeURIComponent(x) }), _.expires_in && (_.expires_in = parseInt(_.expires_in)), _ }(n.join("")), o = r.state, i = r.code, s = r.error, c = r.error_description, !(u = this.transactionManager.get())) throw new Error("Invalid state"); if (this.transactionManager.remove(), s) throw new mR(s, c, o, u.appState); if (!u.code_verifier || u.state && u.state !== o) throw new Error("Invalid state"); return a = { audience: u.audience, scope: u.scope, baseUrl: this.domainUrl, client_id: this.options.client_id, code_verifier: u.code_verifier, grant_type: "authorization_code", code: i, auth0Client: this.options.auth0Client, useFormData: this.options.useFormData, timeout: this.httpTimeoutMs }, u.redirect_uri !== void 0 && (a.redirect_uri = u.redirect_uri), [4, Os(a, this.worker)]; case 1: return d = m.sent(), [4, this._verifyIdToken(d.id_token, u.nonce, u.organizationId)]; case 2: return h = m.sent(), [4, this.cacheManager.set(le(le(le(le({}, d), { decodedToken: h, audience: u.audience, scope: u.scope }), d.scope ? { oauthTokenScope: d.scope } : null), { client_id: this.options.client_id }))]; case 3: return m.sent(), this.cookieStorage.save(this.isAuthenticatedCookieName, !0, { daysUntilExpire: this.sessionCheckExpiryDays, cookieDomain: this.options.cookieDomain }), this._processOrgIdHint(h.claims.org_id), [2, { appState: u.appState }] } }) }) }, t.prototype.checkSession = function(e) { return _e(this, void 0, void 0, function() { var n; return Ee(this, function(r) { switch (r.label) { case 0: if (!this.cookieStorage.get(this.isAuthenticatedCookieName)) { if (!this.cookieStorage.get("auth0.is.authenticated")) return [2]; this.cookieStorage.save(this.isAuthenticatedCookieName, !0, { daysUntilExpire: this.sessionCheckExpiryDays, cookieDomain: this.options.cookieDomain }), this.cookieStorage.remove("auth0.is.authenticated") } r.label = 1; case 1: return r.trys.push([1, 3, , 4]), [4, this.getTokenSilently(e)]; case 2: return r.sent(), [3, 4]; case 3: if (n = r.sent(), !pR.includes(n.error)) throw n; return [3, 4]; case 4: return [2] } }) }) }, t.prototype.getTokenSilently = function(e) { return e === void 0 && (e = {}), _e(this, void 0, void 0, function() { var n, r, o, i = this; return Ee(this, function(s) { return n = le(le({ audience: this.options.audience, ignoreCache: !1 }, e), { scope: Kn(this.defaultScope, this.scope, e.scope) }), r = n.ignoreCache, o = Et(n, ["ignoreCache"]), [2, (c = function() { return i._getTokenSilently(le({ ignoreCache: r }, o)) }, u = "".concat(this.options.client_id, "::").concat(o.audience, "::").concat(o.scope), a = Zc[u], a || (a = c().finally(function() { delete Zc[u], a = null }), Zc[u] = a), a)]; }) }) }, t.prototype._getTokenSilently = function(e) { return e === void 0 && (e = {}), _e(this, void 0, void 0, function() { var n, r, o, i, s, c, u, a, d; return Ee(this, function(h) { switch (h.label) { case 0: return n = e.ignoreCache, r = Et(e, ["ignoreCache"]), n ? [3, 2] : [4, this._getEntryFromCache({ scope: r.scope, audience: r.audience || "default", client_id: this.options.client_id, getDetailedEntry: e.detailedResponse })]; case 1: if (o = h.sent()) return [2, o]; h.label = 2; case 2: return [4, (m = function() { return Mp.acquireLock("auth0.lock.getTokenSilently", 5e3) }, g = 10, g === void 0 && (g = 3), _e(void 0, void 0, void 0, function() { var y; return Ee(this, function(_) { switch (_.label) { case 0: y = 0, _.label = 1; case 1: return y < g ? [4, m()] : [3, 4]; case 2: if (_.sent()) return [2, !0]; _.label = 3; case 3: return y++, [3, 1]; case 4: return [2, !1] } }) }))]; case 3: if (!h.sent()) return [3, 15]; h.label = 4; case 4: return h.trys.push([4, , 12, 14]), n ? [3, 6] : [4, this._getEntryFromCache({ scope: r.scope, audience: r.audience || "default", client_id: this.options.client_id, getDetailedEntry: e.detailedResponse })]; case 5: if (o = h.sent()) return [2, o]; h.label = 6; case 6: return this.options.useRefreshTokens ? [4, this._getTokenUsingRefreshToken(r)] : [3, 8]; case 7: return s = h.sent(), [3, 10]; case 8: return [4, this._getTokenFromIFrame(r)]; case 9: s = h.sent(), h.label = 10; case 10: return i = s, [4, this.cacheManager.set(le({ client_id: this.options.client_id }, i))]; case 11: return h.sent(), this.cookieStorage.save(this.isAuthenticatedCookieName, !0, { daysUntilExpire: this.sessionCheckExpiryDays, cookieDomain: this.options.cookieDomain }), e.detailedResponse ? (c = i.id_token, u = i.access_token, a = i.oauthTokenScope, d = i.expires_in, [2, le(le({ id_token: c, access_token: u }, a ? { scope: a } : null), { expires_in: d })]) : [2, i.access_token]; case 12: return [4, Mp.releaseLock("auth0.lock.getTokenSilently")]; case 13: return h.sent(), [7]; case 14: return [3, 16]; case 15: throw new Gl; case 16: return [2] }var m, g }) }) }, t.prototype.getTokenWithPopup = function(e, n) { return e === void 0 && (e = {}), n === void 0 && (n = {}), _e(this, void 0, void 0, function() { return Ee(this, function(r) { switch (r.label) { case 0: return e.audience = e.audience || this.options.audience, e.scope = Kn(this.defaultScope, this.scope, e.scope), n = le(le({}, hR), n), [4, this.loginWithPopup(e, n)]; case 1: return r.sent(), [4, this.cacheManager.get(new vr({ scope: e.scope, audience: e.audience || "default", client_id: this.options.client_id }))]; case 2: return [2, r.sent().access_token] } }) }) }, t.prototype.isAuthenticated = function() { return _e(this, void 0, void 0, function() { return Ee(this, function(e) { switch (e.label) { case 0: return [4, this.getUser()]; case 1: return [2, !!e.sent()] } }) }) }, t.prototype.buildLogoutUrl = function(e) { e === void 0 && (e = {}), e.client_id !== null ? e.client_id = e.client_id || this.options.client_id : delete e.client_id; var n = e.federated, r = Et(e, ["federated"]), o = n ? "&federated" : ""; return this._url("/v2/logout?".concat(Yl(r))) + o }, t.prototype.logout = function(e) { var n = this; e === void 0 && (e = {}); var r = e.localOnly, o = Et(e, ["localOnly"]); if (r && o.federated) throw new Error("It is invalid to set both the `federated` and `localOnly` options to `true`"); var i = function() { if (n.cookieStorage.remove(n.orgHintCookieName), n.cookieStorage.remove(n.isAuthenticatedCookieName), !r) { var s = n.buildLogoutUrl(o); window.location.assign(s) } }; if (this.options.cache) return this.cacheManager.clear().then(function() { return i() }); this.cacheManager.clearSync(), i() }, t.prototype._getTokenFromIFrame = function(e) { return _e(this, void 0, void 0, function() { var n, r, o, i, s, c, u, a, d, h, m, g, y, _, A, E, T; return Ee(this, function(x) { switch (x.label) { case 0: return n = to(wn()), r = to(wn()), o = wn(), [4, Gc(o)]; case 1: i = x.sent(), s = Yc(i), c = Et(e, ["detailedResponse"]), u = this._getParams(c, n, r, s, e.redirect_uri || this.options.redirect_uri || window.location.origin), (a = this.cookieStorage.get(this.orgHintCookieName)) && !u.organization && (u.organization = a), d = this._authorizeUrl(le(le({}, u), { prompt: "none", response_mode: "web_message" })), x.label = 2; case 2: if (x.trys.push([2, 6, , 7]), window.crossOriginIsolated) throw new Nn("login_required", "The application is running in a Cross-Origin Isolated context, silently retrieving a token without refresh token is not possible."); return h = e.timeoutInSeconds || this.options.authorizeTimeoutInSeconds, [4, (P = d, W = this.domainUrl, Y = h, Y === void 0 && (Y = 60), new Promise(function(Z, he) { var re = window.document.createElement("iframe"); re.setAttribute("width", "0"), re.setAttribute("height", "0"), re.style.display = "none"; var z, ye = function() { window.document.body.contains(re) && (window.document.body.removeChild(re), window.removeEventListener("message", z, !1)) }, De = setTimeout(function() { he(new Gl), ye() }, 1e3 * Y); z = function(fe) { if (fe.origin == W && fe.data && fe.data.type === "authorization_response") { var He = fe.source; He && He.close(), fe.data.response.error ? he(Nn.fromPayload(fe.data.response)) : Z(fe.data.response), clearTimeout(De), window.removeEventListener("message", z, !1), setTimeout(ye, 2e3) } }, window.addEventListener("message", z, !1), window.document.body.appendChild(re), re.setAttribute("src", P) }))]; case 3: if (m = x.sent(), n !== m.state) throw new Error("Invalid state"); return g = e.scope, y = e.audience, _ = Et(e, ["scope", "audience", "redirect_uri", "ignoreCache", "timeoutInSeconds", "detailedResponse"]), [4, Os(le(le(le({}, this.customOptions), _), { scope: g, audience: y, baseUrl: this.domainUrl, client_id: this.options.client_id, code_verifier: o, code: m.code, grant_type: "authorization_code", redirect_uri: u.redirect_uri, auth0Client: this.options.auth0Client, useFormData: this.options.useFormData, timeout: _.timeout || this.httpTimeoutMs }), this.worker)]; case 4: return A = x.sent(), [4, this._verifyIdToken(A.id_token, r)]; case 5: return E = x.sent(), this._processOrgIdHint(E.claims.org_id), [2, le(le({}, A), { decodedToken: E, scope: u.scope, oauthTokenScope: A.scope, audience: u.audience || "default" })]; case 6: throw (T = x.sent()).error === "login_required" && this.logout({ localOnly: !0 }), T; case 7: return [2] }var P, W, Y }) }) }, t.prototype._getTokenUsingRefreshToken = function(e) { return _e(this, void 0, void 0, function() { var n, r, o, i, s, c, u, a, d; return Ee(this, function(h) { switch (h.label) { case 0: return e.scope = Kn(this.defaultScope, this.options.scope, e.scope), [4, this.cacheManager.get(new vr({ scope: e.scope, audience: e.audience || "default", client_id: this.options.client_id }))]; case 1: return (n = h.sent()) && n.refresh_token || this.worker ? [3, 4] : this.useRefreshTokensFallback ? [4, this._getTokenFromIFrame(e)] : [3, 3]; case 2: return [2, h.sent()]; case 3: throw new bR(e.audience || "default", e.scope); case 4: r = e.redirect_uri || this.options.redirect_uri || window.location.origin, i = e.scope, s = e.audience, c = Et(e, ["scope", "audience", "ignoreCache", "timeoutInSeconds", "detailedResponse"]), u = typeof e.timeoutInSeconds == "number" ? 1e3 * e.timeoutInSeconds : null, h.label = 5; case 5: return h.trys.push([5, 7, , 10]), [4, Os(le(le(le(le(le({}, this.customOptions), c), { audience: s, scope: i, baseUrl: this.domainUrl, client_id: this.options.client_id, grant_type: "refresh_token", refresh_token: n && n.refresh_token, redirect_uri: r }), u && { timeout: u }), { auth0Client: this.options.auth0Client, useFormData: this.options.useFormData, timeout: this.httpTimeoutMs }), this.worker)]; case 6: return o = h.sent(), [3, 10]; case 7: return ((a = h.sent()).message.indexOf("Missing Refresh Token") > -1 || a.message && a.message.indexOf("invalid refresh token") > -1) && this.useRefreshTokensFallback ? [4, this._getTokenFromIFrame(e)] : [3, 9]; case 8: return [2, h.sent()]; case 9: throw a; case 10: return [4, this._verifyIdToken(o.id_token)]; case 11: return d = h.sent(), [2, le(le({}, o), { decodedToken: d, scope: e.scope, oauthTokenScope: o.scope, audience: e.audience || "default" })] } }) }) }, t.prototype._getEntryFromCache = function(e) { var n = e.scope, r = e.audience, o = e.client_id, i = e.getDetailedEntry, s = i !== void 0 && i; return _e(this, void 0, void 0, function() { var c, u, a, d, h; return Ee(this, function(m) { switch (m.label) { case 0: return [4, this.cacheManager.get(new vr({ scope: n, audience: r, client_id: o }), 60)]; case 1: return (c = m.sent()) && c.access_token ? s ? (u = c.id_token, a = c.access_token, d = c.oauthTokenScope, h = c.expires_in, [2, le(le({ id_token: u, access_token: a }, d ? { scope: d } : null), { expires_in: h })]) : [2, c.access_token] : [2] } }) }) }, t
}(); function VR(t) { return _e(this, void 0, void 0, function() { var e; return Ee(this, function(n) { switch (n.label) { case 0: return [4, (e = new UR(t)).checkSession()]; case 1: return n.sent(), [2, e] } }) }) } class KR { constructor() { this._listeners = {} } on(e, n, r = null) { typeof n == "function" && (this._listeners[e] = this._listeners[e] || [], n.ctx = r, this._listeners[e].push(n)) } off(e, n) { this._listeners[e] = this._listeners[e] || []; const r = this._listeners[e].indexOf(n); r !== -1 && this._listeners[e].splice(r, 1) } emit(e, n) { this._listeners[e] = this._listeners[e] || []; let r = this._listeners[e].length; for (let o = 0; o < r; o++) { let i = this._listeners[e][o]; i.ctx ? i.call(i.ctx, n) : i(n) } } } const WR = () => window.history.replaceState({}, document.title, window.location.pathname); let F = {}; class zR extends KR { constructor(e = {}) { super(), F = this, F.loading = !0, F.AUTH_EVENTS = { LOADING: "LOADING", LOADED: "LOADED", AUTHENTICATED: "AUTHENTICATED", TOKEN_CHANGE: "TOKEN_CHANGE" }, F.user = {}, F.userInfo = {}, F.identity = {}, F.isAuthenticated = !1, F.bearer = "", F.options = e, F.popupOpen = !1, F.auth0Client = null, F.error = null, F.options.onRedirectCallback = F.options.onRedirectCallback || WR, F.created(e), F.created = !0 } async loginWithPopup(e = { returnTo: window.location.origin }) { F.popupOpen = !0; try { await F.auth0Client.loginWithPopup(e), F.user = await F.auth0Client.getUser(), F.user = F.user || {}, await F.getUserData(), F.isAuthenticated = !0 } catch { F.loginWithRedirect() } finally { F.popupOpen = !1 } } async handleRedirectCallback() { F.loading = !0; try { await F.auth0Client.handleRedirectCallback(), F.user = await F.auth0Client.getUser(), await F.getUserData(), F.isAuthenticated = !0 } catch (e) { F.error = e } finally { F.loading = !1 } } loginWithRedirect(e = {}) { return e.appState || (e.redirectUri = e.redirectUri || window.location.href), F.auth0Client.loginWithRedirect(e) } getIdTokenClaims(e) { return F.auth0Client.getIdTokenClaims(e) } async getTokenSilently(e) { const n = await F.auth0Client.getTokenSilently(e); return F.getIdentityClaims(n), F.emit(F.AUTH_EVENTS.TOKEN_CHANGE, this), n } hasPermissions(e) { if (Array.isArray(e) || (e = [e]), !F.identity.permissions) return !1; for (; e.length;) { const n = e.pop(); if (!F.identity.permissions.find(o => o === n)) return !1 } return !0 } hasRoles(e) { if (Array.isArray(e) || (e = [e]), !F.userInfo.roles) return !1; for (; e.length;) { const n = e.pop(); if (!F.userInfo.roles.find(o => o === n)) return !1 } return !0 } async getIdentityClaims(e) { return F.identity = JSON.parse(GR(e)), F.identity } async getTokenWithPopup(e) { const n = await F.auth0Client.getTokenWithPopup(e); return F.getIdentityClaims(n), F.emit(F.AUTH_EVENTS.TOKEN_CHANGE, this), n } async getUserData() { try { const e = await F.getTokenSilently(); await F.getIdentityClaims(e), F.bearer = "Bearer " + e; const r = await (await fetch(`https://${F.options.domain}/userinfo`, { headers: { authorization: F.bearer } })).json(); for (const o in r) { let i = o; o.includes("https") && (i = i.slice(i.lastIndexOf("/") + 1)), F.userInfo[i] = r[o] } F.user = F.user || {}, F.user.isAuthenticated = !0, F.emit(F.AUTH_EVENTS.AUTHENTICATED, this) } catch (e) { console.error(e) } } logout(e = { returnTo: window.location.origin }) { const n = F.auth0Client.logout(e); return F.bearer = "", F.user = {}, F.userInfo = {}, F.identity = {}, F.isAuthenticated = !1, n } async created(e) { F.emit(F.AUTH_EVENTS.LOADING), F.auth0Client = await VR({ domain: e.domain, client_id: e.clientId, audience: e.audience, redirect_uri: e.redirectUri || window.location.origin, useRefreshTokens: e.useRefreshTokens || !1 }); try { if (window.location.search.includes("code=") && window.location.search.includes("state=")) { const { appState: n } = await F.auth0Client.handleRedirectCallback(); e.onRedirectCallback(n) } } catch (n) { F.error = n } finally { if (F.isAuthenticated = await F.auth0Client.isAuthenticated(), !F.isAuthenticated) { F.loading = !1, F.emit(F.AUTH_EVENTS.LOADED); return } F.user = await F.auth0Client.getUser(), await F.getUserData(), F.loading = !1, F.emit(F.AUTH_EVENTS.LOADED) } } } function qR(t = ".") { try { return decodeURIComponent(atob(t).replace(/(.)/g, function(e, n) { let r = n.charCodeAt(0).toString(16).toUpperCase(); return r.length < 2 && (r = "0" + r), "%" + r })) } catch (e) { console.error("[AUTH0-PROVIDER-ERROR] unable to decode token", e) } } function GR(t = ".") { try { t = t.split(".")[1]; let e = t.replace(/-/g, "+").replace(/_/g, "/"); switch (e.length % 4) { case 0: break; case 2: e += "=="; break; case 3: e += "="; break; default: throw new Error("Illegal base64url string!") }return qR(e) } catch (e) { console.error("[AUTH0-PROVIDER-ERROR] unable to decode token", e) } } function YR(t) { return F && F.created ? F : new zR(t) } const XR = "modulepreload", ZR = function(t) { return "/" + t }, jp = {}, Jc = function(e, n, r) { if (!n || n.length === 0) return e(); const o = document.getElementsByTagName("link"); return Promise.all(n.map(i => { if (i = ZR(i), i in jp) return; jp[i] = !0; const s = i.endsWith(".css"), c = s ? '[rel="stylesheet"]' : ""; if (!!r) for (let d = o.length - 1; d >= 0; d--) { const h = o[d]; if (h.href === i && (!s || h.rel === "stylesheet")) return } else if (document.querySelector(`link[href="${i}"]${c}`)) return; const a = document.createElement("link"); if (a.rel = s ? "stylesheet" : XR, s || (a.as = "script", a.crossOrigin = ""), a.href = i, document.head.appendChild(a), s) return new Promise((d, h) => { a.addEventListener("load", d), a.addEventListener("error", () => h(new Error(`Unable to preload CSS for ${i}`))) }) })).then(() => e()) }, JR = (t, e) => { const n = t[e]; return n ? typeof n == "function" ? n() : Promise.resolve(n) : new Promise((r, o) => { (typeof queueMicrotask == "function" ? queueMicrotask : setTimeout)(o.bind(null, new Error("Unknown variable dynamic import: " + e))) }) };/*!
  * vue-router v4.2.2
  * (c) 2023 Eduardo San Martin Morote
  * @license MIT
  */const co = typeof window < "u"; function QR(t) { return t.__esModule || t[Symbol.toStringTag] === "Module" } const Se = Object.assign; function Qc(t, e) { const n = {}; for (const r in e) { const o = e[r]; n[r] = Xt(o) ? o.map(t) : t(o) } return n } const Si = () => { }, Xt = Array.isArray, eI = /\/$/, tI = t => t.replace(eI, ""); function el(t, e, n = "/") { let r, o = {}, i = "", s = ""; const c = e.indexOf("#"); let u = e.indexOf("?"); return c < u && c >= 0 && (u = -1), u > -1 && (r = e.slice(0, u), i = e.slice(u + 1, c > -1 ? c : e.length), o = t(i)), c > -1 && (r = r || e.slice(0, c), s = e.slice(c, e.length)), r = iI(r ?? e, n), { fullPath: r + (i && "?") + i + s, path: r, query: o, hash: s } } function nI(t, e) { const n = e.query ? t(e.query) : ""; return e.path + (n && "?") + n + (e.hash || "") } function Hp(t, e) { return !e || !t.toLowerCase().startsWith(e.toLowerCase()) ? t : t.slice(e.length) || "/" } function rI(t, e, n) { const r = e.matched.length - 1, o = n.matched.length - 1; return r > -1 && r === o && Bo(e.matched[r], n.matched[o]) && Rw(e.params, n.params) && t(e.query) === t(n.query) && e.hash === n.hash } function Bo(t, e) { return (t.aliasOf || t) === (e.aliasOf || e) } function Rw(t, e) { if (Object.keys(t).length !== Object.keys(e).length) return !1; for (const n in t) if (!oI(t[n], e[n])) return !1; return !0 } function oI(t, e) { return Xt(t) ? Up(t, e) : Xt(e) ? Up(e, t) : t === e } function Up(t, e) { return Xt(e) ? t.length === e.length && t.every((n, r) => n === e[r]) : t.length === 1 && t[0] === e } function iI(t, e) { if (t.startsWith("/")) return t; if (!t) return e; const n = e.split("/"), r = t.split("/"), o = r[r.length - 1]; (o === ".." || o === ".") && r.push(""); let i = n.length - 1, s, c; for (s = 0; s < r.length; s++)if (c = r[s], c !== ".") if (c === "..") i > 1 && i--; else break; return n.slice(0, i).join("/") + "/" + r.slice(s - (s === r.length ? 1 : 0)).join("/") } var ji; (function(t) { t.pop = "pop", t.push = "push" })(ji || (ji = {})); var Ci; (function(t) { t.back = "back", t.forward = "forward", t.unknown = "" })(Ci || (Ci = {})); function sI(t) { if (!t) if (co) { const e = document.querySelector("base"); t = e && e.getAttribute("href") || "/", t = t.replace(/^\w+:\/\/[^\/]+/, "") } else t = "/"; return t[0] !== "/" && t[0] !== "#" && (t = "/" + t), tI(t) } const aI = /^[^#]+#/; function cI(t, e) { return t.replace(aI, "#") + e } function lI(t, e) { const n = document.documentElement.getBoundingClientRect(), r = t.getBoundingClientRect(); return { behavior: e.behavior, left: r.left - n.left - (e.left || 0), top: r.top - n.top - (e.top || 0) } } const ec = () => ({ left: window.pageXOffset, top: window.pageYOffset }); function uI(t) { let e; if ("el" in t) { const n = t.el, r = typeof n == "string" && n.startsWith("#"), o = typeof n == "string" ? r ? document.getElementById(n.slice(1)) : document.querySelector(n) : n; if (!o) return; e = lI(o, t) } else e = t; "scrollBehavior" in document.documentElement.style ? window.scrollTo(e) : window.scrollTo(e.left != null ? e.left : window.pageXOffset, e.top != null ? e.top : window.pageYOffset) } function Vp(t, e) { return (history.state ? history.state.position - e : -1) + t } const Xl = new Map; function fI(t, e) { Xl.set(t, e) } function dI(t) { const e = Xl.get(t); return Xl.delete(t), e } let hI = () => location.protocol + "//" + location.host; function Iw(t, e) { const { pathname: n, search: r, hash: o } = e, i = t.indexOf("#"); if (i > -1) { let c = o.includes(t.slice(i)) ? t.slice(i).length : 1, u = o.slice(c); return u[0] !== "/" && (u = "/" + u), Hp(u, "") } return Hp(n, t) + r + o } function pI(t, e, n, r) { let o = [], i = [], s = null; const c = ({ state: m }) => { const g = Iw(t, location), y = n.value, _ = e.value; let A = 0; if (m) { if (n.value = g, e.value = m, s && s === y) { s = null; return } A = _ ? m.position - _.position : 0 } else r(g); o.forEach(E => { E(n.value, y, { delta: A, type: ji.pop, direction: A ? A > 0 ? Ci.forward : Ci.back : Ci.unknown }) }) }; function u() { s = n.value } function a(m) { o.push(m); const g = () => { const y = o.indexOf(m); y > -1 && o.splice(y, 1) }; return i.push(g), g } function d() { const { history: m } = window; m.state && m.replaceState(Se({}, m.state, { scroll: ec() }), "") } function h() { for (const m of i) m(); i = [], window.removeEventListener("popstate", c), window.removeEventListener("beforeunload", d) } return window.addEventListener("popstate", c), window.addEventListener("beforeunload", d, { passive: !0 }), { pauseListeners: u, listen: a, destroy: h } } function Kp(t, e, n, r = !1, o = !1) { return { back: t, current: e, forward: n, replaced: r, position: window.history.length, scroll: o ? ec() : null } } function mI(t) { const { history: e, location: n } = window, r = { value: Iw(t, n) }, o = { value: e.state }; o.value || i(r.value, { back: null, current: r.value, forward: null, position: e.length - 1, replaced: !0, scroll: null }, !0); function i(u, a, d) { const h = t.indexOf("#"), m = h > -1 ? (n.host && document.querySelector("base") ? t : t.slice(h)) + u : hI() + t + u; try { e[d ? "replaceState" : "pushState"](a, "", m), o.value = a } catch (g) { console.error(g), n[d ? "replace" : "assign"](m) } } function s(u, a) { const d = Se({}, e.state, Kp(o.value.back, u, o.value.forward, !0), a, { position: o.value.position }); i(u, d, !0), r.value = u } function c(u, a) { const d = Se({}, o.value, e.state, { forward: u, scroll: ec() }); i(d.current, d, !0); const h = Se({}, Kp(r.value, u, null), { position: d.position + 1 }, a); i(u, h, !1), r.value = u } return { location: r, state: o, push: c, replace: s } } function gI(t) { t = sI(t); const e = mI(t), n = pI(t, e.state, e.location, e.replace); function r(i, s = !0) { s || n.pauseListeners(), history.go(i) } const o = Se({ location: "", base: t, go: r, createHref: cI.bind(null, t) }, e, n); return Object.defineProperty(o, "location", { enumerable: !0, get: () => e.location.value }), Object.defineProperty(o, "state", { enumerable: !0, get: () => e.state.value }), o } function yI(t) { return t = location.host ? t || location.pathname + location.search : "", t.includes("#") || (t += "#"), gI(t) } function wI(t) { return typeof t == "string" || t && typeof t == "object" } function Pw(t) { return typeof t == "string" || typeof t == "symbol" } const Wn = { path: "/", name: void 0, params: {}, query: {}, hash: "", fullPath: "/", matched: [], meta: {}, redirectedFrom: void 0 }, Nw = Symbol(""); var Wp; (function(t) { t[t.aborted = 4] = "aborted", t[t.cancelled = 8] = "cancelled", t[t.duplicated = 16] = "duplicated" })(Wp || (Wp = {})); function $o(t, e) { return Se(new Error, { type: t, [Nw]: !0 }, e) } function bn(t, e) { return t instanceof Error && Nw in t && (e == null || !!(t.type & e)) } const zp = "[^/]+?", bI = { sensitive: !1, strict: !1, start: !0, end: !0 }, vI = /[.+*?^${}()[\]/\\]/g; function _I(t, e) { const n = Se({}, bI, e), r = []; let o = n.start ? "^" : ""; const i = []; for (const a of t) { const d = a.length ? [] : [90]; n.strict && !a.length && (o += "/"); for (let h = 0; h < a.length; h++) { const m = a[h]; let g = 40 + (n.sensitive ? .25 : 0); if (m.type === 0) h || (o += "/"), o += m.value.replace(vI, "\\$&"), g += 40; else if (m.type === 1) { const { value: y, repeatable: _, optional: A, regexp: E } = m; i.push({ name: y, repeatable: _, optional: A }); const T = E || zp; if (T !== zp) { g += 10; try { new RegExp(`(${T})`) } catch (P) { throw new Error(`Invalid custom RegExp for param "${y}" (${T}): ` + P.message) } } let x = _ ? `((?:${T})(?:/(?:${T}))*)` : `(${T})`; h || (x = A && a.length < 2 ? `(?:/${x})` : "/" + x), A && (x += "?"), o += x, g += 20, A && (g += -8), _ && (g += -20), T === ".*" && (g += -50) } d.push(g) } r.push(d) } if (n.strict && n.end) { const a = r.length - 1; r[a][r[a].length - 1] += .7000000000000001 } n.strict || (o += "/?"), n.end ? o += "$" : n.strict && (o += "(?:/|$)"); const s = new RegExp(o, n.sensitive ? "" : "i"); function c(a) { const d = a.match(s), h = {}; if (!d) return null; for (let m = 1; m < d.length; m++) { const g = d[m] || "", y = i[m - 1]; h[y.name] = g && y.repeatable ? g.split("/") : g } return h } function u(a) { let d = "", h = !1; for (const m of t) { (!h || !d.endsWith("/")) && (d += "/"), h = !1; for (const g of m) if (g.type === 0) d += g.value; else if (g.type === 1) { const { value: y, repeatable: _, optional: A } = g, E = y in a ? a[y] : ""; if (Xt(E) && !_) throw new Error(`Provided param "${y}" is an array but it is not repeatable (* or + modifiers)`); const T = Xt(E) ? E.join("/") : E; if (!T) if (A) m.length < 2 && (d.endsWith("/") ? d = d.slice(0, -1) : h = !0); else throw new Error(`Missing required param "${y}"`); d += T } } return d || "/" } return { re: s, score: r, keys: i, parse: c, stringify: u } } function EI(t, e) { let n = 0; for (; n < t.length && n < e.length;) { const r = e[n] - t[n]; if (r) return r; n++ } return t.length < e.length ? t.length === 1 && t[0] === 40 + 40 ? -1 : 1 : t.length > e.length ? e.length === 1 && e[0] === 40 + 40 ? 1 : -1 : 0 } function AI(t, e) { let n = 0; const r = t.score, o = e.score; for (; n < r.length && n < o.length;) { const i = EI(r[n], o[n]); if (i) return i; n++ } if (Math.abs(o.length - r.length) === 1) { if (qp(r)) return 1; if (qp(o)) return -1 } return o.length - r.length } function qp(t) { const e = t[t.length - 1]; return t.length > 0 && e[e.length - 1] < 0 } const TI = { type: 0, value: "" }, SI = /[a-zA-Z0-9_]/; function CI(t) { if (!t) return [[]]; if (t === "/") return [[TI]]; if (!t.startsWith("/")) throw new Error(`Invalid path "${t}"`); function e(g) { throw new Error(`ERR (${n})/"${a}": ${g}`) } let n = 0, r = n; const o = []; let i; function s() { i && o.push(i), i = [] } let c = 0, u, a = "", d = ""; function h() { a && (n === 0 ? i.push({ type: 0, value: a }) : n === 1 || n === 2 || n === 3 ? (i.length > 1 && (u === "*" || u === "+") && e(`A repeatable param (${a}) must be alone in its segment. eg: '/:ids+.`), i.push({ type: 1, value: a, regexp: d, repeatable: u === "*" || u === "+", optional: u === "*" || u === "?" })) : e("Invalid state to consume buffer"), a = "") } function m() { a += u } for (; c < t.length;) { if (u = t[c++], u === "\\" && n !== 2) { r = n, n = 4; continue } switch (n) { case 0: u === "/" ? (a && h(), s()) : u === ":" ? (h(), n = 1) : m(); break; case 4: m(), n = r; break; case 1: u === "(" ? n = 2 : SI.test(u) ? m() : (h(), n = 0, u !== "*" && u !== "?" && u !== "+" && c--); break; case 2: u === ")" ? d[d.length - 1] == "\\" ? d = d.slice(0, -1) + u : n = 3 : d += u; break; case 3: h(), n = 0, u !== "*" && u !== "?" && u !== "+" && c--, d = ""; break; default: e("Unknown state"); break } } return n === 2 && e(`Unfinished custom RegExp for param "${a}"`), h(), s(), o } function OI(t, e, n) { const r = _I(CI(t.path), n), o = Se(r, { record: t, parent: e, children: [], alias: [] }); return e && !o.record.aliasOf == !e.record.aliasOf && e.children.push(o), o } function xI(t, e) { const n = [], r = new Map; e = Xp({ strict: !1, end: !0, sensitive: !1 }, e); function o(d) { return r.get(d) } function i(d, h, m) { const g = !m, y = kI(d); y.aliasOf = m && m.record; const _ = Xp(e, d), A = [y]; if ("alias" in d) { const x = typeof d.alias == "string" ? [d.alias] : d.alias; for (const P of x) A.push(Se({}, y, { components: m ? m.record.components : y.components, path: P, aliasOf: m ? m.record : y })) } let E, T; for (const x of A) { const { path: P } = x; if (h && P[0] !== "/") { const W = h.record.path, Y = W[W.length - 1] === "/" ? "" : "/"; x.path = h.record.path + (P && Y + P) } if (E = OI(x, h, _), m ? m.alias.push(E) : (T = T || E, T !== E && T.alias.push(E), g && d.name && !Yp(E) && s(d.name)), y.children) { const W = y.children; for (let Y = 0; Y < W.length; Y++)i(W[Y], E, m && m.children[Y]) } m = m || E, (E.record.components && Object.keys(E.record.components).length || E.record.name || E.record.redirect) && u(E) } return T ? () => { s(T) } : Si } function s(d) { if (Pw(d)) { const h = r.get(d); h && (r.delete(d), n.splice(n.indexOf(h), 1), h.children.forEach(s), h.alias.forEach(s)) } else { const h = n.indexOf(d); h > -1 && (n.splice(h, 1), d.record.name && r.delete(d.record.name), d.children.forEach(s), d.alias.forEach(s)) } } function c() { return n } function u(d) { let h = 0; for (; h < n.length && AI(d, n[h]) >= 0 && (d.record.path !== n[h].record.path || !Lw(d, n[h]));)h++; n.splice(h, 0, d), d.record.name && !Yp(d) && r.set(d.record.name, d) } function a(d, h) { let m, g = {}, y, _; if ("name" in d && d.name) { if (m = r.get(d.name), !m) throw $o(1, { location: d }); _ = m.record.name, g = Se(Gp(h.params, m.keys.filter(T => !T.optional).map(T => T.name)), d.params && Gp(d.params, m.keys.map(T => T.name))), y = m.stringify(g) } else if ("path" in d) y = d.path, m = n.find(T => T.re.test(y)), m && (g = m.parse(y), _ = m.record.name); else { if (m = h.name ? r.get(h.name) : n.find(T => T.re.test(h.path)), !m) throw $o(1, { location: d, currentLocation: h }); _ = m.record.name, g = Se({}, h.params, d.params), y = m.stringify(g) } const A = []; let E = m; for (; E;)A.unshift(E.record), E = E.parent; return { name: _, path: y, params: g, matched: A, meta: II(A) } } return t.forEach(d => i(d)), { addRoute: i, resolve: a, removeRoute: s, getRoutes: c, getRecordMatcher: o } } function Gp(t, e) { const n = {}; for (const r of e) r in t && (n[r] = t[r]); return n } function kI(t) { return { path: t.path, redirect: t.redirect, name: t.name, meta: t.meta || {}, aliasOf: void 0, beforeEnter: t.beforeEnter, props: RI(t), children: t.children || [], instances: {}, leaveGuards: new Set, updateGuards: new Set, enterCallbacks: {}, components: "components" in t ? t.components || null : t.component && { default: t.component } } } function RI(t) { const e = {}, n = t.props || !1; if ("component" in t) e.default = n; else for (const r in t.components) e[r] = typeof n == "boolean" ? n : n[r]; return e } function Yp(t) { for (; t;) { if (t.record.aliasOf) return !0; t = t.parent } return !1 } function II(t) { return t.reduce((e, n) => Se(e, n.meta), {}) } function Xp(t, e) { const n = {}; for (const r in t) n[r] = r in e ? e[r] : t[r]; return n } function Lw(t, e) { return e.children.some(n => n === t || Lw(t, n)) } const Dw = /#/g, PI = /&/g, NI = /\//g, LI = /=/g, DI = /\?/g, Bw = /\+/g, BI = /%5B/g, $I = /%5D/g, $w = /%5E/g, MI = /%60/g, Mw = /%7B/g, FI = /%7C/g, Fw = /%7D/g, jI = /%20/g; function wf(t) { return encodeURI("" + t).replace(FI, "|").replace(BI, "[").replace($I, "]") } function HI(t) { return wf(t).replace(Mw, "{").replace(Fw, "}").replace($w, "^") } function Zl(t) { return wf(t).replace(Bw, "%2B").replace(jI, "+").replace(Dw, "%23").replace(PI, "%26").replace(MI, "`").replace(Mw, "{").replace(Fw, "}").replace($w, "^") } function UI(t) { return Zl(t).replace(LI, "%3D") } function VI(t) { return wf(t).replace(Dw, "%23").replace(DI, "%3F") } function KI(t) { return t == null ? "" : VI(t).replace(NI, "%2F") } function ba(t) { try { return decodeURIComponent("" + t) } catch { } return "" + t } function WI(t) { const e = {}; if (t === "" || t === "?") return e; const r = (t[0] === "?" ? t.slice(1) : t).split("&"); for (let o = 0; o < r.length; ++o) { const i = r[o].replace(Bw, " "), s = i.indexOf("="), c = ba(s < 0 ? i : i.slice(0, s)), u = s < 0 ? null : ba(i.slice(s + 1)); if (c in e) { let a = e[c]; Xt(a) || (a = e[c] = [a]), a.push(u) } else e[c] = u } return e } function Zp(t) { let e = ""; for (let n in t) { const r = t[n]; if (n = UI(n), r == null) { r !== void 0 && (e += (e.length ? "&" : "") + n); continue } (Xt(r) ? r.map(i => i && Zl(i)) : [r && Zl(r)]).forEach(i => { i !== void 0 && (e += (e.length ? "&" : "") + n, i != null && (e += "=" + i)) }) } return e } function zI(t) { const e = {}; for (const n in t) { const r = t[n]; r !== void 0 && (e[n] = Xt(r) ? r.map(o => o == null ? null : "" + o) : r == null ? r : "" + r) } return e } const qI = Symbol(""), Jp = Symbol(""), bf = Symbol(""), jw = Symbol(""), Jl = Symbol(""); function hi() { let t = []; function e(r) { return t.push(r), () => { const o = t.indexOf(r); o > -1 && t.splice(o, 1) } } function n() { t = [] } return { add: e, list: () => t, reset: n } } function qn(t, e, n, r, o) { const i = r && (r.enterCallbacks[o] = r.enterCallbacks[o] || []); return () => new Promise((s, c) => { const u = h => { h === !1 ? c($o(4, { from: n, to: e })) : h instanceof Error ? c(h) : wI(h) ? c($o(2, { from: e, to: h })) : (i && r.enterCallbacks[o] === i && typeof h == "function" && i.push(h), s()) }, a = t.call(r && r.instances[o], e, n, u); let d = Promise.resolve(a); t.length < 3 && (d = d.then(u)), d.catch(h => c(h)) }) } function tl(t, e, n, r) { const o = []; for (const i of t) for (const s in i.components) { let c = i.components[s]; if (!(e !== "beforeRouteEnter" && !i.instances[s])) if (GI(c)) { const a = (c.__vccOpts || c)[e]; a && o.push(qn(a, n, r, i, s)) } else { let u = c(); o.push(() => u.then(a => { if (!a) return Promise.reject(new Error(`Couldn't resolve component "${s}" at "${i.path}"`)); const d = QR(a) ? a.default : a; i.components[s] = d; const m = (d.__vccOpts || d)[e]; return m && qn(m, n, r, i, s)() })) } } return o } function GI(t) { return typeof t == "object" || "displayName" in t || "props" in t || "__vccOpts" in t } function Qp(t) { const e = Sn(bf), n = Sn(jw), r = Ke(() => e.resolve(yo(t.to))), o = Ke(() => { const { matched: u } = r.value, { length: a } = u, d = u[a - 1], h = n.matched; if (!d || !h.length) return -1; const m = h.findIndex(Bo.bind(null, d)); if (m > -1) return m; const g = em(u[a - 2]); return a > 1 && em(d) === g && h[h.length - 1].path !== g ? h.findIndex(Bo.bind(null, u[a - 2])) : m }), i = Ke(() => o.value > -1 && JI(n.params, r.value.params)), s = Ke(() => o.value > -1 && o.value === n.matched.length - 1 && Rw(n.params, r.value.params)); function c(u = {}) { return ZI(u) ? e[yo(t.replace) ? "replace" : "push"](yo(t.to)).catch(Si) : Promise.resolve() } return { route: r, href: Ke(() => r.value.href), isActive: i, isExactActive: s, navigate: c } } const YI = Wg({ name: "RouterLink", compatConfig: { MODE: 3 }, props: { to: { type: [String, Object], required: !0 }, replace: Boolean, activeClass: String, exactActiveClass: String, custom: Boolean, ariaCurrentValue: { type: String, default: "page" } }, useLink: Qp, setup(t, { slots: e }) { const n = Wo(Qp(t)), { options: r } = Sn(bf), o = Ke(() => ({ [tm(t.activeClass, r.linkActiveClass, "router-link-active")]: n.isActive, [tm(t.exactActiveClass, r.linkExactActiveClass, "router-link-exact-active")]: n.isExactActive })); return () => { const i = e.default && e.default(n); return t.custom ? i : uy("a", { "aria-current": n.isExactActive ? t.ariaCurrentValue : null, href: n.href, onClick: n.navigate, class: o.value }, i) } } }), XI = YI; function ZI(t) { if (!(t.metaKey || t.altKey || t.ctrlKey || t.shiftKey) && !t.defaultPrevented && !(t.button !== void 0 && t.button !== 0)) { if (t.currentTarget && t.currentTarget.getAttribute) { const e = t.currentTarget.getAttribute("target"); if (/\b_blank\b/i.test(e)) return } return t.preventDefault && t.preventDefault(), !0 } } function JI(t, e) { for (const n in e) { const r = e[n], o = t[n]; if (typeof r == "string") { if (r !== o) return !1 } else if (!Xt(o) || o.length !== r.length || r.some((i, s) => i !== o[s])) return !1 } return !0 } function em(t) { return t ? t.aliasOf ? t.aliasOf.path : t.path : "" } const tm = (t, e, n) => t ?? e ?? n, QI = Wg({ name: "RouterView", inheritAttrs: !1, props: { name: { type: String, default: "default" }, route: Object }, compatConfig: { MODE: 3 }, setup(t, { attrs: e, slots: n }) { const r = Sn(Jl), o = Ke(() => t.route || r.value), i = Sn(Jp, 0), s = Ke(() => { let a = yo(i); const { matched: d } = o.value; let h; for (; (h = d[a]) && !h.components;)a++; return a }), c = Ke(() => o.value.matched[s.value]); Bs(Jp, Ke(() => s.value + 1)), Bs(qI, c), Bs(Jl, o); const u = La(); return Ds(() => [u.value, c.value, t.name], ([a, d, h], [m, g, y]) => { d && (d.instances[h] = a, g && g !== d && a && a === m && (d.leaveGuards.size || (d.leaveGuards = g.leaveGuards), d.updateGuards.size || (d.updateGuards = g.updateGuards))), a && d && (!g || !Bo(d, g) || !m) && (d.enterCallbacks[h] || []).forEach(_ => _(a)) }, { flush: "post" }), () => { const a = o.value, d = t.name, h = c.value, m = h && h.components[d]; if (!m) return nm(n.default, { Component: m, route: a }); const g = h.props[d], y = g ? g === !0 ? a.params : typeof g == "function" ? g(a) : g : null, A = uy(m, Se({}, y, e, { onVnodeUnmounted: E => { E.component.isUnmounted && (h.instances[d] = null) }, ref: u })); return nm(n.default, { Component: A, route: a }) || A } } }); function nm(t, e) { if (!t) return null; const n = t(e); return n.length === 1 ? n[0] : n } const eP = QI; function tP(t) { const e = xI(t.routes, t), n = t.parseQuery || WI, r = t.stringifyQuery || Zp, o = t.history, i = hi(), s = hi(), c = hi(), u = _C(Wn); let a = Wn; co && t.scrollBehavior && "scrollRestoration" in history && (history.scrollRestoration = "manual"); const d = Qc.bind(null, R => "" + R), h = Qc.bind(null, KI), m = Qc.bind(null, ba); function g(R, U) { let j, X; return Pw(R) ? (j = e.getRecordMatcher(R), X = U) : X = R, e.addRoute(X, j) } function y(R) { const U = e.getRecordMatcher(R); U && e.removeRoute(U) } function _() { return e.getRoutes().map(R => R.record) } function A(R) { return !!e.getRecordMatcher(R) } function E(R, U) { if (U = Se({}, U || u.value), typeof R == "string") { const S = el(n, R, U.path), C = e.resolve({ path: S.path }, U), N = o.createHref(S.fullPath); return Se(S, C, { params: m(C.params), hash: ba(S.hash), redirectedFrom: void 0, href: N }) } let j; if ("path" in R) j = Se({}, R, { path: el(n, R.path, U.path).path }); else { const S = Se({}, R.params); for (const C in S) S[C] == null && delete S[C]; j = Se({}, R, { params: h(S) }), U.params = h(U.params) } const X = e.resolve(j, U), me = R.hash || ""; X.params = d(m(X.params)); const w = nI(r, Se({}, R, { hash: HI(me), path: X.path })), v = o.createHref(w); return Se({ fullPath: w, hash: me, query: r === Zp ? zI(R.query) : R.query || {} }, X, { redirectedFrom: void 0, href: v }) } function T(R) { return typeof R == "string" ? el(n, R, u.value.path) : Se({}, R) } function x(R, U) { if (a !== R) return $o(8, { from: U, to: R }) } function P(R) { return Z(R) } function W(R) { return P(Se(T(R), { replace: !0 })) } function Y(R) { const U = R.matched[R.matched.length - 1]; if (U && U.redirect) { const { redirect: j } = U; let X = typeof j == "function" ? j(R) : j; return typeof X == "string" && (X = X.includes("?") || X.includes("#") ? X = T(X) : { path: X }, X.params = {}), Se({ query: R.query, hash: R.hash, params: "path" in X ? {} : R.params }, X) } } function Z(R, U) { const j = a = E(R), X = u.value, me = R.state, w = R.force, v = R.replace === !0, S = Y(j); if (S) return Z(Se(T(S), { state: typeof S == "object" ? Se({}, me, S.state) : me, force: w, replace: v }), U || j); const C = j; C.redirectedFrom = U; let N; return !w && rI(r, X, j) && (N = $o(16, { to: C, from: X }), at(X, X, !0, !1)), (N ? Promise.resolve(N) : z(C, X)).catch(D => bn(D) ? bn(D, 2) ? D : $e(D) : oe(D, C, X)).then(D => { if (D) { if (bn(D, 2)) return Z(Se({ replace: v }, T(D.to), { state: typeof D.to == "object" ? Se({}, me, D.to.state) : me, force: w }), U || C) } else D = De(C, X, !0, v, me); return ye(C, X, D), D }) } function he(R, U) { const j = x(R, U); return j ? Promise.reject(j) : Promise.resolve() } function re(R) { const U = ct.values().next().value; return U && typeof U.runWithContext == "function" ? U.runWithContext(R) : R() } function z(R, U) { let j; const [X, me, w] = nP(R, U); j = tl(X.reverse(), "beforeRouteLeave", R, U); for (const S of X) S.leaveGuards.forEach(C => { j.push(qn(C, R, U)) }); const v = he.bind(null, R, U); return j.push(v), Oe(j).then(() => { j = []; for (const S of i.list()) j.push(qn(S, R, U)); return j.push(v), Oe(j) }).then(() => { j = tl(me, "beforeRouteUpdate", R, U); for (const S of me) S.updateGuards.forEach(C => { j.push(qn(C, R, U)) }); return j.push(v), Oe(j) }).then(() => { j = []; for (const S of R.matched) if (S.beforeEnter && !U.matched.includes(S)) if (Xt(S.beforeEnter)) for (const C of S.beforeEnter) j.push(qn(C, R, U)); else j.push(qn(S.beforeEnter, R, U)); return j.push(v), Oe(j) }).then(() => (R.matched.forEach(S => S.enterCallbacks = {}), j = tl(w, "beforeRouteEnter", R, U), j.push(v), Oe(j))).then(() => { j = []; for (const S of s.list()) j.push(qn(S, R, U)); return j.push(v), Oe(j) }).catch(S => bn(S, 8) ? S : Promise.reject(S)) } function ye(R, U, j) { for (const X of c.list()) re(() => X(R, U, j)) } function De(R, U, j, X, me) { const w = x(R, U); if (w) return w; const v = U === Wn, S = co ? history.state : {}; j && (X || v ? o.replace(R.fullPath, Se({ scroll: v && S && S.scroll }, me)) : o.push(R.fullPath, me)), u.value = R, at(R, U, j, v), $e() } let fe; function He() { fe || (fe = o.listen((R, U, j) => { if (!Xe.listening) return; const X = E(R), me = Y(X); if (me) { Z(Se(me, { replace: !0 }), X).catch(Si); return } a = X; const w = u.value; co && fI(Vp(w.fullPath, j.delta), ec()), z(X, w).catch(v => bn(v, 12) ? v : bn(v, 2) ? (Z(v.to, X).then(S => { bn(S, 20) && !j.delta && j.type === ji.pop && o.go(-1, !1) }).catch(Si), Promise.reject()) : (j.delta && o.go(-j.delta, !1), oe(v, X, w))).then(v => { v = v || De(X, w, !1), v && (j.delta && !bn(v, 8) ? o.go(-j.delta, !1) : j.type === ji.pop && bn(v, 20) && o.go(-1, !1)), ye(X, w, v) }).catch(Si) })) } let nt = hi(), pe = hi(), ie; function oe(R, U, j) { $e(R); const X = pe.list(); return X.length ? X.forEach(me => me(R, U, j)) : console.error(R), Promise.reject(R) } function Re() { return ie && u.value !== Wn ? Promise.resolve() : new Promise((R, U) => { nt.add([R, U]) }) } function $e(R) { return ie || (ie = !R, He(), nt.list().forEach(([U, j]) => R ? j(R) : U()), nt.reset()), R } function at(R, U, j, X) { const { scrollBehavior: me } = t; if (!co || !me) return Promise.resolve(); const w = !j && dI(Vp(R.fullPath, 0)) || (X || !j) && history.state && history.state.scroll || null; return $g().then(() => me(R, U, w)).then(v => v && uI(v)).catch(v => oe(v, R, U)) } const Ce = R => o.go(R); let rt; const ct = new Set, Xe = { currentRoute: u, listening: !0, addRoute: g, removeRoute: y, hasRoute: A, getRoutes: _, resolve: E, options: t, push: P, replace: W, go: Ce, back: () => Ce(-1), forward: () => Ce(1), beforeEach: i.add, beforeResolve: s.add, afterEach: c.add, onError: pe.add, isReady: Re, install(R) { const U = this; R.component("RouterLink", XI), R.component("RouterView", eP), R.config.globalProperties.$router = U, Object.defineProperty(R.config.globalProperties, "$route", { enumerable: !0, get: () => yo(u) }), co && !rt && u.value === Wn && (rt = !0, P(o.location).catch(me => { })); const j = {}; for (const me in Wn) j[me] = Ke(() => u.value[me]); R.provide(bf, U), R.provide(jw, Wo(j)), R.provide(Jl, u); const X = R.unmount; ct.add(R), R.unmount = function() { ct.delete(R), ct.size < 1 && (a = Wn, fe && fe(), fe = null, u.value = Wn, rt = !1, ie = !1), X() } } }; function Oe(R) { return R.reduce((U, j) => U.then(() => re(j)), Promise.resolve()) } return Xe } function nP(t, e) { const n = [], r = [], o = [], i = Math.max(e.matched.length, t.matched.length); for (let s = 0; s < i; s++) { const c = e.matched[s]; c && (t.matched.find(a => Bo(a, c)) ? r.push(c) : n.push(c)); const u = t.matched[s]; u && (e.matched.find(a => Bo(a, u)) || o.push(u)) } return [n, r, o] } function rP(t) { return () => JR(Object.assign({ "./pages/AboutPage.vue": () => Jc(() => import("./AboutPage-ddb8e2e7.js"), []), "./pages/AccountPage.vue": () => Jc(() => import("./AccountPage-6746d859.js"), ["assets/AccountPage-6746d859.js", "assets/AccountPage-79c9a418.css"]), "./pages/HomePage.vue": () => Jc(() => import("./HomePage-3621277b.js"), []) }), `./pages/${t}.vue`) } const oP = [{ path: "/", name: "Home", component: rP("HomePage") }], Hw = tP({ linkActiveClass: "router-link-active", linkExactActiveClass: "router-link-exact-active", history: yI(), routes: oP }); class iP extends fy { constructor(e) { super(e), this.email = e.email } } class sP { async getAccount() { try { const e = await it.get("/account"); ue.account = new iP(e.data) } catch (e) { Nt.error("HAVE YOU STARTED YOUR SERVER YET???", e) } } } const aP = new sP, mn = Object.create(null); mn.open = "0"; mn.close = "1"; mn.ping = "2"; mn.pong = "3"; mn.message = "4"; mn.upgrade = "5"; mn.noop = "6"; const qs = Object.create(null); Object.keys(mn).forEach(t => { qs[mn[t]] = t }); const cP = { type: "error", data: "parser error" }, lP = typeof Blob == "function" || typeof Blob < "u" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]", uP = typeof ArrayBuffer == "function", fP = t => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(t) : t && t.buffer instanceof ArrayBuffer, Uw = ({ type: t, data: e }, n, r) => lP && e instanceof Blob ? n ? r(e) : rm(e, r) : uP && (e instanceof ArrayBuffer || fP(e)) ? n ? r(e) : rm(new Blob([e]), r) : r(mn[t] + (e || "")), rm = (t, e) => { const n = new FileReader; return n.onload = function() { const r = n.result.split(",")[1]; e("b" + (r || "")) }, n.readAsDataURL(t) }, om = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", wi = typeof Uint8Array > "u" ? [] : new Uint8Array(256); for (let t = 0; t < om.length; t++)wi[om.charCodeAt(t)] = t; const dP = t => { let e = t.length * .75, n = t.length, r, o = 0, i, s, c, u; t[t.length - 1] === "=" && (e--, t[t.length - 2] === "=" && e--); const a = new ArrayBuffer(e), d = new Uint8Array(a); for (r = 0; r < n; r += 4)i = wi[t.charCodeAt(r)], s = wi[t.charCodeAt(r + 1)], c = wi[t.charCodeAt(r + 2)], u = wi[t.charCodeAt(r + 3)], d[o++] = i << 2 | s >> 4, d[o++] = (s & 15) << 4 | c >> 2, d[o++] = (c & 3) << 6 | u & 63; return a }, hP = typeof ArrayBuffer == "function", Vw = (t, e) => { if (typeof t != "string") return { type: "message", data: Kw(t, e) }; const n = t.charAt(0); return n === "b" ? { type: "message", data: pP(t.substring(1), e) } : qs[n] ? t.length > 1 ? { type: qs[n], data: t.substring(1) } : { type: qs[n] } : cP }, pP = (t, e) => { if (hP) { const n = dP(t); return Kw(n, e) } else return { base64: !0, data: t } }, Kw = (t, e) => { switch (e) { case "blob": return t instanceof ArrayBuffer ? new Blob([t]) : t; case "arraybuffer": default: return t } }, Ww = String.fromCharCode(30), mP = (t, e) => { const n = t.length, r = new Array(n); let o = 0; t.forEach((i, s) => { Uw(i, !1, c => { r[s] = c, ++o === n && e(r.join(Ww)) }) }) }, gP = (t, e) => { const n = t.split(Ww), r = []; for (let o = 0; o < n.length; o++) { const i = Vw(n[o], e); if (r.push(i), i.type === "error") break } return r }, zw = 4; function ze(t) { if (t) return yP(t) } function yP(t) { for (var e in ze.prototype) t[e] = ze.prototype[e]; return t } ze.prototype.on = ze.prototype.addEventListener = function(t, e) { return this._callbacks = this._callbacks || {}, (this._callbacks["$" + t] = this._callbacks["$" + t] || []).push(e), this }; ze.prototype.once = function(t, e) { function n() { this.off(t, n), e.apply(this, arguments) } return n.fn = e, this.on(t, n), this }; ze.prototype.off = ze.prototype.removeListener = ze.prototype.removeAllListeners = ze.prototype.removeEventListener = function(t, e) { if (this._callbacks = this._callbacks || {}, arguments.length == 0) return this._callbacks = {}, this; var n = this._callbacks["$" + t]; if (!n) return this; if (arguments.length == 1) return delete this._callbacks["$" + t], this; for (var r, o = 0; o < n.length; o++)if (r = n[o], r === e || r.fn === e) { n.splice(o, 1); break } return n.length === 0 && delete this._callbacks["$" + t], this }; ze.prototype.emit = function(t) { this._callbacks = this._callbacks || {}; for (var e = new Array(arguments.length - 1), n = this._callbacks["$" + t], r = 1; r < arguments.length; r++)e[r - 1] = arguments[r]; if (n) { n = n.slice(0); for (var r = 0, o = n.length; r < o; ++r)n[r].apply(this, e) } return this }; ze.prototype.emitReserved = ze.prototype.emit; ze.prototype.listeners = function(t) { return this._callbacks = this._callbacks || {}, this._callbacks["$" + t] || [] }; ze.prototype.hasListeners = function(t) { return !!this.listeners(t).length }; const Dt = (() => typeof self < "u" ? self : typeof window < "u" ? window : Function("return this")())(); function qw(t, ...e) { return e.reduce((n, r) => (t.hasOwnProperty(r) && (n[r] = t[r]), n), {}) } const wP = Dt.setTimeout, bP = Dt.clearTimeout; function tc(t, e) { e.useNativeTimers ? (t.setTimeoutFn = wP.bind(Dt), t.clearTimeoutFn = bP.bind(Dt)) : (t.setTimeoutFn = Dt.setTimeout.bind(Dt), t.clearTimeoutFn = Dt.clearTimeout.bind(Dt)) } const vP = 1.33; function _P(t) { return typeof t == "string" ? EP(t) : Math.ceil((t.byteLength || t.size) * vP) } function EP(t) { let e = 0, n = 0; for (let r = 0, o = t.length; r < o; r++)e = t.charCodeAt(r), e < 128 ? n += 1 : e < 2048 ? n += 2 : e < 55296 || e >= 57344 ? n += 3 : (r++, n += 4); return n } class AP extends Error { constructor(e, n, r) { super(e), this.description = n, this.context = r, this.type = "TransportError" } } class Gw extends ze { constructor(e) { super(), this.writable = !1, tc(this, e), this.opts = e, this.query = e.query, this.socket = e.socket } onError(e, n, r) { return super.emitReserved("error", new AP(e, n, r)), this } open() { return this.readyState = "opening", this.doOpen(), this } close() { return (this.readyState === "opening" || this.readyState === "open") && (this.doClose(), this.onClose()), this } send(e) { this.readyState === "open" && this.write(e) } onOpen() { this.readyState = "open", this.writable = !0, super.emitReserved("open") } onData(e) { const n = Vw(e, this.socket.binaryType); this.onPacket(n) } onPacket(e) { super.emitReserved("packet", e) } onClose(e) { this.readyState = "closed", super.emitReserved("close", e) } pause(e) { } } const Yw = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""), Ql = 64, TP = {}; let im = 0, xs = 0, sm; function am(t) { let e = ""; do e = Yw[t % Ql] + e, t = Math.floor(t / Ql); while (t > 0); return e } function Xw() { const t = am(+new Date); return t !== sm ? (im = 0, sm = t) : t + "." + am(im++) } for (; xs < Ql; xs++)TP[Yw[xs]] = xs; function Zw(t) { let e = ""; for (let n in t) t.hasOwnProperty(n) && (e.length && (e += "&"), e += encodeURIComponent(n) + "=" + encodeURIComponent(t[n])); return e } function SP(t) { let e = {}, n = t.split("&"); for (let r = 0, o = n.length; r < o; r++) { let i = n[r].split("="); e[decodeURIComponent(i[0])] = decodeURIComponent(i[1]) } return e } let Jw = !1; try { Jw = typeof XMLHttpRequest < "u" && "withCredentials" in new XMLHttpRequest } catch { } const CP = Jw; function Qw(t) { const e = t.xdomain; try { if (typeof XMLHttpRequest < "u" && (!e || CP)) return new XMLHttpRequest } catch { } if (!e) try { return new Dt[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP") } catch { } } function OP() { } const xP = function() { return new Qw({ xdomain: !1 }).responseType != null }(); class kP extends Gw { constructor(e) { if (super(e), this.polling = !1, typeof location < "u") { const r = location.protocol === "https:"; let o = location.port; o || (o = r ? "443" : "80"), this.xd = typeof location < "u" && e.hostname !== location.hostname || o !== e.port, this.xs = e.secure !== r } const n = e && e.forceBase64; this.supportsBinary = xP && !n } get name() { return "polling" } doOpen() { this.poll() } pause(e) { this.readyState = "pausing"; const n = () => { this.readyState = "paused", e() }; if (this.polling || !this.writable) { let r = 0; this.polling && (r++, this.once("pollComplete", function() { --r || n() })), this.writable || (r++, this.once("drain", function() { --r || n() })) } else n() } poll() { this.polling = !0, this.doPoll(), this.emitReserved("poll") } onData(e) { const n = r => { if (this.readyState === "opening" && r.type === "open" && this.onOpen(), r.type === "close") return this.onClose({ description: "transport closed by the server" }), !1; this.onPacket(r) }; gP(e, this.socket.binaryType).forEach(n), this.readyState !== "closed" && (this.polling = !1, this.emitReserved("pollComplete"), this.readyState === "open" && this.poll()) } doClose() { const e = () => { this.write([{ type: "close" }]) }; this.readyState === "open" ? e() : this.once("open", e) } write(e) { this.writable = !1, mP(e, n => { this.doWrite(n, () => { this.writable = !0, this.emitReserved("drain") }) }) } uri() { let e = this.query || {}; const n = this.opts.secure ? "https" : "http"; let r = ""; this.opts.timestampRequests !== !1 && (e[this.opts.timestampParam] = Xw()), !this.supportsBinary && !e.sid && (e.b64 = 1), this.opts.port && (n === "https" && Number(this.opts.port) !== 443 || n === "http" && Number(this.opts.port) !== 80) && (r = ":" + this.opts.port); const o = Zw(e), i = this.opts.hostname.indexOf(":") !== -1; return n + "://" + (i ? "[" + this.opts.hostname + "]" : this.opts.hostname) + r + this.opts.path + (o.length ? "?" + o : "") } request(e = {}) { return Object.assign(e, { xd: this.xd, xs: this.xs }, this.opts), new un(this.uri(), e) } doWrite(e, n) { const r = this.request({ method: "POST", data: e }); r.on("success", n), r.on("error", (o, i) => { this.onError("xhr post error", o, i) }) } doPoll() { const e = this.request(); e.on("data", this.onData.bind(this)), e.on("error", (n, r) => { this.onError("xhr poll error", n, r) }), this.pollXhr = e } } class un extends ze { constructor(e, n) { super(), tc(this, n), this.opts = n, this.method = n.method || "GET", this.uri = e, this.async = n.async !== !1, this.data = n.data !== void 0 ? n.data : null, this.create() } create() { const e = qw(this.opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref"); e.xdomain = !!this.opts.xd, e.xscheme = !!this.opts.xs; const n = this.xhr = new Qw(e); try { n.open(this.method, this.uri, this.async); try { if (this.opts.extraHeaders) { n.setDisableHeaderCheck && n.setDisableHeaderCheck(!0); for (let r in this.opts.extraHeaders) this.opts.extraHeaders.hasOwnProperty(r) && n.setRequestHeader(r, this.opts.extraHeaders[r]) } } catch { } if (this.method === "POST") try { n.setRequestHeader("Content-type", "text/plain;charset=UTF-8") } catch { } try { n.setRequestHeader("Accept", "*/*") } catch { } "withCredentials" in n && (n.withCredentials = this.opts.withCredentials), this.opts.requestTimeout && (n.timeout = this.opts.requestTimeout), n.onreadystatechange = () => { n.readyState === 4 && (n.status === 200 || n.status === 1223 ? this.onLoad() : this.setTimeoutFn(() => { this.onError(typeof n.status == "number" ? n.status : 0) }, 0)) }, n.send(this.data) } catch (r) { this.setTimeoutFn(() => { this.onError(r) }, 0); return } typeof document < "u" && (this.index = un.requestsCount++, un.requests[this.index] = this) } onError(e) { this.emitReserved("error", e, this.xhr), this.cleanup(!0) } cleanup(e) { if (!(typeof this.xhr > "u" || this.xhr === null)) { if (this.xhr.onreadystatechange = OP, e) try { this.xhr.abort() } catch { } typeof document < "u" && delete un.requests[this.index], this.xhr = null } } onLoad() { const e = this.xhr.responseText; e !== null && (this.emitReserved("data", e), this.emitReserved("success"), this.cleanup()) } abort() { this.cleanup() } } un.requestsCount = 0; un.requests = {}; if (typeof document < "u") { if (typeof attachEvent == "function") attachEvent("onunload", cm); else if (typeof addEventListener == "function") { const t = "onpagehide" in Dt ? "pagehide" : "unload"; addEventListener(t, cm, !1) } } function cm() { for (let t in un.requests) un.requests.hasOwnProperty(t) && un.requests[t].abort() } const eb = (() => typeof Promise == "function" && typeof Promise.resolve == "function" ? e => Promise.resolve().then(e) : (e, n) => n(e, 0))(), ks = Dt.WebSocket || Dt.MozWebSocket, lm = !0, RP = "arraybuffer", um = typeof navigator < "u" && typeof navigator.product == "string" && navigator.product.toLowerCase() === "reactnative"; class IP extends Gw { constructor(e) { super(e), this.supportsBinary = !e.forceBase64 } get name() { return "websocket" } doOpen() { if (!this.check()) return; const e = this.uri(), n = this.opts.protocols, r = um ? {} : qw(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity"); this.opts.extraHeaders && (r.headers = this.opts.extraHeaders); try { this.ws = lm && !um ? n ? new ks(e, n) : new ks(e) : new ks(e, n, r) } catch (o) { return this.emitReserved("error", o) } this.ws.binaryType = this.socket.binaryType || RP, this.addEventListeners() } addEventListeners() { this.ws.onopen = () => { this.opts.autoUnref && this.ws._socket.unref(), this.onOpen() }, this.ws.onclose = e => this.onClose({ description: "websocket connection closed", context: e }), this.ws.onmessage = e => this.onData(e.data), this.ws.onerror = e => this.onError("websocket error", e) } write(e) { this.writable = !1; for (let n = 0; n < e.length; n++) { const r = e[n], o = n === e.length - 1; Uw(r, this.supportsBinary, i => { const s = {}; try { lm && this.ws.send(i) } catch { } o && eb(() => { this.writable = !0, this.emitReserved("drain") }, this.setTimeoutFn) }) } } doClose() { typeof this.ws < "u" && (this.ws.close(), this.ws = null) } uri() { let e = this.query || {}; const n = this.opts.secure ? "wss" : "ws"; let r = ""; this.opts.port && (n === "wss" && Number(this.opts.port) !== 443 || n === "ws" && Number(this.opts.port) !== 80) && (r = ":" + this.opts.port), this.opts.timestampRequests && (e[this.opts.timestampParam] = Xw()), this.supportsBinary || (e.b64 = 1); const o = Zw(e), i = this.opts.hostname.indexOf(":") !== -1; return n + "://" + (i ? "[" + this.opts.hostname + "]" : this.opts.hostname) + r + this.opts.path + (o.length ? "?" + o : "") } check() { return !!ks } } const PP = { websocket: IP, polling: kP }, NP = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/, LP = ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"]; function eu(t) { const e = t, n = t.indexOf("["), r = t.indexOf("]"); n != -1 && r != -1 && (t = t.substring(0, n) + t.substring(n, r).replace(/:/g, ";") + t.substring(r, t.length)); let o = NP.exec(t || ""), i = {}, s = 14; for (; s--;)i[LP[s]] = o[s] || ""; return n != -1 && r != -1 && (i.source = e, i.host = i.host.substring(1, i.host.length - 1).replace(/;/g, ":"), i.authority = i.authority.replace("[", "").replace("]", "").replace(/;/g, ":"), i.ipv6uri = !0), i.pathNames = DP(i, i.path), i.queryKey = BP(i, i.query), i } function DP(t, e) { const n = /\/{2,9}/g, r = e.replace(n, "/").split("/"); return (e.slice(0, 1) == "/" || e.length === 0) && r.splice(0, 1), e.slice(-1) == "/" && r.splice(r.length - 1, 1), r } function BP(t, e) { const n = {}; return e.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function(r, o, i) { o && (n[o] = i) }), n } let tb = class lo extends ze { constructor(e, n = {}) { super(), this.writeBuffer = [], e && typeof e == "object" && (n = e, e = null), e ? (e = eu(e), n.hostname = e.host, n.secure = e.protocol === "https" || e.protocol === "wss", n.port = e.port, e.query && (n.query = e.query)) : n.host && (n.hostname = eu(n.host).host), tc(this, n), this.secure = n.secure != null ? n.secure : typeof location < "u" && location.protocol === "https:", n.hostname && !n.port && (n.port = this.secure ? "443" : "80"), this.hostname = n.hostname || (typeof location < "u" ? location.hostname : "localhost"), this.port = n.port || (typeof location < "u" && location.port ? location.port : this.secure ? "443" : "80"), this.transports = n.transports || ["polling", "websocket"], this.writeBuffer = [], this.prevBufferLen = 0, this.opts = Object.assign({ path: "/engine.io", agent: !1, withCredentials: !1, upgrade: !0, timestampParam: "t", rememberUpgrade: !1, addTrailingSlash: !0, rejectUnauthorized: !0, perMessageDeflate: { threshold: 1024 }, transportOptions: {}, closeOnBeforeunload: !0 }, n), this.opts.path = this.opts.path.replace(/\/$/, "") + (this.opts.addTrailingSlash ? "/" : ""), typeof this.opts.query == "string" && (this.opts.query = SP(this.opts.query)), this.id = null, this.upgrades = null, this.pingInterval = null, this.pingTimeout = null, this.pingTimeoutTimer = null, typeof addEventListener == "function" && (this.opts.closeOnBeforeunload && (this.beforeunloadEventListener = () => { this.transport && (this.transport.removeAllListeners(), this.transport.close()) }, addEventListener("beforeunload", this.beforeunloadEventListener, !1)), this.hostname !== "localhost" && (this.offlineEventListener = () => { this.onClose("transport close", { description: "network connection lost" }) }, addEventListener("offline", this.offlineEventListener, !1))), this.open() } createTransport(e) { const n = Object.assign({}, this.opts.query); n.EIO = zw, n.transport = e, this.id && (n.sid = this.id); const r = Object.assign({}, this.opts.transportOptions[e], this.opts, { query: n, socket: this, hostname: this.hostname, secure: this.secure, port: this.port }); return new PP[e](r) } open() { let e; if (this.opts.rememberUpgrade && lo.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1) e = "websocket"; else if (this.transports.length === 0) { this.setTimeoutFn(() => { this.emitReserved("error", "No transports available") }, 0); return } else e = this.transports[0]; this.readyState = "opening"; try { e = this.createTransport(e) } catch { this.transports.shift(), this.open(); return } e.open(), this.setTransport(e) } setTransport(e) { this.transport && this.transport.removeAllListeners(), this.transport = e, e.on("drain", this.onDrain.bind(this)).on("packet", this.onPacket.bind(this)).on("error", this.onError.bind(this)).on("close", n => this.onClose("transport close", n)) } probe(e) { let n = this.createTransport(e), r = !1; lo.priorWebsocketSuccess = !1; const o = () => { r || (n.send([{ type: "ping", data: "probe" }]), n.once("packet", h => { if (!r) if (h.type === "pong" && h.data === "probe") { if (this.upgrading = !0, this.emitReserved("upgrading", n), !n) return; lo.priorWebsocketSuccess = n.name === "websocket", this.transport.pause(() => { r || this.readyState !== "closed" && (d(), this.setTransport(n), n.send([{ type: "upgrade" }]), this.emitReserved("upgrade", n), n = null, this.upgrading = !1, this.flush()) }) } else { const m = new Error("probe error"); m.transport = n.name, this.emitReserved("upgradeError", m) } })) }; function i() { r || (r = !0, d(), n.close(), n = null) } const s = h => { const m = new Error("probe error: " + h); m.transport = n.name, i(), this.emitReserved("upgradeError", m) }; function c() { s("transport closed") } function u() { s("socket closed") } function a(h) { n && h.name !== n.name && i() } const d = () => { n.removeListener("open", o), n.removeListener("error", s), n.removeListener("close", c), this.off("close", u), this.off("upgrading", a) }; n.once("open", o), n.once("error", s), n.once("close", c), this.once("close", u), this.once("upgrading", a), n.open() } onOpen() { if (this.readyState = "open", lo.priorWebsocketSuccess = this.transport.name === "websocket", this.emitReserved("open"), this.flush(), this.readyState === "open" && this.opts.upgrade) { let e = 0; const n = this.upgrades.length; for (; e < n; e++)this.probe(this.upgrades[e]) } } onPacket(e) { if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing") switch (this.emitReserved("packet", e), this.emitReserved("heartbeat"), e.type) { case "open": this.onHandshake(JSON.parse(e.data)); break; case "ping": this.resetPingTimeout(), this.sendPacket("pong"), this.emitReserved("ping"), this.emitReserved("pong"); break; case "error": const n = new Error("server error"); n.code = e.data, this.onError(n); break; case "message": this.emitReserved("data", e.data), this.emitReserved("message", e.data); break } } onHandshake(e) { this.emitReserved("handshake", e), this.id = e.sid, this.transport.query.sid = e.sid, this.upgrades = this.filterUpgrades(e.upgrades), this.pingInterval = e.pingInterval, this.pingTimeout = e.pingTimeout, this.maxPayload = e.maxPayload, this.onOpen(), this.readyState !== "closed" && this.resetPingTimeout() } resetPingTimeout() { this.clearTimeoutFn(this.pingTimeoutTimer), this.pingTimeoutTimer = this.setTimeoutFn(() => { this.onClose("ping timeout") }, this.pingInterval + this.pingTimeout), this.opts.autoUnref && this.pingTimeoutTimer.unref() } onDrain() { this.writeBuffer.splice(0, this.prevBufferLen), this.prevBufferLen = 0, this.writeBuffer.length === 0 ? this.emitReserved("drain") : this.flush() } flush() { if (this.readyState !== "closed" && this.transport.writable && !this.upgrading && this.writeBuffer.length) { const e = this.getWritablePackets(); this.transport.send(e), this.prevBufferLen = e.length, this.emitReserved("flush") } } getWritablePackets() { if (!(this.maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1)) return this.writeBuffer; let n = 1; for (let r = 0; r < this.writeBuffer.length; r++) { const o = this.writeBuffer[r].data; if (o && (n += _P(o)), r > 0 && n > this.maxPayload) return this.writeBuffer.slice(0, r); n += 2 } return this.writeBuffer } write(e, n, r) { return this.sendPacket("message", e, n, r), this } send(e, n, r) { return this.sendPacket("message", e, n, r), this } sendPacket(e, n, r, o) { if (typeof n == "function" && (o = n, n = void 0), typeof r == "function" && (o = r, r = null), this.readyState === "closing" || this.readyState === "closed") return; r = r || {}, r.compress = r.compress !== !1; const i = { type: e, data: n, options: r }; this.emitReserved("packetCreate", i), this.writeBuffer.push(i), o && this.once("flush", o), this.flush() } close() { const e = () => { this.onClose("forced close"), this.transport.close() }, n = () => { this.off("upgrade", n), this.off("upgradeError", n), e() }, r = () => { this.once("upgrade", n), this.once("upgradeError", n) }; return (this.readyState === "opening" || this.readyState === "open") && (this.readyState = "closing", this.writeBuffer.length ? this.once("drain", () => { this.upgrading ? r() : e() }) : this.upgrading ? r() : e()), this } onError(e) { lo.priorWebsocketSuccess = !1, this.emitReserved("error", e), this.onClose("transport error", e) } onClose(e, n) { (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing") && (this.clearTimeoutFn(this.pingTimeoutTimer), this.transport.removeAllListeners("close"), this.transport.close(), this.transport.removeAllListeners(), typeof removeEventListener == "function" && (removeEventListener("beforeunload", this.beforeunloadEventListener, !1), removeEventListener("offline", this.offlineEventListener, !1)), this.readyState = "closed", this.id = null, this.emitReserved("close", e, n), this.writeBuffer = [], this.prevBufferLen = 0) } filterUpgrades(e) { const n = []; let r = 0; const o = e.length; for (; r < o; r++)~this.transports.indexOf(e[r]) && n.push(e[r]); return n } }; tb.protocol = zw; function $P(t, e = "", n) { let r = t; n = n || typeof location < "u" && location, t == null && (t = n.protocol + "//" + n.host), typeof t == "string" && (t.charAt(0) === "/" && (t.charAt(1) === "/" ? t = n.protocol + t : t = n.host + t), /^(https?|wss?):\/\//.test(t) || (typeof n < "u" ? t = n.protocol + "//" + t : t = "https://" + t), r = eu(t)), r.port || (/^(http|ws)$/.test(r.protocol) ? r.port = "80" : /^(http|ws)s$/.test(r.protocol) && (r.port = "443")), r.path = r.path || "/"; const i = r.host.indexOf(":") !== -1 ? "[" + r.host + "]" : r.host; return r.id = r.protocol + "://" + i + ":" + r.port + e, r.href = r.protocol + "://" + i + (n && n.port === r.port ? "" : ":" + r.port), r } const MP = typeof ArrayBuffer == "function", FP = t => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(t) : t.buffer instanceof ArrayBuffer, nb = Object.prototype.toString, jP = typeof Blob == "function" || typeof Blob < "u" && nb.call(Blob) === "[object BlobConstructor]", HP = typeof File == "function" || typeof File < "u" && nb.call(File) === "[object FileConstructor]"; function vf(t) { return MP && (t instanceof ArrayBuffer || FP(t)) || jP && t instanceof Blob || HP && t instanceof File } function Gs(t, e) { if (!t || typeof t != "object") return !1; if (Array.isArray(t)) { for (let n = 0, r = t.length; n < r; n++)if (Gs(t[n])) return !0; return !1 } if (vf(t)) return !0; if (t.toJSON && typeof t.toJSON == "function" && arguments.length === 1) return Gs(t.toJSON(), !0); for (const n in t) if (Object.prototype.hasOwnProperty.call(t, n) && Gs(t[n])) return !0; return !1 } function UP(t) { const e = [], n = t.data, r = t; return r.data = tu(n, e), r.attachments = e.length, { packet: r, buffers: e } } function tu(t, e) { if (!t) return t; if (vf(t)) { const n = { _placeholder: !0, num: e.length }; return e.push(t), n } else if (Array.isArray(t)) { const n = new Array(t.length); for (let r = 0; r < t.length; r++)n[r] = tu(t[r], e); return n } else if (typeof t == "object" && !(t instanceof Date)) { const n = {}; for (const r in t) Object.prototype.hasOwnProperty.call(t, r) && (n[r] = tu(t[r], e)); return n } return t } function VP(t, e) { return t.data = nu(t.data, e), delete t.attachments, t } function nu(t, e) { if (!t) return t; if (t && t._placeholder === !0) { if (typeof t.num == "number" && t.num >= 0 && t.num < e.length) return e[t.num]; throw new Error("illegal attachments") } else if (Array.isArray(t)) for (let n = 0; n < t.length; n++)t[n] = nu(t[n], e); else if (typeof t == "object") for (const n in t) Object.prototype.hasOwnProperty.call(t, n) && (t[n] = nu(t[n], e)); return t } const KP = ["connect", "connect_error", "disconnect", "disconnecting", "newListener", "removeListener"], WP = 5; var ge; (function(t) { t[t.CONNECT = 0] = "CONNECT", t[t.DISCONNECT = 1] = "DISCONNECT", t[t.EVENT = 2] = "EVENT", t[t.ACK = 3] = "ACK", t[t.CONNECT_ERROR = 4] = "CONNECT_ERROR", t[t.BINARY_EVENT = 5] = "BINARY_EVENT", t[t.BINARY_ACK = 6] = "BINARY_ACK" })(ge || (ge = {})); class zP { constructor(e) { this.replacer = e } encode(e) { return (e.type === ge.EVENT || e.type === ge.ACK) && Gs(e) ? this.encodeAsBinary({ type: e.type === ge.EVENT ? ge.BINARY_EVENT : ge.BINARY_ACK, nsp: e.nsp, data: e.data, id: e.id }) : [this.encodeAsString(e)] } encodeAsString(e) { let n = "" + e.type; return (e.type === ge.BINARY_EVENT || e.type === ge.BINARY_ACK) && (n += e.attachments + "-"), e.nsp && e.nsp !== "/" && (n += e.nsp + ","), e.id != null && (n += e.id), e.data != null && (n += JSON.stringify(e.data, this.replacer)), n } encodeAsBinary(e) { const n = UP(e), r = this.encodeAsString(n.packet), o = n.buffers; return o.unshift(r), o } } function fm(t) { return Object.prototype.toString.call(t) === "[object Object]" } class _f extends ze { constructor(e) { super(), this.reviver = e } add(e) { let n; if (typeof e == "string") { if (this.reconstructor) throw new Error("got plaintext data when reconstructing a packet"); n = this.decodeString(e); const r = n.type === ge.BINARY_EVENT; r || n.type === ge.BINARY_ACK ? (n.type = r ? ge.EVENT : ge.ACK, this.reconstructor = new qP(n), n.attachments === 0 && super.emitReserved("decoded", n)) : super.emitReserved("decoded", n) } else if (vf(e) || e.base64) if (this.reconstructor) n = this.reconstructor.takeBinaryData(e), n && (this.reconstructor = null, super.emitReserved("decoded", n)); else throw new Error("got binary data when not reconstructing a packet"); else throw new Error("Unknown type: " + e) } decodeString(e) { let n = 0; const r = { type: Number(e.charAt(0)) }; if (ge[r.type] === void 0) throw new Error("unknown packet type " + r.type); if (r.type === ge.BINARY_EVENT || r.type === ge.BINARY_ACK) { const i = n + 1; for (; e.charAt(++n) !== "-" && n != e.length;); const s = e.substring(i, n); if (s != Number(s) || e.charAt(n) !== "-") throw new Error("Illegal attachments"); r.attachments = Number(s) } if (e.charAt(n + 1) === "/") { const i = n + 1; for (; ++n && !(e.charAt(n) === "," || n === e.length);); r.nsp = e.substring(i, n) } else r.nsp = "/"; const o = e.charAt(n + 1); if (o !== "" && Number(o) == o) { const i = n + 1; for (; ++n;) { const s = e.charAt(n); if (s == null || Number(s) != s) { --n; break } if (n === e.length) break } r.id = Number(e.substring(i, n + 1)) } if (e.charAt(++n)) { const i = this.tryParse(e.substr(n)); if (_f.isPayloadValid(r.type, i)) r.data = i; else throw new Error("invalid payload") } return r } tryParse(e) { try { return JSON.parse(e, this.reviver) } catch { return !1 } } static isPayloadValid(e, n) { switch (e) { case ge.CONNECT: return fm(n); case ge.DISCONNECT: return n === void 0; case ge.CONNECT_ERROR: return typeof n == "string" || fm(n); case ge.EVENT: case ge.BINARY_EVENT: return Array.isArray(n) && (typeof n[0] == "number" || typeof n[0] == "string" && KP.indexOf(n[0]) === -1); case ge.ACK: case ge.BINARY_ACK: return Array.isArray(n) } } destroy() { this.reconstructor && (this.reconstructor.finishedReconstruction(), this.reconstructor = null) } } class qP { constructor(e) { this.packet = e, this.buffers = [], this.reconPack = e } takeBinaryData(e) { if (this.buffers.push(e), this.buffers.length === this.reconPack.attachments) { const n = VP(this.reconPack, this.buffers); return this.finishedReconstruction(), n } return null } finishedReconstruction() { this.reconPack = null, this.buffers = [] } } const GP = Object.freeze(Object.defineProperty({ __proto__: null, Decoder: _f, Encoder: zP, get PacketType() { return ge }, protocol: WP }, Symbol.toStringTag, { value: "Module" })); function Kt(t, e, n) { return t.on(e, n), function() { t.off(e, n) } } const YP = Object.freeze({ connect: 1, connect_error: 1, disconnect: 1, disconnecting: 1, newListener: 1, removeListener: 1 }); class rb extends ze { constructor(e, n, r) { super(), this.connected = !1, this.recovered = !1, this.receiveBuffer = [], this.sendBuffer = [], this._queue = [], this._queueSeq = 0, this.ids = 0, this.acks = {}, this.flags = {}, this.io = e, this.nsp = n, r && r.auth && (this.auth = r.auth), this._opts = Object.assign({}, r), this.io._autoConnect && this.open() } get disconnected() { return !this.connected } subEvents() { if (this.subs) return; const e = this.io; this.subs = [Kt(e, "open", this.onopen.bind(this)), Kt(e, "packet", this.onpacket.bind(this)), Kt(e, "error", this.onerror.bind(this)), Kt(e, "close", this.onclose.bind(this))] } get active() { return !!this.subs } connect() { return this.connected ? this : (this.subEvents(), this.io._reconnecting || this.io.open(), this.io._readyState === "open" && this.onopen(), this) } open() { return this.connect() } send(...e) { return e.unshift("message"), this.emit.apply(this, e), this } emit(e, ...n) { if (YP.hasOwnProperty(e)) throw new Error('"' + e.toString() + '" is a reserved event name'); if (n.unshift(e), this._opts.retries && !this.flags.fromQueue && !this.flags.volatile) return this._addToQueue(n), this; const r = { type: ge.EVENT, data: n }; if (r.options = {}, r.options.compress = this.flags.compress !== !1, typeof n[n.length - 1] == "function") { const s = this.ids++, c = n.pop(); this._registerAckCallback(s, c), r.id = s } const o = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable; return this.flags.volatile && (!o || !this.connected) || (this.connected ? (this.notifyOutgoingListeners(r), this.packet(r)) : this.sendBuffer.push(r)), this.flags = {}, this } _registerAckCallback(e, n) { var r; const o = (r = this.flags.timeout) !== null && r !== void 0 ? r : this._opts.ackTimeout; if (o === void 0) { this.acks[e] = n; return } const i = this.io.setTimeoutFn(() => { delete this.acks[e]; for (let s = 0; s < this.sendBuffer.length; s++)this.sendBuffer[s].id === e && this.sendBuffer.splice(s, 1); n.call(this, new Error("operation has timed out")) }, o); this.acks[e] = (...s) => { this.io.clearTimeoutFn(i), n.apply(this, [null, ...s]) } } emitWithAck(e, ...n) { const r = this.flags.timeout !== void 0 || this._opts.ackTimeout !== void 0; return new Promise((o, i) => { n.push((s, c) => r ? s ? i(s) : o(c) : o(s)), this.emit(e, ...n) }) } _addToQueue(e) { let n; typeof e[e.length - 1] == "function" && (n = e.pop()); const r = { id: this._queueSeq++, tryCount: 0, pending: !1, args: e, flags: Object.assign({ fromQueue: !0 }, this.flags) }; e.push((o, ...i) => r !== this._queue[0] ? void 0 : (o !== null ? r.tryCount > this._opts.retries && (this._queue.shift(), n && n(o)) : (this._queue.shift(), n && n(null, ...i)), r.pending = !1, this._drainQueue())), this._queue.push(r), this._drainQueue() } _drainQueue(e = !1) { if (!this.connected || this._queue.length === 0) return; const n = this._queue[0]; n.pending && !e || (n.pending = !0, n.tryCount++, this.flags = n.flags, this.emit.apply(this, n.args)) } packet(e) { e.nsp = this.nsp, this.io._packet(e) } onopen() { typeof this.auth == "function" ? this.auth(e => { this._sendConnectPacket(e) }) : this._sendConnectPacket(this.auth) } _sendConnectPacket(e) { this.packet({ type: ge.CONNECT, data: this._pid ? Object.assign({ pid: this._pid, offset: this._lastOffset }, e) : e }) } onerror(e) { this.connected || this.emitReserved("connect_error", e) } onclose(e, n) { this.connected = !1, delete this.id, this.emitReserved("disconnect", e, n) } onpacket(e) { if (e.nsp === this.nsp) switch (e.type) { case ge.CONNECT: e.data && e.data.sid ? this.onconnect(e.data.sid, e.data.pid) : this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)")); break; case ge.EVENT: case ge.BINARY_EVENT: this.onevent(e); break; case ge.ACK: case ge.BINARY_ACK: this.onack(e); break; case ge.DISCONNECT: this.ondisconnect(); break; case ge.CONNECT_ERROR: this.destroy(); const r = new Error(e.data.message); r.data = e.data.data, this.emitReserved("connect_error", r); break } } onevent(e) { const n = e.data || []; e.id != null && n.push(this.ack(e.id)), this.connected ? this.emitEvent(n) : this.receiveBuffer.push(Object.freeze(n)) } emitEvent(e) { if (this._anyListeners && this._anyListeners.length) { const n = this._anyListeners.slice(); for (const r of n) r.apply(this, e) } super.emit.apply(this, e), this._pid && e.length && typeof e[e.length - 1] == "string" && (this._lastOffset = e[e.length - 1]) } ack(e) { const n = this; let r = !1; return function(...o) { r || (r = !0, n.packet({ type: ge.ACK, id: e, data: o })) } } onack(e) { const n = this.acks[e.id]; typeof n == "function" && (n.apply(this, e.data), delete this.acks[e.id]) } onconnect(e, n) { this.id = e, this.recovered = n && this._pid === n, this._pid = n, this.connected = !0, this.emitBuffered(), this.emitReserved("connect"), this._drainQueue(!0) } emitBuffered() { this.receiveBuffer.forEach(e => this.emitEvent(e)), this.receiveBuffer = [], this.sendBuffer.forEach(e => { this.notifyOutgoingListeners(e), this.packet(e) }), this.sendBuffer = [] } ondisconnect() { this.destroy(), this.onclose("io server disconnect") } destroy() { this.subs && (this.subs.forEach(e => e()), this.subs = void 0), this.io._destroy(this) } disconnect() { return this.connected && this.packet({ type: ge.DISCONNECT }), this.destroy(), this.connected && this.onclose("io client disconnect"), this } close() { return this.disconnect() } compress(e) { return this.flags.compress = e, this } get volatile() { return this.flags.volatile = !0, this } timeout(e) { return this.flags.timeout = e, this } onAny(e) { return this._anyListeners = this._anyListeners || [], this._anyListeners.push(e), this } prependAny(e) { return this._anyListeners = this._anyListeners || [], this._anyListeners.unshift(e), this } offAny(e) { if (!this._anyListeners) return this; if (e) { const n = this._anyListeners; for (let r = 0; r < n.length; r++)if (e === n[r]) return n.splice(r, 1), this } else this._anyListeners = []; return this } listenersAny() { return this._anyListeners || [] } onAnyOutgoing(e) { return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.push(e), this } prependAnyOutgoing(e) { return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.unshift(e), this } offAnyOutgoing(e) { if (!this._anyOutgoingListeners) return this; if (e) { const n = this._anyOutgoingListeners; for (let r = 0; r < n.length; r++)if (e === n[r]) return n.splice(r, 1), this } else this._anyOutgoingListeners = []; return this } listenersAnyOutgoing() { return this._anyOutgoingListeners || [] } notifyOutgoingListeners(e) { if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) { const n = this._anyOutgoingListeners.slice(); for (const r of n) r.apply(this, e.data) } } } function Jo(t) { t = t || {}, this.ms = t.min || 100, this.max = t.max || 1e4, this.factor = t.factor || 2, this.jitter = t.jitter > 0 && t.jitter <= 1 ? t.jitter : 0, this.attempts = 0 } Jo.prototype.duration = function() { var t = this.ms * Math.pow(this.factor, this.attempts++); if (this.jitter) { var e = Math.random(), n = Math.floor(e * this.jitter * t); t = Math.floor(e * 10) & 1 ? t + n : t - n } return Math.min(t, this.max) | 0 }; Jo.prototype.reset = function() { this.attempts = 0 }; Jo.prototype.setMin = function(t) { this.ms = t }; Jo.prototype.setMax = function(t) { this.max = t }; Jo.prototype.setJitter = function(t) { this.jitter = t }; class ru extends ze { constructor(e, n) { var r; super(), this.nsps = {}, this.subs = [], e && typeof e == "object" && (n = e, e = void 0), n = n || {}, n.path = n.path || "/socket.io", this.opts = n, tc(this, n), this.reconnection(n.reconnection !== !1), this.reconnectionAttempts(n.reconnectionAttempts || 1 / 0), this.reconnectionDelay(n.reconnectionDelay || 1e3), this.reconnectionDelayMax(n.reconnectionDelayMax || 5e3), this.randomizationFactor((r = n.randomizationFactor) !== null && r !== void 0 ? r : .5), this.backoff = new Jo({ min: this.reconnectionDelay(), max: this.reconnectionDelayMax(), jitter: this.randomizationFactor() }), this.timeout(n.timeout == null ? 2e4 : n.timeout), this._readyState = "closed", this.uri = e; const o = n.parser || GP; this.encoder = new o.Encoder, this.decoder = new o.Decoder, this._autoConnect = n.autoConnect !== !1, this._autoConnect && this.open() } reconnection(e) { return arguments.length ? (this._reconnection = !!e, this) : this._reconnection } reconnectionAttempts(e) { return e === void 0 ? this._reconnectionAttempts : (this._reconnectionAttempts = e, this) } reconnectionDelay(e) { var n; return e === void 0 ? this._reconnectionDelay : (this._reconnectionDelay = e, (n = this.backoff) === null || n === void 0 || n.setMin(e), this) } randomizationFactor(e) { var n; return e === void 0 ? this._randomizationFactor : (this._randomizationFactor = e, (n = this.backoff) === null || n === void 0 || n.setJitter(e), this) } reconnectionDelayMax(e) { var n; return e === void 0 ? this._reconnectionDelayMax : (this._reconnectionDelayMax = e, (n = this.backoff) === null || n === void 0 || n.setMax(e), this) } timeout(e) { return arguments.length ? (this._timeout = e, this) : this._timeout } maybeReconnectOnOpen() { !this._reconnecting && this._reconnection && this.backoff.attempts === 0 && this.reconnect() } open(e) { if (~this._readyState.indexOf("open")) return this; this.engine = new tb(this.uri, this.opts); const n = this.engine, r = this; this._readyState = "opening", this.skipReconnect = !1; const o = Kt(n, "open", function() { r.onopen(), e && e() }), i = Kt(n, "error", s => { r.cleanup(), r._readyState = "closed", this.emitReserved("error", s), e ? e(s) : r.maybeReconnectOnOpen() }); if (this._timeout !== !1) { const s = this._timeout; s === 0 && o(); const c = this.setTimeoutFn(() => { o(), n.close(), n.emit("error", new Error("timeout")) }, s); this.opts.autoUnref && c.unref(), this.subs.push(function() { clearTimeout(c) }) } return this.subs.push(o), this.subs.push(i), this } connect(e) { return this.open(e) } onopen() { this.cleanup(), this._readyState = "open", this.emitReserved("open"); const e = this.engine; this.subs.push(Kt(e, "ping", this.onping.bind(this)), Kt(e, "data", this.ondata.bind(this)), Kt(e, "error", this.onerror.bind(this)), Kt(e, "close", this.onclose.bind(this)), Kt(this.decoder, "decoded", this.ondecoded.bind(this))) } onping() { this.emitReserved("ping") } ondata(e) { try { this.decoder.add(e) } catch (n) { this.onclose("parse error", n) } } ondecoded(e) { eb(() => { this.emitReserved("packet", e) }, this.setTimeoutFn) } onerror(e) { this.emitReserved("error", e) } socket(e, n) { let r = this.nsps[e]; return r ? this._autoConnect && !r.active && r.connect() : (r = new rb(this, e, n), this.nsps[e] = r), r } _destroy(e) { const n = Object.keys(this.nsps); for (const r of n) if (this.nsps[r].active) return; this._close() } _packet(e) { const n = this.encoder.encode(e); for (let r = 0; r < n.length; r++)this.engine.write(n[r], e.options) } cleanup() { this.subs.forEach(e => e()), this.subs.length = 0, this.decoder.destroy() } _close() { this.skipReconnect = !0, this._reconnecting = !1, this.onclose("forced close"), this.engine && this.engine.close() } disconnect() { return this._close() } onclose(e, n) { this.cleanup(), this.backoff.reset(), this._readyState = "closed", this.emitReserved("close", e, n), this._reconnection && !this.skipReconnect && this.reconnect() } reconnect() { if (this._reconnecting || this.skipReconnect) return this; const e = this; if (this.backoff.attempts >= this._reconnectionAttempts) this.backoff.reset(), this.emitReserved("reconnect_failed"), this._reconnecting = !1; else { const n = this.backoff.duration(); this._reconnecting = !0; const r = this.setTimeoutFn(() => { e.skipReconnect || (this.emitReserved("reconnect_attempt", e.backoff.attempts), !e.skipReconnect && e.open(o => { o ? (e._reconnecting = !1, e.reconnect(), this.emitReserved("reconnect_error", o)) : e.onreconnect() })) }, n); this.opts.autoUnref && r.unref(), this.subs.push(function() { clearTimeout(r) }) } } onreconnect() { const e = this.backoff.attempts; this._reconnecting = !1, this.backoff.reset(), this.emitReserved("reconnect", e) } } const pi = {}; function nl(t, e) { typeof t == "object" && (e = t, t = void 0), e = e || {}; const n = $P(t, e.path || "/socket.io"), r = n.source, o = n.id, i = n.path, s = pi[o] && i in pi[o].nsps, c = e.forceNew || e["force new connection"] || e.multiplex === !1 || s; let u; return c ? u = new ru(r, e) : (pi[o] || (pi[o] = new ru(r, e)), u = pi[o]), n.query && !e.query && (e.query = n.queryKey), u.socket(n.path, e) } Object.assign(nl, { Manager: ru, Socket: rb, io: nl, connect: nl }); const XP = { connection: "connection", connected: "connected", disconnect: "disconnect", authenticate: "authenticate", authenticated: "authenticated", userConnected: "userConnected", userDisconnected: "userDisconnected", error: "error" }; class Ef { constructor(e = !1, n = "") { } on(e, n) { var o; const r = this; return (o = this.socket) == null || o.on(e, function() { try { n.call(r, ...arguments) } catch (i) { Nt.warn("[FATAL EVENT]", e), Nt.error("[FATAL ERROR IN HANDLER METHOD]", i) } }), this } onConnected(e) { this.connected = !0, this.playback() } onAuthenticated(e) { console.groupCollapsed("[SOCKET_AUTHENTICATED]", this.constructor.name), Nt.log(e), this.authenticated = !0, this.playback(), console.groupEnd() } authenticate(e) { var n; (n = this.socket) == null || n.emit(XP.authenticate, e) } enqueue(e, n) { Nt.log("[ENQUEING_ACTION]", { action: e, payload: n }), this.queue.push({ action: e, payload: n }) } playback() { if (!this.queue.length) return; Nt.log(`[${this.constructor.name}]`); const e = [...this.queue]; this.queue = [], e.forEach(n => { this.emit(n.action, n.payload) }) } emit(e, n = void 0) { if (this.requiresAuth && !this.authenticated) return this.enqueue(e, n); if (!this.connected) return this.enqueue(e, n); Nt.log("", e, n), this.socket.emit(e, n) } } class ZP extends Ef { constructor() { super(), this.on("error", this.onError) } onError(e) { lt.toast(e.message, "error") } } const ob = new ZP, kt = YR({ domain: Tx, clientId: Sx, audience: Cx, useRefreshTokens: !0, onRedirectCallback: t => { Hw.push(t && t.targetUrl ? t.targetUrl : window.location.pathname) } }); kt.on(kt.AUTH_EVENTS.AUTHENTICATED, async function() { it.defaults.headers.authorization = kt.bearer, it.interceptors.request.use(JP), ue.user = kt.user, await aP.getAccount(), ob.authenticate(kt.bearer), await Po.getFavoritesByAccountId(!1) }); async function JP(t) { if (!kt.isAuthenticated) return t; const e = kt.identity.exp * 1e3, n = e < Date.now(), r = e < Date.now() + 1e3 * 60 * 60 * 12; return n ? await kt.loginWithPopup() : r && (await kt.getTokenSilently(), it.defaults.headers.authorization = kt.bearer, ob.authenticate(kt.bearer)), t } const Kr = (t, e) => { const n = t.__vccOpts || t; for (const [r, o] of e) n[r] = o; return n }, QP = { setup() { return { user: Ke(() => ue.user), account: Ke(() => ue.account), async login() { kt.loginWithPopup() }, async logout() { kt.logout({ returnTo: window.location.origin }) } } } }, eN = { class: "navbar-text" }, tN = { key: 1 }, nN = { class: "dropdown my-2 my-lg-0" }, rN = { type: "button", class: "border-0 selectable no-select", "data-bs-toggle": "dropdown", "aria-expanded": "false" }, oN = { key: 0 }, iN = ["src"], sN = { class: "dropdown-menu dropdown-menu-end p-0", "aria-labelledby": "authDropdown" }, aN = { class: "list-group" }, cN = M("i", { class: "mdi mdi-logout" }, null, -1); function lN(t, e, n, r, o, i) { return Le(), Fe("span", eN, [r.user.isAuthenticated ? (Le(), Fe("div", tN, [M("div", nN, [M("div", rN, [r.account.picture || r.user.picture ? (Le(), Fe("div", oN, [M("img", { src: r.account.picture || r.user.picture, alt: "account photo", height: "50", class: "rounded-circle" }, null, 8, iN)])) : so("", !0)]), M("div", sN, [M("div", aN, [M("div", { class: "list-group-item dropdown-item list-group-item-action text-danger selectable", onClick: e[1] || (e[1] = (...s) => r.logout && r.logout(...s)) }, [cN, sa(" logout ")])])])])])) : (Le(), Fe("button", { key: 0, class: "btn selectable text-success lighten-30 text-uppercase my-2 my-lg-0", onClick: e[0] || (e[0] = (...s) => r.login && r.login(...s)) }, " Login "))]) } const ib = Kr(QP, [["render", lN]]), uN = Object.freeze(Object.defineProperty({ __proto__: null, default: ib }, Symbol.toStringTag, { value: "Module" })); const fN = { setup() { const t = La(""); return { editable: t, async getRecipes() { try { await Io.getRecipes(t.value), t.value = "" } catch (e) { lt.error(e.message, "[GETTING RECIPES]") } }, async getRecipesByAccountId() { try { await Io.getRecipesByAccountId() } catch (e) { lt.error(e.message, "[GETTING RECIPES BY ACCOUNT ID]") } }, async getFavoritesByAccountId() { try { await Po.getFavoritesByAccountId(!0) } catch (e) { lt.error(e.message, "[GETTING FAVORITES BY ACCOUNT ID]") } } } }, components: { Login: ib } }, sb = t => (Ug("data-v-0f72a717"), t = t(), Vg(), t), dN = { class: "row navbar navbar-dark bg-img px-3 align-items-start px-0 position-relative" }, hN = { class: "d-flex justify-content-end align-items-center" }, pN = { class: "form-group d-flex align-items-center" }, mN = { class: "input-group" }, gN = sb(() => M("button", { type: "submit", class: "input-group-text", id: "comment", title: "Post Comment" }, [M("i", { class: "mdi mdi-magnify" })], -1)), yN = sb(() => M("div", { class: "offset-1 col-10 navbar-brand me-0 d-flex justify-content-center" }, [M("div", { class: "d-flex flex-column align-items-center mb-5 pb-2" }, [M("p", { class: "fs-1" }, "All-Spice"), M("p", { class: "sub-title" }, [sa("Cherish Your Family "), M("br"), sa(" And Their Cooking")])])], -1)), wN = { class: "col-8 col-md-6 col-lg-4 d-flex align-items-center text-center bg-light text-green filter px-0" }; function bN(t, e, n, r, o, i) { const s = io("Login"); return Le(), Fe("nav", dN, [M("div", hN, [M("form", { onSubmit: e[1] || (e[1] = Ku(c => r.getRecipes(), ["prevent"])), id: "form", class: "px-3" }, [M("div", pN, [M("div", mN, [Tr(M("input", { "onUpdate:modelValue": e[0] || (e[0] = c => r.editable = c), id: "search", class: "form-control", type: "text", minlength: "3", maxlength: "50", placeholder: "Search...", required: "" }, null, 512), [[bo, r.editable]]), gN])])], 32), Ve(s)]), yN, M("div", wN, [M("p", { onClick: e[2] || (e[2] = c => r.getRecipes()), class: "flex-grow-1 selectable py-2" }, "Home"), M("p", { onClick: e[3] || (e[3] = c => r.getRecipesByAccountId()), class: "flex-grow-1 selectable py-2" }, "My Recipes"), M("p", { onClick: e[4] || (e[4] = c => r.getFavoritesByAccountId()), class: "flex-grow-1 selectable py-2" }, "Favorites")])]) } const ab = Kr(fN, [["render", bN], ["__scopeId", "data-v-0f72a717"]]), vN = Object.freeze(Object.defineProperty({ __proto__: null, default: ab }, Symbol.toStringTag, { value: "Module" })), _N = { setup() { return {} } }, EN = { class: "modal fade", tabindex: "-1" }, AN = { class: "modal-dialog" }, TN = { class: "modal-content" }, SN = { class: "container-fluid" }; function CN(t, e, n, r, o, i) { return Le(), Fe("div", EN, [M("div", AN, [M("div", TN, [M("div", SN, [e2(t.$slots, "default")])])])]) } const cb = Kr(_N, [["render", CN]]), ON = Object.freeze(Object.defineProperty({ __proto__: null, default: cb }, Symbol.toStringTag, { value: "Module" })); class dm { constructor(e) { this.id = e.id, this.name = e.name, this.quantity = e.quantity, this.recipeId = e.recipeId } } class xN { async getIngredients() { const e = await it.get(`api/recipes/${ue.activeRecipe.id}/ingredients`); ue.ingredients = e.data.map(n => new dm(n)) } async createIngredient(e) { const n = await it.post("api/ingredients", e); ue.ingredients.push(new dm(n.data)) } async removeIngredient(e) { await it.delete(`api/ingredients/${e}`), ue.ingredients = ue.ingredients.filter(n => n.id != e) } } const ou = new xN; const kN = { setup() { const t = La({}); return Mu(() => { document.getElementById("recipeDetails").addEventListener("hidden.bs.modal", () => { t.value = {} }) }), { editable: t, account: Ke(() => ue.account), activeRecipe: Ke(() => ue.activeRecipe), ingredients: Ke(() => ue.ingredients), isFav: Ke(() => ue.favorites.find(e => e.id == ue.activeRecipe.id)), isEditing() { ue.isEditing = !0 }, async removeRecipe() { try { if (!await lt.confirm("Are you sure you want to remove this ingredient?")) return; await Io.removeRecipe(), nr.getOrCreateInstance("#recipeDetails").hide() } catch (e) { lt.error(e.message, "[DELETING RECIPE]") } }, async createIngredient() { try { t.value.recipeId = ue.activeRecipe.id, await ou.createIngredient(t.value), t.value = {} } catch (e) { lt.error(e.message, "[CREATING INGREDIENT]") } }, async removeIngredient(e) { try { if (!await lt.confirm("Are you sure you want to remove this ingredient?")) return; await ou.removeIngredient(e) } catch (n) { lt.error(n.message, "[DELETING INGREDIENT]") } }, async createFavorite() { try { Po.createFavorite(ue.activeRecipe.id) } catch (e) { lt.error(e.message, "[CREATING FAVORITE]") } }, async removeFavorite() { try { Po.removeFavorite(ue.activeRecipe.id) } catch (e) { lt.error(e.message, "[DELETING FAVORITE]") } } } } }, Qo = t => (Ug("data-v-cfa8430e"), t = t(), Vg(), t), RN = { key: 0, class: "row" }, IN = { class: "col-12 col-lg-4 p-0 position-relative" }, PN = ["src", "alt"], NN = { class: "position" }, LN = { class: "col-12 col-lg-8 d-flex flex-column justify-content-between" }, DN = { class: "d-flex justify-content-between align-items-start" }, BN = { class: "my-3 p-3" }, $N = { class: "d-flex align-items-center" }, MN = { class: "fs-3 text-green" }, FN = { class: "category-bg fs-5 px-3 m-3" }, jN = { class: "text-secondary fs-5" }, HN = { class: "d-flex" }, UN = { key: 0, type: "button", class: "btn text-dark selectable no-select mdi mdi-dots-horizontal fs-3", "data-bs-toggle": "dropdown", "aria-expanded": "false", title: "More Options" }, VN = { class: "dropdown-menu dropdown-menu-end p-0", "aria-labelledby": "authDropdown" }, KN = { class: "list-group text-center" }, WN = Qo(() => M("p", { class: "mdi mdi-pencil" }, "Edit Recipe", -1)), zN = [WN], qN = Qo(() => M("p", { class: "mdi mdi-trash-can" }, "Delete Recipe", -1)), GN = [qN], YN = Qo(() => M("button", { type: "button", class: "btn mdi mdi-close text-danger fs-3", "data-bs-dismiss": "modal", "aria-label": "Close" }, null, -1)), XN = { class: "row" }, ZN = { class: "col-12 col-lg-6 px-3" }, JN = { class: "food-card" }, QN = Qo(() => M("p", { class: "title fs-4 text-center p-2" }, "Ingredients", -1)), eL = { class: "d-flex flex-column justify-content-between p-3 text-dark" }, tL = { key: 0 }, nL = ["onClick"], rL = { class: "form-group" }, oL = Qo(() => M("label", { for: "ingredient" }, null, -1)), iL = { class: "input-group" }, sL = Qo(() => M("button", { type: "submit", class: "mdi mdi-plus input-group-text", title: "Add Ingredient" }, null, -1)), aL = { class: "text-end p-3" }, cL = { class: "text-secondary" }; function lL(t, e, n, r, o, i) { return r.activeRecipe ? (Le(), Fe("section", RN, [M("div", IN, [M("img", { class: "img-fluid w-100 px-0 rounded", src: r.activeRecipe.img, alt: r.activeRecipe.title }, null, 8, PN), M("div", NN, [r.isFav ? (Le(), Fe("i", { key: 0, onClick: e[0] || (e[0] = s => r.removeFavorite()), class: "mdi mdi-heart fs-4 text-bg rounded-bottom mx-2 px-1 selectable" })) : (Le(), Fe("i", { key: 1, onClick: e[1] || (e[1] = s => r.createFavorite()), class: "mdi mdi-heart-outline fs-4 text-bg rounded-bottom mx-2 px-1 selectable" }))])]), M("div", LN, [M("div", null, [M("div", DN, [M("div", BN, [M("div", $N, [M("p", MN, tn(r.activeRecipe.title), 1), M("p", FN, tn(r.activeRecipe.category), 1)]), M("p", jN, tn(r.activeRecipe.instructions), 1)]), M("div", HN, [r.activeRecipe.creatorId == r.account.id ? (Le(), Fe("button", UN)) : so("", !0), M("div", VN, [M("div", KN, [M("div", { onClick: e[2] || (e[2] = s => r.isEditing()), class: "list-group-item dropdown-item list-group-item-action selectable", "data-bs-toggle": "modal", "data-bs-target": "#recipeForm" }, zN), M("div", { onClick: e[3] || (e[3] = s => r.removeRecipe()), class: "list-group-item dropdown-item list-group-item-action text-danger selectable" }, GN)])]), YN])]), M("section", XN, [M("div", ZN, [M("div", JN, [QN, M("div", eL, [r.ingredients.length ? (Le(), Fe("div", tL, [(Le(!0), Fe(mt, null, Yg(r.ingredients, s => (Le(), Fe("div", { key: s.id, class: "d-flex justify-content-between" }, [M("p", null, tn(s.quantity) + " " + tn(s.name), 1), r.activeRecipe.creatorId == r.account.id ? (Le(), Fe("i", { key: 0, onClick: c => r.removeIngredient(s.id), class: "mdi mdi-trash-can text-danger selectable", title: "Remove Ingredient" }, null, 8, nL)) : so("", !0)]))), 128))])) : so("", !0), r.activeRecipe.creatorId == r.account.id ? (Le(), Fe("form", { key: 1, onSubmit: e[6] || (e[6] = Ku(s => r.createIngredient(), ["prevent"])) }, [M("div", rL, [oL, M("div", iL, [Tr(M("input", { "onUpdate:modelValue": e[4] || (e[4] = s => r.editable.quantity = s), class: "form-control", type: "text", placeholder: "Quantity...", required: "" }, null, 512), [[bo, r.editable.quantity]]), Tr(M("input", { "onUpdate:modelValue": e[5] || (e[5] = s => r.editable.name = s), class: "form-control w-25", type: "text", placeholder: "Add Ingredient...", required: "" }, null, 512), [[bo, r.editable.name]]), sL])])], 32)) : so("", !0)])])])])]), M("div", aL, [M("p", cL, "published by: " + tn(r.activeRecipe.creator.name), 1)])])])) : so("", !0) } const lb = Kr(kN, [["render", lL], ["__scopeId", "data-v-cfa8430e"]]), uL = Object.freeze(Object.defineProperty({ __proto__: null, default: lb }, Symbol.toStringTag, { value: "Module" })); const fL = { setup() { return { appState: Ke(() => ue), isEditing() { ue.isEditing = !1 } } }, components: { Navbar: ab, ModalComponent: cb, RecipeDetails: lb } }, dL = { class: "container-fluid px-0" }, hL = { class: "container-fluid" }, pL = M("i", { class: "mdi mdi-plus fs-1" }, null, -1), mL = [pL]; function gL(t, e, n, r, o, i) { const s = io("Navbar"), c = io("router-view"), u = io("RecipeDetails"), a = io("ModalComponent"), d = io("RecipeForm"); return Le(), Fe(mt, null, [M("header", dL, [Ve(s)]), M("main", hL, [Ve(c)]), M("div", { onClick: e[0] || (e[0] = h => r.isEditing()), class: "d-flex justify-content-center align-items-center add-position selectable", "data-bs-toggle": "modal", "data-bs-target": "#recipeForm" }, mL), Ve(a, { id: "recipeDetails", class: "modal-xl" }, { default: gl(() => [Ve(u)]), _: 1 }), Ve(a, { id: "recipeForm" }, { default: gl(() => [Ve(d)]), _: 1 })], 64) } const yL = Kr(fL, [["render", gL]]); const Af = { props: { recipeProp: { type: Sr, required: !0 } }, setup(t) { return { isFav: Ke(() => ue.favorites.find(e => e.id == t.recipeProp.id)), backgroundImg: Ke(() => `url("${t.recipeProp.img}")`), async setData() { try { Io.setActiveRecipe(t.recipeProp), await ou.getIngredients() } catch (e) { lt.error(e.message, "[GETTING INGREDIENTS]") } }, async createFavorite() { try { Po.createFavorite(t.recipeProp.id) } catch (e) { lt.error(e.message, "[CREATING FAVORITE]") } }, async removeFavorite() { try { Po.removeFavorite(t.recipeProp.id) } catch (e) { lt.error(e.message, "[DELETING FAVORITE]") } } } } }, hm = () => { Z2(t => ({ "25417ba8": t.backgroundImg })) }, pm = Af.setup; Af.setup = pm ? (t, e) => (hm(), pm(t, e)) : hm; const wL = { class: "card-bg elevation-5 d-flex flex-column justify-content-between" }, bL = { class: "d-flex justify-content-between align-items-start" }, vL = { class: "category-bg fs-5 px-3 m-3" }, _L = { class: "fs-5 fw-bold" }; function EL(t, e, n, r, o, i) { return Le(), Fe("div", wL, [M("div", bL, [M("p", vL, tn(n.recipeProp.category), 1), r.isFav ? (Le(), Fe("i", { key: 0, onClick: e[0] || (e[0] = s => r.removeFavorite()), class: "mdi mdi-heart fs-4 text-bg rounded-bottom mx-2 px-1 selectable" })) : (Le(), Fe("i", { key: 1, onClick: e[1] || (e[1] = s => r.createFavorite()), class: "mdi mdi-heart-outline fs-4 text-bg rounded-bottom mx-2 px-1 selectable" }))]), M("div", { onClick: e[2] || (e[2] = s => r.setData()), class: "text-bg m-2 p-1 rounded selectable", "data-bs-toggle": "modal", "data-bs-target": "#recipeDetails" }, [M("p", _L, tn(n.recipeProp.title), 1), M("p", null, tn(n.recipeProp.instructions), 1)])]) } const AL = Kr(Af, [["render", EL], ["__scopeId", "data-v-cf60a139"]]), TL = Object.freeze(Object.defineProperty({ __proto__: null, default: AL }, Symbol.toStringTag, { value: "Module" })), SL = { setup() { MC(() => { ue.isEditing && (t.value = { ...ue.activeRecipe }) }); const t = La({}), e = ["Soup", "Pasta", "Fish", "Salads", "Beef", "Burgers", "Cheese", "Italian", "Mexican", "Specialty Coffee"]; async function n() { try { Io.createRecipe(t.value) } catch (o) { lt.error(o.message, "[CREATING RECIPE]") } } async function r() { try { Io.updateRecipe(t.value) } catch (o) { lt.error(o.message, "[UPDATING RECIPE]") } } return { editable: t, category: e, resetEditable() { t.value = {} }, handleSubmit() { t.value.category != "Category..." && (ue.isEditing ? r() : n(), this.resetEditable(), nr.getOrCreateInstance("#recipeForm").hide()) } } } }, CL = { class: "row" }, OL = M("div", { class: "col-12 title" }, [M("p", { class: "fs-1" }, "New Recipe")], -1), xL = { class: "col-12" }, kL = { class: "col-7 form-group" }, RL = M("label", { for: "title", class: "px-2 fs-5" }, "Title", -1), IL = { class: "col-5 form-group" }, PL = M("label", { for: "category", class: "px-2 fs-5" }, "Category", -1), NL = M("option", { selected: "" }, "Category...", -1), LL = ["value"], DL = { class: "col-12 form-group py-2" }, BL = M("label", { for: "instructions", class: "px-2 fs-5" }, "Instructions", -1), $L = { class: "col-12 form-group pb-2" }, ML = M("label", { for: "img", class: "px-2 fs-5" }, "Image", -1), FL = { class: "text-end pt-3" }, jL = M("button", { class: "btn btn-success", type: "submit" }, "Submit", -1); function HL(t, e, n, r, o, i) { return Le(), Fe("section", CL, [OL, M("div", xL, [M("form", { onSubmit: e[5] || (e[5] = Ku(s => r.handleSubmit(), ["prevent"])), class: "row text-dark py-3" }, [M("div", kL, [RL, Tr(M("input", { "onUpdate:modelValue": e[0] || (e[0] = s => r.editable.title = s), id: "title", class: "form-control", type: "text", minlength: "3", maxlength: "255", placeholder: "Title...", required: "" }, null, 512), [[bo, r.editable.title]])]), M("div", IL, [PL, Tr(M("select", { "onUpdate:modelValue": e[1] || (e[1] = s => r.editable.category = s), id: "category", class: "form-select", required: "" }, [NL, (Le(!0), Fe(mt, null, Yg(r.category, s => (Le(), Fe("option", { key: s, value: s }, tn(s), 9, LL))), 128))], 512), [[Q2, r.editable.category]])]), M("div", DL, [BL, Tr(M("input", { "onUpdate:modelValue": e[2] || (e[2] = s => r.editable.instructions = s), id: "instructions", class: "form-control", type: "text", minlength: "3", maxlength: "255", placeholder: "Instructions...", required: "" }, null, 512), [[bo, r.editable.instructions]])]), M("div", $L, [ML, Tr(M("input", { "onUpdate:modelValue": e[3] || (e[3] = s => r.editable.img = s), id: "img", class: "form-control", type: "url", minlength: "3", maxlength: "255", placeholder: "Url...", required: "" }, null, 512), [[bo, r.editable.img]])]), M("div", FL, [M("button", { onClick: e[4] || (e[4] = s => r.resetEditable()), class: "btn mx-3", type: "reset", "data-bs-dismiss": "modal" }, "Cancel"), jL])], 32)])]) } const UL = Kr(SL, [["render", HL]]), VL = Object.freeze(Object.defineProperty({ __proto__: null, default: UL }, Symbol.toStringTag, { value: "Module" })); function KL(t) { Object.entries(Object.assign({ "./components/Login.vue": uN, "./components/ModalComponent.vue": ON, "./components/Navbar.vue": vN, "./components/RecipeCard.vue": TL, "./components/RecipeDetails.vue": uL, "./components/RecipeForm.vue": VL })).forEach(([n, r]) => { const o = r.name || n.substring(n.lastIndexOf("/") + 1).replace(/\.\w+$/, ""); t.component(o, r.default) }) } class WL extends Ef { constructor() { super(), this.on("IS_TESTED", this.onTest) } onTest(e) { Nt.log("Received IS_TESTED", e) } } const zL = new WL, qL = Object.freeze(Object.defineProperty({ __proto__: null, testHandler: zL }, Symbol.toStringTag, { value: "Module" })); function GL() { const t = Object.assign({ "../handlers/TestHandler.js": qL }); return Object.entries(t).forEach(([e, n]) => { const r = e.substring(e.lastIndexOf("/") + 1).replace(/\.\w+$/, ""); t[r] = n }), t } class YL extends Ef { constructor() { super(); ld(this, "handlers", {}); this.handlers = GL() } get(n) { return this.handlers[n] } } new YL; const ub = oO(yL); KL(ub); ub.use(Hw).mount("#app"); export { ue as A, mt as F, lt as P, AL as R, Kr as _, M as a, Ke as b, Fe as c, Mu as d, io as e, Yg as f, Ve as g, Le as o, Io as r, tn as t };
